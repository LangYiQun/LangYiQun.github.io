<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"langyiqun.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="RubyRuby是一个详细的内存子系统的模拟模型。可以通过各种替换策略、一致性协议实现、互连网络、DMA和内存控制器、发起内存请求和处理响应的各种定序器来建模包含（inclusive）&#x2F;独占（exclusive）缓存层次结构。这些模型是模块化的、灵活的和高度可配置的。 Ruby有以下三个特点：  关注点分离。将内存系统的各个模型模块化，例如，一致性协议规范与替换策略和缓存索引映射是分开的">
<meta property="og:type" content="article">
<meta property="og:title" content="Gem5模拟器学习（八）————通过Ruby实现缓存一致性协议">
<meta property="og:url" content="https://langyiqun.github.io/2023/11/25/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89/index.html">
<meta property="og:site_name" content="夏虫的博客">
<meta property="og:description" content="RubyRuby是一个详细的内存子系统的模拟模型。可以通过各种替换策略、一致性协议实现、互连网络、DMA和内存控制器、发起内存请求和处理响应的各种定序器来建模包含（inclusive）&#x2F;独占（exclusive）缓存层次结构。这些模型是模块化的、灵活的和高度可配置的。 Ruby有以下三个特点：  关注点分离。将内存系统的各个模型模块化，例如，一致性协议规范与替换策略和缓存索引映射是分开的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://langyiqun.github.io/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89/image-20231204190803198.png">
<meta property="og:image" content="https://langyiqun.github.io/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89/v2-c033b43df7af58f9468432e564c4266f_720w.png">
<meta property="article:published_time" content="2023-11-25T07:19:53.000Z">
<meta property="article:modified_time" content="2023-12-09T07:13:23.369Z">
<meta property="article:author" content="Mr .L">
<meta property="article:tag" content="Ruby">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://langyiqun.github.io/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89/image-20231204190803198.png">


<link rel="canonical" href="https://langyiqun.github.io/2023/11/25/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://langyiqun.github.io/2023/11/25/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89/","path":"2023/11/25/Gem5模拟器学习（八）/","title":"Gem5模拟器学习（八）————通过Ruby实现缓存一致性协议"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Gem5模拟器学习（八）————通过Ruby实现缓存一致性协议 | 夏虫的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">夏虫的博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">却道天凉好个秋</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Ruby"><span class="nav-number">1.</span> <span class="nav-text">Ruby</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.</span> <span class="nav-text">实现一致性协议的步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%B3%A8%E5%86%8C%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">2.1.</span> <span class="nav-text">1. 注册状态机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BC%96%E5%86%99%E7%8A%B6%E6%80%81%E6%9C%BA%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.</span> <span class="nav-text">2.编写状态机文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%8A%B6%E6%80%81%E6%9C%BA%E5%A3%B0%E6%98%8E"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.1 状态机声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E7%8A%B6%E6%80%81%E6%9C%BA%E5%8F%82%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2 状态机参数声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E7%8A%B6%E6%80%81%E5%A3%B0%E6%98%8E"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.3 状态声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E4%BA%8B%E4%BB%B6%E5%A3%B0%E6%98%8E"><span class="nav-number">2.2.4.</span> <span class="nav-text">2.4 事件声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.2.5.</span> <span class="nav-text">2.5 用户定义结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Entry"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">Entry</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TBE"><span class="nav-number">2.2.5.2.</span> <span class="nav-text">TBE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TBETable"><span class="nav-number">2.2.5.3.</span> <span class="nav-text">TBETable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">2.2.5.4.</span> <span class="nav-text">外部函数声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E6%9D%BF%E4%BB%A3%E7%A0%81"><span class="nav-number">2.2.5.5.</span> <span class="nav-text">样板代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AB%AF%E5%8F%A3"><span class="nav-number">2.2.6.</span> <span class="nav-text">2.6 输入输出端口</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Mr .L</p>
  <div class="site-description" itemprop="description">this is a personal blog of Mr .L</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/yourname" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/yourname" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-facebook fa-fw"></i>FB Page</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/yourname" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://youtube.com/yourname" title="YouTube → https:&#x2F;&#x2F;youtube.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTube</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/yourname" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
      <span class="links-of-author-item">
        <a href="skype:yourname?call|chat" title="Skype → skype:yourname?call|chat" rel="noopener me" target="_blank"><i class="fab fa-skype fa-fw"></i>Skype</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://langyiqun.github.io/2023/11/25/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr .L">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏虫的博客">
      <meta itemprop="description" content="this is a personal blog of Mr .L">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Gem5模拟器学习（八）————通过Ruby实现缓存一致性协议 | 夏虫的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Gem5模拟器学习（八）————通过Ruby实现缓存一致性协议
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-25 15:19:53" itemprop="dateCreated datePublished" datetime="2023-11-25T15:19:53+08:00">2023-11-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-09 15:13:23" itemprop="dateModified" datetime="2023-12-09T15:13:23+08:00">2023-12-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h1><p>Ruby是一个详细的内存子系统的模拟模型。可以通过各种替换策略、一致性协议实现、互连网络、DMA和内存控制器、发起内存请求和处理响应的各种定序器来建模包含（inclusive）&#x2F;独占（exclusive）缓存层次结构。这些模型是模块化的、灵活的和高度可配置的。</p>
<p>Ruby有以下三个特点：</p>
<ul>
<li><strong>关注点分离</strong>。将内存系统的各个模型模块化，例如，一致性协议规范与替换策略和缓存索引映射是分开的，网络拓扑结构与实现也是分开指定的。</li>
<li><strong>丰富的可配置性</strong>。几乎所有影响内存层次结构的功能和时序都可以控制。</li>
<li><strong>快速的原型设计</strong>。使用一种高级规范语言SLICC来指定各种控制器的功能。</li>
</ul>
<p><strong>SLICC + 一致性协议</strong></p>
<p>SLICC：Specification Language for Implementing Cache Coherence，是一种特定领域的语言，用于指定缓存一致性协议。</p>
<p>缓存一致性协议以状态机的方式工作，而SLICC用于指定状态机的行为。SLICC文件以“.sm”结尾，它们是状态机文件。每个文件描述状态、某些事件从开始状态到结束状态的转换，以及在转换过程中要采取的操作。</p>
<p>每个一致性协议都由多个SLICC状态机文件组成。这些文件是用SLCC编译器编译的，该编译器是用Python编写的，也是gem5源代码的一部分。SLIC编译器<u>获取状态机文件</u>并<u>输出一组C++文件</u>，这些文件与gem5的所有其他文件一起编译。这些文件包括SimObject声明文件以及SimObjects和其他C++对象的实现文件。</p>
<h1 id="实现一致性协议的步骤"><a href="#实现一致性协议的步骤" class="headerlink" title="实现一致性协议的步骤"></a>实现一致性协议的步骤</h1><p>以下是对官网教程<a target="_blank" rel="noopener" href="https://www.gem5.org/documentation/learning_gem5/part3/MSIintro/">gem5: Introduction to Ruby</a>的内容整理，教程的目标是实现MSI协议，协议的具体内容可以在《A Primer on Memory Consistency and Cache Coherence》书的第8.2节找到 (pages 141-149)</p>
<h2 id="1-注册状态机"><a href="#1-注册状态机" class="headerlink" title="1. 注册状态机"></a>1. 注册状态机</h2><p>MSI协议是通过SLICC语言编写的状态机文件实现的，这些状态机文件是用SLCC编译器编译的，会通过scons与gem5其他文件一起编译，因此需要为SCons创建一个文件，以便知道要编译什么。这里我们创建一个<code>Sconsopts</code>文件，而不是<code>Sconscript</code>文件，这是因为<code>Sconsopts</code>会在<code>Sconscript</code>之前执行，而我们也需要在编译gem5之前编译状态机文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Import(&#x27;*&#x27;)</span><br><span class="line"># 注册协议名‘MSI’，Scons将假定一个名为MSI.slicc的文件</span><br><span class="line">main.Append(ALL_PROTOCOLS=[&#x27;MSI&#x27;])</span><br><span class="line"># 告诉SCons在当前目录中查找要传递给SLCC编译器的文件。</span><br><span class="line">main.Append(PROTOCOL_DIRS=[Dir(&#x27;.&#x27;)])</span><br></pre></td></tr></table></figure>



<h2 id="2-编写状态机文件"><a href="#2-编写状态机文件" class="headerlink" title="2.编写状态机文件"></a>2.编写状态机文件</h2><p>编写状态机文件是实现一致性协议的最主要工作，状态机文件通常包含以下几个部分：</p>
<ul>
<li><p>Parameters</p>
<p>These are the parameters for the SimObject that will be generated from the SLICC code.</p>
</li>
<li><p>Declaring required structures and functions</p>
<p>This section declares the states, events, and many other required structures for the state machine.</p>
</li>
<li><p>In port code blocks</p>
<p>Contain code that looks at incoming messages from the (<code>in_port</code>) message buffers and determines what events to trigger.</p>
</li>
<li><p>Actions</p>
<p>These are simple one-effect code blocks (e.g., send a message) that are executed when going through a transition.</p>
</li>
<li><p>Transitions</p>
<p>Specify actions to execute given a starting state and an event and the final state. This is the meat of the state machine definition.</p>
</li>
</ul>
<p>Over the next few sections we will go over how to write each of these components of the protocol.</p>
<h3 id="2-1-状态机声明"><a href="#2-1-状态机声明" class="headerlink" title="2.1 状态机声明"></a>2.1 状态机声明</h3><p>创建一个名为<code>MSI-call.sm</code>的文件，并按以下格式声明状态机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">machine(MachineType:L1Cache, &quot;MSI cache&quot;)</span><br><span class="line">    : &lt;parameters&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &lt;All state machine code&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MachineType:L1Cache</code>将状态机命名为<code>L1Cache</code>，SLICC 将使用该名称为我们生成许多不同的对象。例如，一旦编译了这个文件，就会有一个新的 SimObject: <code>L1Cache_Controller</code> 作为缓存控制器。这个声明中还包括对这个状态机的描述: “ MSI cache”。</p>
<h3 id="2-2-状态机参数声明"><a href="#2-2-状态机参数声明" class="headerlink" title="2.2 状态机参数声明"></a>2.2 状态机参数声明</h3><p>状态机参数的声明在冒号（：）之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">machine(MachineType:L1Cache, &quot;MSI cache&quot;)</span><br><span class="line">: Sequencer *sequencer;</span><br><span class="line">  CacheMemory *cacheMemory;</span><br><span class="line">  bool send_evictions;</span><br><span class="line">  # “To” buffer</span><br><span class="line">  MessageBuffer * requestToDir, network=&quot;To&quot;, virtual_network=&quot;0&quot;, vnet_type=&quot;request&quot;;</span><br><span class="line">  MessageBuffer * responseToDirOrSibling, network=&quot;To&quot;, virtual_network=&quot;2&quot;, vnet_type=&quot;response&quot;;</span><br><span class="line">  # “From” buffer</span><br><span class="line">  MessageBuffer * forwardFromDir, network=&quot;From&quot;, virtual_network=&quot;1&quot;, vnet_type=&quot;forward&quot;;</span><br><span class="line">  MessageBuffer * responseFromDirOrSibling, network=&quot;From&quot;, virtual_network=&quot;2&quot;, vnet_type=&quot;response&quot;;</span><br><span class="line">  # “To” buffer</span><br><span class="line">  MessageBuffer * mandatoryQueue;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>排序器（Sequencer）</p>
<p>Sequencer是一个带有从端口的gem5 MemObject，因此它可以接受来自其他对象的内存请求。Swquencer接受来自CPU（或其他主端口）的请求，并将gem5数据包转换为RubyRequest。最后，RubyRequest被推送到状态机的强制队列（commandoryQueue）中。</p>
</li>
<li><p>缓存数据（Cache Memory）</p>
<p>用于保存缓存数据（即缓存条目）的内容。</p>
</li>
<li><p>消息缓冲区（MessageBuffer）</p>
<p>消息缓冲区是状态机和Ruby网络之间的接口。通过消息缓冲区发送和接收消息。因此，对于我们协议中的每个虚拟通道，我们都需要一个单独的消息缓冲区。</p>
<p>虚拟网络的作用是防止死锁。MSI协议需要三个不同的虚拟网络。在该协议中，最高优先级是响应Response（虚拟网络2），其次是转发的请求Forwarded Requests（虚拟网络1），然后请求Requests具有最低优先级（虚拟网络0）。</p>
<p>代码中有两个”To” buffer，两个”From” buffer和一个Special buffer。其中，”To” buffer类似于gem5中的主端口，是此控制器用来向系统中的其他控制器发送消息的消息缓冲区；”From” buffer类似于gem5中的从端口，是此控制器用来接收系统中其他控制器发送的消息的消息缓冲区；对于Special buffer，Sequencer使用此消息缓冲区将gem5数据包转换为Ruby请求。与其他消息缓冲区不同，commandoryQueue不连接到Ruby网络，并且，此消息缓冲区的名称是硬编码的，必须为“commandoryQueue”</p>
<p>两个”To” buffer一个用于低优先级请求，另一个用于高优先级响应。优先级基于其他控制器查看消息缓冲区的顺序。类似地，两个”From” buffer使该缓存可以通过两种不同的方式接收消息，要么作为来自目录的转发请求，要么作为对该控制器发出的请求的响应。响应的优先级高于转发的请求。</p>
</li>
</ul>
<p>如前所述，状态机文件在经过SLICC编译后会成为Simobject文件，以上代码编译后产生的文件为<code>L1Cache_Controller.py</code>，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from m5.params import *</span><br><span class="line">from m5.SimObject import SimObject</span><br><span class="line">from Controller import RubyController</span><br><span class="line"></span><br><span class="line">class L1Cache_Controller(RubyController):</span><br><span class="line">    type = &#x27;L1Cache_Controller&#x27;</span><br><span class="line">    cxx_header = &#x27;mem/protocol/L1Cache_Controller.hh&#x27;</span><br><span class="line">    sequencer = Param.RubySequencer(&quot;&quot;)</span><br><span class="line">    cacheMemory = Param.RubyCache(&quot;&quot;)</span><br><span class="line">    send_evictions = Param.Bool(&quot;&quot;)</span><br><span class="line">    requestToDir = Param.MessageBuffer(&quot;&quot;)</span><br><span class="line">    responseToDirOrSibling = Param.MessageBuffer(&quot;&quot;)</span><br><span class="line">    forwardFromDir = Param.MessageBuffer(&quot;&quot;)</span><br><span class="line">    responseFromDirOrSibling = Param.MessageBuffer(&quot;&quot;)</span><br><span class="line">    mandatoryQueue = Param.MessageBuffer(&quot;&quot;)</span><br></pre></td></tr></table></figure>

<p>对这个文件，<strong>不能做任何修改！</strong></p>
<h3 id="2-3-状态声明"><a href="#2-3-状态声明" class="headerlink" title="2.3 状态声明"></a>2.3 状态声明</h3><p>通过<code>state_declaration</code>声明状态机的所有稳定和瞬态。对瞬态的命名遵循Sorin等人的命名约定。例如，瞬态“IM_AD”对应于在等待确认（A）和数据（D）时从无效（I）移动到已修改（M）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">state_declaration(State, desc=&quot;Cache states&quot;) &#123;</span><br><span class="line">    I,      AccessPermission:Invalid,</span><br><span class="line">                desc=&quot;Not present/Invalid&quot;;</span><br><span class="line"></span><br><span class="line">    // States moving out of I</span><br><span class="line">    IS_D,   AccessPermission:Invalid,</span><br><span class="line">                desc=&quot;Invalid, moving to S, waiting for data&quot;;</span><br><span class="line">    IM_AD,  AccessPermission:Invalid,</span><br><span class="line">                desc=&quot;Invalid, moving to M, waiting for acks and data&quot;;</span><br><span class="line">    IM_A,   AccessPermission:Busy,</span><br><span class="line">                desc=&quot;Invalid, moving to M, waiting for acks&quot;;</span><br><span class="line"></span><br><span class="line">    S,      AccessPermission:Read_Only,</span><br><span class="line">                desc=&quot;Shared. Read-only, other caches may have the block&quot;;</span><br><span class="line"></span><br><span class="line">    // States moving out of S</span><br><span class="line">    SM_AD,  AccessPermission:Read_Only,</span><br><span class="line">                desc=&quot;Shared, moving to M, waiting for acks and &#x27;data&#x27;&quot;;</span><br><span class="line">    SM_A,   AccessPermission:Read_Only,</span><br><span class="line">                desc=&quot;Shared, moving to M, waiting for acks&quot;;</span><br><span class="line"></span><br><span class="line">    M,      AccessPermission:Read_Write,</span><br><span class="line">                desc=&quot;Modified. Read &amp; write permissions. Owner of block&quot;;</span><br><span class="line"></span><br><span class="line">    // States moving to Invalid</span><br><span class="line">    MI_A,   AccessPermission:Busy,</span><br><span class="line">                desc=&quot;Was modified, moving to I, waiting for put ack&quot;;</span><br><span class="line">    SI_A,   AccessPermission:Busy,</span><br><span class="line">                desc=&quot;Was shared, moving to I, waiting for put ack&quot;;</span><br><span class="line">    II_A,   AccessPermission:Invalid,</span><br><span class="line">                desc=&quot;Sent valid data before receiving put ack. &quot;Waiting for put ack.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个状态都有一个相关的访问权限<code>AccessPermission</code>，包括无效（<strong>Invalid</strong>）、不存在（<strong>NotPresent</strong>）、忙（<strong>Busy</strong>）、只读（<strong>Read_Only</strong>）、读写（<strong>Read_Write</strong>），访问权限用于对缓存进行功能访问<em>functional accesses</em>。对于功能访问，将检查所有缓存，看它们是否有具有匹配地址的相应块。</p>
<h3 id="2-4-事件声明"><a href="#2-4-事件声明" class="headerlink" title="2.4 事件声明"></a>2.4 事件声明</h3><p>声明由该缓存控制器的传入消息触发的所有事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">enumeration(Event, desc=&quot;Cache events&quot;) &#123;</span><br><span class="line">    // From the processor/sequencer/mandatory queue</span><br><span class="line">    Load,           desc=&quot;Load from processor&quot;;</span><br><span class="line">    Store,          desc=&quot;Store from processor&quot;;</span><br><span class="line"></span><br><span class="line">    // Internal event (only triggered from processor requests)</span><br><span class="line">    Replacement,    desc=&quot;Triggered when block is chosen as victim&quot;;</span><br><span class="line"></span><br><span class="line">    // Forwarded request from other cache via dir on the forward network</span><br><span class="line">    FwdGetS,        desc=&quot;Directory sent us a request to satisfy GetS. We must have the block in M to respond to this.&quot;;</span><br><span class="line">    FwdGetM,        desc=&quot;Directory sent us a request to satisfy GetM. We must have the block in M to respond to this.&quot;;</span><br><span class="line">    Inv,            desc=&quot;Invalidate from the directory.&quot;;</span><br><span class="line">    PutAck,         desc=&quot;Response from directory after we issue a put. This must be on the fwd network to avoid deadlock.&quot;;</span><br><span class="line"></span><br><span class="line">    // Responses from directory</span><br><span class="line">    DataDirNoAcks,  desc=&quot;Data from directory (acks = 0)&quot;;</span><br><span class="line">    DataDirAcks,    desc=&quot;Data from directory (acks &gt; 0)&quot;;</span><br><span class="line"></span><br><span class="line">    // Responses from other caches</span><br><span class="line">    DataOwner,      desc=&quot;Data from owner&quot;;</span><br><span class="line">    InvAck,         desc=&quot;Invalidation ack from other cache after Inv&quot;;</span><br><span class="line"></span><br><span class="line">    // Special event to simplify implementation</span><br><span class="line">    LastInvAck,     desc=&quot;Triggered after the last ack is received&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>状态和事件可以参考表8.3的缓存控制器转换表</p>
<p><img src="/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89/image-20231204190803198.png" alt="image-20231204190803198"></p>
<h3 id="2-5-用户定义结构体"><a href="#2-5-用户定义结构体" class="headerlink" title="2.5 用户定义结构体"></a>2.5 用户定义结构体</h3><p>下面定义的是在这个控制器的其他地方用到的结构体</p>
<h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><p>这是存储在CacheMemory中的结构。它只需要包含数据和状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">structure(Entry, desc=&quot;Cache entry&quot;, interface=&quot;AbstractCacheEntry&quot;) &#123;</span><br><span class="line">    State CacheState,        desc=&quot;cache state&quot;;</span><br><span class="line">    DataBlock DataBlk,       desc=&quot;Data in the block&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TBE"><a href="#TBE" class="headerlink" title="TBE"></a>TBE</h4><p>TBE是“事务缓冲区条目”。这存储了瞬态期间所需的信息。这就像MSHR。它在该协议中起MSHR的作用，但该条目也被分配用于其他用途。在该协议中，它将存储状态（通常需要）、数据（通常也需要）以及该块当前正在等待的ack数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">structure(TBE, desc=&quot;Entry for transient requests&quot;) &#123;</span><br><span class="line">    State TBEState,         desc=&quot;State of block&quot;;</span><br><span class="line">    DataBlock DataBlk,      desc=&quot;Data for the block. Needed for MI_A&quot;;</span><br><span class="line">    int AcksOutstanding, default=0, desc=&quot;Number of acks left to receive.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TBETable"><a href="#TBETable" class="headerlink" title="TBETable"></a>TBETable</h4><p>还需要一个存放所有TBE的地方。其中<code>external=&quot;yes&quot;</code>表明这是一个外部定义的类；它是在SLICC之外的C++中定义的。因此，我们需要声明我们将要使用它，并声明我们将对其调用的任何函数。您可以在src&#x2F;mem&#x2F;ruby&#x2F;structures&#x2F;TBETable.hh中找到TBETable的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">structure(TBETable, external=&quot;yes&quot;) &#123;</span><br><span class="line">  TBE lookup(Addr);</span><br><span class="line">  void allocate(Addr);</span><br><span class="line">  void deallocate(Addr);</span><br><span class="line">  bool isPresent(Addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="外部函数声明"><a href="#外部函数声明" class="headerlink" title="外部函数声明"></a>外部函数声明</h4><p>如果我们要在文件的其余部分中使用AbstractController中的任何函数，都需要声明它们。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tick clockEdge();</span><br><span class="line">void set_cache_entry(AbstractCacheEntry a);</span><br><span class="line">void unset_cache_entry();</span><br><span class="line">void set_tbe(TBE b);</span><br><span class="line">void unset_tbe();</span><br></pre></td></tr></table></figure>

<h4 id="样板代码"><a href="#样板代码" class="headerlink" title="样板代码"></a>样板代码</h4><p>下面这一组样板工具代码很少在不同的协议之间发生变化。在AbstractController中，我们必须实现一组纯虚拟的函数。</p>
<ul>
<li>getState</li>
</ul>
<p>Given a TBE, cache entry, and address return the state of the block. This is called on the block to decide which transition to execute when an event is triggered. Usually, you return the state in the TBE or cache entry, whichever is valid.</p>
<p>给定IBE，entry和地址，返回地址所在缓存块的状态</p>
<ul>
<li>setState</li>
</ul>
<p>Given a TBE, cache entry, and address make sure the state is set correctly on the block. This is called at the end of the transition to set the final state on the block.</p>
<ul>
<li>getAccessPermission</li>
</ul>
<p>Get the access permission of a block. This is used during functional access to decide whether or not to functionally access the block. It is similar to <code>getState</code>, get the information from the TBE if valid, cache entry, if valid, or the block is not present.</p>
<ul>
<li>setAccessPermission</li>
</ul>
<p>Like <code>getAccessPermission</code>, but sets the permission.</p>
<ul>
<li>functionalRead</li>
</ul>
<p>Functionally read the data. It is possible the TBE has more up-to-date information, so check that first. Note: testAndRead&#x2F;Write defined in src&#x2F;mem&#x2F;ruby&#x2F;slicc_interface&#x2F;Util.hh</p>
<ul>
<li>functionalWrite</li>
</ul>
<p>Functionally write the data. Similarly, you may need to update the data in both the TBE and the cache entry.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">State getState(TBE tbe, Entry cache_entry, Addr addr) &#123;</span><br><span class="line">    // The TBE state will override the state in cache memory, if valid</span><br><span class="line">    if (is_valid(tbe)) &#123; return tbe.TBEState; &#125;</span><br><span class="line">    // Next, if the cache entry is valid, it holds the state</span><br><span class="line">    else if (is_valid(cache_entry)) &#123; return cache_entry.CacheState; &#125;</span><br><span class="line">    // If the block isn&#x27;t present, then it&#x27;s state must be I.</span><br><span class="line">    else &#123; return State:I; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void setState(TBE tbe, Entry cache_entry, Addr addr, State state) &#123;</span><br><span class="line">  if (is_valid(tbe)) &#123; tbe.TBEState := state; &#125;</span><br><span class="line">  if (is_valid(cache_entry)) &#123; cache_entry.CacheState := state; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AccessPermission getAccessPermission(Addr addr) &#123;</span><br><span class="line">    TBE tbe := TBEs[addr];</span><br><span class="line">    if(is_valid(tbe)) &#123;</span><br><span class="line">        return L1Cache_State_to_permission(tbe.TBEState);</span><br><span class="line">    &#125;</span><br><span class="line">    Entry cache_entry := getCacheEntry(addr);</span><br><span class="line">    if(is_valid(cache_entry)) &#123;</span><br><span class="line">        return L1Cache_State_to_permission(cache_entry.CacheState);</span><br><span class="line">    &#125;</span><br><span class="line">    return AccessPermission:NotPresent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void setAccessPermission(Entry cache_entry, Addr addr, State state) &#123;</span><br><span class="line">    if (is_valid(cache_entry)) &#123;</span><br><span class="line">        cache_entry.changePermission(L1Cache_State_to_permission(state));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void functionalRead(Addr addr, Packet *pkt) &#123;</span><br><span class="line">    TBE tbe := TBEs[addr];</span><br><span class="line">    if(is_valid(tbe)) &#123;</span><br><span class="line">        testAndRead(addr, tbe.DataBlk, pkt);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        testAndRead(addr, getCacheEntry(addr).DataBlk, pkt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int functionalWrite(Addr addr, Packet *pkt) &#123;</span><br><span class="line">    int num_functional_writes := 0;</span><br><span class="line">    TBE tbe := TBEs[addr];</span><br><span class="line">    if(is_valid(tbe)) &#123;</span><br><span class="line">        num_functional_writes := num_functional_writes +</span><br><span class="line">            testAndWrite(addr, tbe.DataBlk, pkt);</span><br><span class="line">        return num_functional_writes;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<p>以下是对这些状态和转换的高层次描述：</p>
<p><img src="/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89/v2-c033b43df7af58f9468432e564c4266f_720w.png" alt="img"></p>
<h3 id="2-6-输入输出端口"><a href="#2-6-输入输出端口" class="headerlink" title="2.6 输入输出端口"></a>2.6 输入输出端口</h3><p>参考链接🔗</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/539342291">gem5模拟器入门（四） - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34898487/article/details/134252221">EM5官方教程全流程： part 3 RUBY-CSDN博客</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Ruby/" rel="tag"># Ruby</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/11/25/Cache%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/" rel="prev" title="">
                  <i class="fa fa-angle-left"></i> 
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/11/29/%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C/" rel="next" title="互联网络">
                  互联网络 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Mr .L</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
