<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"langyiqun.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文是官网教程gem5: Creating SimObjects in the memory system的学习笔记。 本节教程是创建一个位于CPU和内存总线之间的阻塞式简单内存对象，主要实现了基本请求的传递。在下一节教程中，会在本节创建的简单内存对象之上增加部分逻辑，使其成为一个非常简单的阻塞单处理器缓存。下图是整个系统的示意图，其中，我们创建的内存对象有两个CPU侧的从端口（slave por">
<meta property="og:type" content="article">
<meta property="og:title" content="Gem5模拟器学习（四）">
<meta property="og:url" content="https://langyiqun.github.io/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/index.html">
<meta property="og:site_name" content="郎轶群的博客">
<meta property="og:description" content="本文是官网教程gem5: Creating SimObjects in the memory system的学习笔记。 本节教程是创建一个位于CPU和内存总线之间的阻塞式简单内存对象，主要实现了基本请求的传递。在下一节教程中，会在本节创建的简单内存对象之上增加部分逻辑，使其成为一个非常简单的阻塞单处理器缓存。下图是整个系统的示意图，其中，我们创建的内存对象有两个CPU侧的从端口（slave por">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://langyiqun.github.io/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/simple_memobj.png">
<meta property="og:image" content="https://langyiqun.github.io/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/master_slave_1.png">
<meta property="og:image" content="https://langyiqun.github.io/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzgxMTM1,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="https://langyiqun.github.io/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzgxMTM1,size_16,color_FFFFFF,t_70-169863203577313.png">
<meta property="og:image" content="https://langyiqun.github.io/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/memobj_api.png">
<meta property="article:published_time" content="2023-10-30T00:39:24.000Z">
<meta property="article:modified_time" content="2023-11-24T01:37:16.436Z">
<meta property="article:author" content="Lang Yi Qun">
<meta property="article:tag" content="Gem5">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://langyiqun.github.io/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/simple_memobj.png">


<link rel="canonical" href="https://langyiqun.github.io/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://langyiqun.github.io/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/","path":"2023/10/30/Gem5模拟器学习（四）/","title":"Gem5模拟器学习（四）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Gem5模拟器学习（四） | 郎轶群的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">郎轶群的博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">却道天凉好个秋</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%B8%BB%E4%BB%8E%E7%AB%AF%E5%8F%A3"><span class="nav-number">1.</span> <span class="nav-text">一、主从端口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="nav-number">2.</span> <span class="nav-text">二、数据包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%B8%BB%E4%BB%8E%E4%BA%A4%E4%BA%92"><span class="nav-number">3.</span> <span class="nav-text">三、主从交互</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%AD%A3%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E4%B8%BB%E4%BB%8E%E4%BA%A4%E4%BA%92"><span class="nav-number">3.1.</span> <span class="nav-text">（1）正常情况下的主从交互</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%BB%8E%E6%9C%BA%E5%BF%99%E6%97%B6%E7%9A%84%E4%B8%BB%E4%BB%8E%E4%BA%A4%E4%BA%92"><span class="nav-number">3.2.</span> <span class="nav-text">（2）从机忙时的主从交互</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E4%B8%BB%E6%9C%BA%E5%BF%99%E6%97%B6%E7%9A%84%E4%B8%BB%E4%BB%8E%E4%BA%A4%E4%BA%92"><span class="nav-number">3.3.</span> <span class="nav-text">（3）主机忙时的主从交互</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81SimpleMemobj%E4%B8%BB%E4%BB%8E%E7%AB%AF%E5%8F%A3%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.</span> <span class="nav-text">四、SimpleMemobj主从端口函数实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#textcolor-RGB-250-106-106-1-%E8%8E%B7%E5%8F%96%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E8%8C%83%E5%9B%B4-CPU-%E2%80%93-Mem-bus"><span class="nav-number">4.1.</span> <span class="nav-text">$\textcolor[RGB]{250,106,106}{(1)获取内存模型的地址范围         (CPU –&gt; Mem bus)}$</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-SimpleMemobj-CPUSidePort-getAddrRanges"><span class="nav-number">4.1.1.</span> <span class="nav-text">1. SimpleMemobj::CPUSidePort::getAddrRanges</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-SimpleMemobj-getAddrRanges"><span class="nav-number">4.1.2.</span> <span class="nav-text">2. SimpleMemobj::getAddrRanges</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#textcolor-RGB-100-106-255-2-%E9%80%9A%E7%9F%A5%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E8%8C%83%E5%9B%B4%E5%8F%91%E7%94%9F%E6%9B%B4%E6%94%B9-Mem-bus-%E2%80%93-CPU"><span class="nav-number">4.2.</span> <span class="nav-text">$\textcolor[RGB]{100,106,255}{(2)通知内存模型的地址范围发生更改(Mem bus –&gt; CPU)} $</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-SimpleMemobj-MemSidePort-recvRangeChange"><span class="nav-number">4.2.1.</span> <span class="nav-text">1. SimpleMemobj::MemSidePort::recvRangeChange</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-SimpleMemobj-sendRangeChange"><span class="nav-number">4.2.2.</span> <span class="nav-text">2. SimpleMemobj::sendRangeChange</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#textcolor-RGB-250-250-100-3-%E5%8A%9F%E8%83%BD%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94-CPU-%E2%80%93-Mem-bus"><span class="nav-number">4.3.</span> <span class="nav-text">$\textcolor[RGB]{250,250,100}{(3)功能请求与响应(CPU –&gt; Mem bus)} $</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-SimpleMemobj-CPUSidePort-recvFunctional"><span class="nav-number">4.3.1.</span> <span class="nav-text">1. SimpleMemobj::CPUSidePort::recvFunctional</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-SimpleMemobj-handleFunctional"><span class="nav-number">4.3.2.</span> <span class="nav-text">2. SimpleMemobj::handleFunctional</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#textcolor-RGB-250-100-250-4-%E5%8F%91%E9%80%81%E5%AE%9A%E6%97%B6%E8%AF%B7%E6%B1%82-CPU-%E2%80%93-Mem-bus"><span class="nav-number">4.4.</span> <span class="nav-text">$\textcolor[RGB]{250,100,250}{(4)发送定时请求(CPU –&gt; Mem bus)} $</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-SimpleMemobj-CPUSidePort-recvTimingReq"><span class="nav-number">4.4.1.</span> <span class="nav-text">1. SimpleMemobj::CPUSidePort::recvTimingReq</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-SimpleMemobj-handleRequest"><span class="nav-number">4.4.2.</span> <span class="nav-text">2. SimpleMemobj::handleRequest</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-SimpleMemobj-MemSidePort-sendPacket"><span class="nav-number">4.4.3.</span> <span class="nav-text">3. SimpleMemobj::MemSidePort::sendPacket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-SimpleMemobj-MemSidePort-recvReqRetry"><span class="nav-number">4.4.4.</span> <span class="nav-text">4. SimpleMemobj::MemSidePort::recvReqRetry</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#textcolor-RGB-100-250-250-5-%E6%8E%A5%E6%94%B6%E5%AE%9A%E6%97%B6%E8%AF%B7%E6%B1%82%E7%9A%84%E5%93%8D%E5%BA%94-Mem-bus-%E2%80%93-CPU"><span class="nav-number">4.5.</span> <span class="nav-text">$\textcolor[RGB]{100,250,250}{(5)接收定时请求的响应(Mem bus –&gt; CPU)} $</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-SimpleMemobj-MemSidePort-recvTimingResp"><span class="nav-number">4.5.1.</span> <span class="nav-text">1. SimpleMemobj::MemSidePort::recvTimingResp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-SimpleMemobj-handleResponse"><span class="nav-number">4.5.2.</span> <span class="nav-text">2. SimpleMemobj::handleResponse</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-SimpleMemobj-CPUSidePort-sendPacket"><span class="nav-number">4.5.3.</span> <span class="nav-text">3. SimpleMemobj::CPUSidePort::sendPacket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-SimpleMemobj-CPUSidePort-trySendRetry"><span class="nav-number">4.5.4.</span> <span class="nav-text">4. SimpleMemobj::CPUSidePort::trySendRetry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-SimpleMemobj-CPUSidePort-recvRespRetry"><span class="nav-number">4.5.5.</span> <span class="nav-text">5. SimpleMemobj::CPUSidePort::recvRespRetry</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E9%85%8D%E7%BD%AE%E8%84%9A%E6%9C%AC"><span class="nav-number">5.</span> <span class="nav-text">五、配置脚本</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lang Yi Qun</p>
  <div class="site-description" itemprop="description">this is a personal blog of lyq</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/yourname" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/yourname" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-facebook fa-fw"></i>FB Page</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/yourname" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://youtube.com/yourname" title="YouTube → https:&#x2F;&#x2F;youtube.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTube</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/yourname" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
      <span class="links-of-author-item">
        <a href="skype:yourname?call|chat" title="Skype → skype:yourname?call|chat" rel="noopener me" target="_blank"><i class="fab fa-skype fa-fw"></i>Skype</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://langyiqun.github.io/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lang Yi Qun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="郎轶群的博客">
      <meta itemprop="description" content="this is a personal blog of lyq">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Gem5模拟器学习（四） | 郎轶群的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Gem5模拟器学习（四）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-30 08:39:24" itemprop="dateCreated datePublished" datetime="2023-10-30T08:39:24+08:00">2023-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-24 09:37:16" itemprop="dateModified" datetime="2023-11-24T09:37:16+08:00">2023-11-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">Gem5模拟器</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>本文是官网教程<a target="_blank" rel="noopener" href="https://www.gem5.org/documentation/learning_gem5/part2/memoryobject/">gem5: Creating SimObjects in the memory system</a>的学习笔记。</p>
<p>本节教程是创建一个位于CPU和内存总线之间的阻塞式简单内存对象，主要实现了基本请求的传递。在下一节教程中，会在本节创建的简单内存对象之上增加部分逻辑，使其成为一个非常简单的阻塞单处理器缓存。下图是整个系统的示意图，其中，我们创建的内存对象有两个CPU侧的从端口（slave port）和一个内存总线侧的主端口（master port）。它将实现将请求从CPU传递到内存总线，并将响应从内存总线传递到CPU。</p>
<span id="more"></span>

<img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/simple_memobj.png" class="" title="System with a simple memory object which sits between a CPU and the memory bus.">



<h1 id="一、主从端口"><a href="#一、主从端口" class="headerlink" title="一、主从端口"></a>一、主从端口</h1><p>主端口（master port）和从端口（slave port）是模拟器中创造的概念，用于描述计算机系统中不同组件之间的数据传输关系。在模拟器中用于连接计算机系统中的各种组件。其中，<strong>主端口负责发送请求（send req）、接收响应（recv resp）</strong>；<strong>从端口负责接受请求（recv req）、发送响应（send resp）</strong>，因此，<u>主从端口必须配对使用</u>。</p>
<p>以本模拟系统为例，memory object有两个CPU侧的从端口，用于接收CPU的请求，并向其返回响应；同时有一个mem bus侧的主接口，用于向mem bus发送请求，并接收其响应。</p>
<p>这些端口实现三种不同的存储系统模式：</p>
<ul>
<li>定时模式（timing mode）。唯一的产生正确模拟结果的模式，最常用。</li>
<li>原子模式（atomic mode）。</li>
<li>功能模式（functional mode）。</li>
</ul>
<p>其他模式暂时不懂。。。</p>
<p>三种访存模式介绍<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45726331/article/details/129651724">【Gem5】gem5模拟器中三种访存模式Atomic、Timing、Functional的总结对比_空空7的博客-CSDN博客</a></p>
<h1 id="二、数据包"><a href="#二、数据包" class="headerlink" title="二、数据包"></a>二、数据包</h1><p>在gem5中，<strong>端口通过发送数据包（packet）实现交互</strong>。数据包由MemReq组成，MemReq是内存请求对象。MemReq保存初始化包的原始请求的信息，例如请求者、地址和请求类型（读、写等）。数据包还有一个MemCmd，它是数据包的当前命令。此命令可以在数据包的整个生命周期中改变（例如，一旦满足内存命令，请求就变成响应）。最常见的MemCmd是ReadReq（读请求）、ReadResp（读响应）、WriteReq（写请求）、WriteResp（写响应）。还有缓存和许多其他命令类型的写回请求（WritebackDirty、WritebackClean）</p>
<h1 id="三、主从交互"><a href="#三、主从交互" class="headerlink" title="三、主从交互"></a>三、主从交互</h1><p>在定时模式下，主从端口的交互有以下三种情况，需要理清其函数调用链</p>
<h2 id="（1）正常情况下的主从交互"><a href="#（1）正常情况下的主从交互" class="headerlink" title="（1）正常情况下的主从交互"></a>（1）正常情况下的主从交互</h2><p>正常情况下，主机通过调用sendTimingReq函数发送请求，从机的recvTimingReq函数也随之被调用，如果从机目前可以接受此请求，则返回true，表示从机已经接受此次请求。从机接受请求后随即开始处理此请求。</p>
<p>从机处理完请求后，通过调用sendTimingResp函数发送此次请求的响应，类似地，主机的recvTimingResp函数随之被调用，如果主机目前可以接受此响应，则返回true，表示主机已经接受了此次响应。交互结束。</p>
<img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/master_slave_1.png" class="" title="Simple master-slave interaction when both can accept the request and the response.">

<h2 id="（2）从机忙时的主从交互"><a href="#（2）从机忙时的主从交互" class="headerlink" title="（2）从机忙时的主从交互"></a>（2）从机忙时的主从交互</h2><p>以上情况是主从都顺利接收的理想情况，但当从机接受请求或主机接受响应时，它们可能正忙。</p>
<p>下面就是从机忙时主从交互的过程。</p>
<p>从机忙时，从机无法接受主机发送的请求，因此recvTimingReq函数返回false，拒绝接受此次请求。但当从机结束忙态后，会通过调用sendReqRetry函数通知主机，“邀请”主机再次重试发送请求，主机通过recvReqRetry函数接收重试通知后，随机再次发起新的请求。当然，新请求也可能再次因为从机忙而被拒绝。</p>
<img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzgxMTM1,size_16,color_FFFFFF,t_70.png" class="" title="交互">

<h2 id="（3）主机忙时的主从交互"><a href="#（3）主机忙时的主从交互" class="headerlink" title="（3）主机忙时的主从交互"></a>（3）主机忙时的主从交互</h2><p>类似地，在主机忙时，主机无法接收从机发送的响应，因此recvTimingResp函数返回false，拒绝接收此次响应。但当主机结束忙态后，会通过调用sendRespRetry函数通知从机，“邀请”从机再次重试发送响应，从机通过recvRespRetry函数接收重试通知后，随机再次发起新的响应。</p>
<img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzgxMTM1,size_16,color_FFFFFF,t_70-169863203577313.png" class="" title="交互">

<h1 id="四、SimpleMemobj主从端口函数实现"><a href="#四、SimpleMemobj主从端口函数实现" class="headerlink" title="四、SimpleMemobj主从端口函数实现"></a>四、SimpleMemobj主从端口函数实现</h1><p>在本节的简单内存对象（SimpleMemobj）下定义了两个嵌套类CPUSidePort和MemSidePort，它们分别继承自ResponsePort&#x2F;SlavePort和RequstPort&#x2F;MasterPort，即从端口和主端口。</p>
<ul>
<li>SimpleMemobj类的成员变量<ul>
<li><strong>CPU侧从端口</strong>  CPUSidePort instPort; CPUSidePort dataPort;</li>
<li><strong>内存总线侧主端口</strong>  MemSidePort memPort; </li>
<li><strong>阻塞标志</strong> 目前是否正在阻塞等待一个响应 bool blocked;</li>
</ul>
</li>
<li>CPUSidePort类的成员变量<ul>
<li><strong>父对象指针（即SimpleMemobj对象）</strong> SimpleMemobj *owner;</li>
<li><strong>是否需要重发</strong> CPU试图发送请求给端口，但被拒绝的情况下，需要记录一下存在这种情况，端口在结束忙态后会通知CPU重发。bool needRetry;</li>
<li><strong>被阻塞的数据包指针</strong> 该端口试图给CPU发送响应，但被CPU拒绝，需要暂存这个数据包。PacketPtr blockedPacket;</li>
</ul>
</li>
<li>MemSidePort类的成员变量<ul>
<li><strong>父对象指针（即SimpleMemobj对象）</strong> SimpleMemobj *owner;</li>
<li><strong>被阻塞的数据包指针</strong> 该端口试图给主存发送请求，但被主存拒绝，需要暂存这个数据包。PacketPtr blockedPacket;</li>
</ul>
</li>
</ul>
<p>各类的成员函数如下图，其中，加粗函数为必须实现的函数，未加粗的函数为在父类中已经实现的函数。</p>
<img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/memobj_api.png" class="" title="Interaction between SimpleMemobj and its ports">



<p>下面按上图顺序分别对五个函数调用链进行梳理 </p>
<h2 id="textcolor-RGB-250-106-106-1-获取内存模型的地址范围-CPU-–-Mem-bus"><a href="#textcolor-RGB-250-106-106-1-获取内存模型的地址范围-CPU-–-Mem-bus" class="headerlink" title="$\textcolor[RGB]{250,106,106}{(1)获取内存模型的地址范围         (CPU –&gt; Mem bus)}$"></a>$\textcolor[RGB]{250,106,106}{(1)获取内存模型的地址范围         (CPU –&gt; Mem bus)}$</h2><p>CPU 发送请求，查询内存模型的地址范围，并返回一个 AddrRangeList 类型的值。这种查询请求<strong>不存在阻塞情况</strong>。</p>
<h3 id="1-SimpleMemobj-CPUSidePort-getAddrRanges"><a href="#1-SimpleMemobj-CPUSidePort-getAddrRanges" class="headerlink" title="1. SimpleMemobj::CPUSidePort::getAddrRanges"></a>1. SimpleMemobj::CPUSidePort::getAddrRanges</h3><p>CPUSidePort直接将请求传递给其父对象SimpleMemobj</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AddrRangeList</span><br><span class="line">SimpleMemobj::CPUSidePort::getAddrRanges() const</span><br><span class="line">&#123;</span><br><span class="line">    return owner-&gt;getAddrRanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-SimpleMemobj-getAddrRanges"><a href="#2-SimpleMemobj-getAddrRanges" class="headerlink" title="2. SimpleMemobj::getAddrRanges"></a>2. SimpleMemobj::getAddrRanges</h3><p>SimpleMemobj同样直接将请求传递给其子对象MemSidePort </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AddrRangeList</span><br><span class="line">SimpleMemobj::getAddrRanges() const</span><br><span class="line">&#123;</span><br><span class="line">    DPRINTF(SimpleMemobj, &quot;Sending new ranges\n&quot;);</span><br><span class="line">    // Just use the same ranges as whatever is on the memory side.</span><br><span class="line">    return memPort.getAddrRanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MemSidePort.getAddrRanges()函数已经在MemSidePort的父类RequestPort中被实现了，返回地址范围，可直接使用。</p>
<h2 id="textcolor-RGB-100-106-255-2-通知内存模型的地址范围发生更改-Mem-bus-–-CPU"><a href="#textcolor-RGB-100-106-255-2-通知内存模型的地址范围发生更改-Mem-bus-–-CPU" class="headerlink" title="$\textcolor[RGB]{100,106,255}{(2)通知内存模型的地址范围发生更改(Mem bus –&gt; CPU)} $"></a>$\textcolor[RGB]{100,106,255}{(2)通知内存模型的地址范围发生更改(Mem bus –&gt; CPU)} $</h2><p>Mem bus发送请求，向CPU通知内存模型的地址范围发生更改，同样此通知也<strong>不会阻塞</strong>。</p>
<h3 id="1-SimpleMemobj-MemSidePort-recvRangeChange"><a href="#1-SimpleMemobj-MemSidePort-recvRangeChange" class="headerlink" title="1. SimpleMemobj::MemSidePort::recvRangeChange"></a>1. SimpleMemobj::MemSidePort::recvRangeChange</h3><p>MemSidePort 直接将请求传递给其父对象 SimpleMemobj</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::MemSidePort::recvRangeChange()</span><br><span class="line">&#123;</span><br><span class="line">    owner-&gt;sendRangeChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-SimpleMemobj-sendRangeChange"><a href="#2-SimpleMemobj-sendRangeChange" class="headerlink" title="2. SimpleMemobj::sendRangeChange"></a>2. SimpleMemobj::sendRangeChange</h3><p>SimpleMemobj同样直接将请求传递给其子对象CPUSidePort</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::sendRangeChange()</span><br><span class="line">&#123;</span><br><span class="line">    instPort.sendRangeChange();</span><br><span class="line">    dataPort.sendRangeChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CPUSidePort.sendRangeChange函数同样已经在CPUSidePort的父类ResponsePort中被实现了，可直接使用。</p>
<h2 id="textcolor-RGB-250-250-100-3-功能请求与响应-CPU-–-Mem-bus"><a href="#textcolor-RGB-250-250-100-3-功能请求与响应-CPU-–-Mem-bus" class="headerlink" title="$\textcolor[RGB]{250,250,100}{(3)功能请求与响应(CPU –&gt; Mem bus)} $"></a>$\textcolor[RGB]{250,250,100}{(3)功能请求与响应(CPU –&gt; Mem bus)} $</h2><p>功能请求是指不改变系统状态的请求，通常用于读取数据或检查系统状态。同样这种请求也<strong>不会发生阻塞</strong>。</p>
<p>这个过程的调用链与获取地址范围大致相同，只不过需要传递数据包指针。</p>
<h3 id="1-SimpleMemobj-CPUSidePort-recvFunctional"><a href="#1-SimpleMemobj-CPUSidePort-recvFunctional" class="headerlink" title="1. SimpleMemobj::CPUSidePort::recvFunctional"></a>1. SimpleMemobj::CPUSidePort::recvFunctional</h3><p>CPUSidePort直接将请求传递给其父对象 SimpleMemobj</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::CPUSidePort::recvFunctional(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Just forward to the memobj.</span><br><span class="line">    return owner-&gt;handleFunctional(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-SimpleMemobj-handleFunctional"><a href="#2-SimpleMemobj-handleFunctional" class="headerlink" title="2. SimpleMemobj::handleFunctional"></a>2. SimpleMemobj::handleFunctional</h3><p>SimpleMemobj同样直接将请求传递给其子对象MemSidePort </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::handleFunctional(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Just pass this on to the memory side to handle for now.</span><br><span class="line">    memPort.sendFunctional(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MemSidePort.sendFunctional()函数已经在MemSidePort的父类RequestPort中被实现了，可直接使用。</p>
<h2 id="textcolor-RGB-250-100-250-4-发送定时请求-CPU-–-Mem-bus"><a href="#textcolor-RGB-250-100-250-4-发送定时请求-CPU-–-Mem-bus" class="headerlink" title="$\textcolor[RGB]{250,100,250}{(4)发送定时请求(CPU –&gt; Mem bus)} $"></a>$\textcolor[RGB]{250,100,250}{(4)发送定时请求(CPU –&gt; Mem bus)} $</h2><p>定时请求是指需要等待一段时间后才能完成的请求，通常用于写入数据或执行耗时操作。由于CPU发送请求时，mem bus可能尚未处理完上一次请求，处于忙态，无法接收此次请求，因此这个过程<strong>可能会发生阻塞</strong>。</p>
<h3 id="1-SimpleMemobj-CPUSidePort-recvTimingReq"><a href="#1-SimpleMemobj-CPUSidePort-recvTimingReq" class="headerlink" title="1. SimpleMemobj::CPUSidePort::recvTimingReq"></a>1. SimpleMemobj::CPUSidePort::recvTimingReq</h3><p>CPUSidePort尝试通过父对象 SimpleMemobj的handleRequest函数发送定时请求</p>
<p>如果成功，返回true；</p>
<p>如果失败，将needRetry置为true并返回false，该请求被阻止，CPU在将来某个时候需要发送一个重试（见SimpleMemobj::CPUSidePort::trySendRetry()函数）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">SimpleMemobj::CPUSidePort::recvTimingReq(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Just forward to the memobj.</span><br><span class="line">    if (!owner-&gt;handleRequest(pkt)) &#123;</span><br><span class="line">        needRetry = true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-SimpleMemobj-handleRequest"><a href="#2-SimpleMemobj-handleRequest" class="headerlink" title="2. SimpleMemobj::handleRequest"></a>2. SimpleMemobj::handleRequest</h3><p>来到SimpleMemobj的handleRequest函数。首先检查目前没有在等待响应（被阻塞）</p>
<p>如果没有被阻塞，则将blocked置为true，即进入阻塞状态，并通过子对象MemSidePort的sendPacket函数发送数据包，并返回true；</p>
<p>反之如果被阻塞，直接返回false，拒绝此请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">SimpleMemobj::handleRequest(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    if (blocked) &#123;</span><br><span class="line">        // There is currently an outstanding request. Stall.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    DPRINTF(SimpleMemobj, &quot;Got request for addr %#x\n&quot;, pkt-&gt;getAddr());</span><br><span class="line">    </span><br><span class="line">    // This memobj is now blocked waiting for the response to this packet.</span><br><span class="line">    blocked = true;</span><br><span class="line">    </span><br><span class="line">    // Simply forward to the memory port</span><br><span class="line">    memPort.sendPacket(pkt);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-SimpleMemobj-MemSidePort-sendPacket"><a href="#3-SimpleMemobj-MemSidePort-sendPacket" class="headerlink" title="3. SimpleMemobj::MemSidePort::sendPacket"></a>3. SimpleMemobj::MemSidePort::sendPacket</h3><p>MemSidePort的sendPacket会调用sendTimingReq函数（在其父类中定义，可直接使用）发送请求数据包给内存总线。如果发送不成功，则将要发送的数据包指针保存下来，准备重发该数据包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::MemSidePort::sendPacket(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Note: This flow control is very simple since the memobj is blocking.</span><br><span class="line">    panic_if(blockedPacket != nullptr, &quot;Should never try to send if blocked!&quot;);</span><br><span class="line">    </span><br><span class="line">    // If we can&#x27;t send the packet across the port, store it for later.</span><br><span class="line">    if (!sendTimingReq(pkt)) &#123;</span><br><span class="line">        blockedPacket = pkt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-SimpleMemobj-MemSidePort-recvReqRetry"><a href="#4-SimpleMemobj-MemSidePort-recvReqRetry" class="headerlink" title="4. SimpleMemobj::MemSidePort::recvReqRetry"></a>4. SimpleMemobj::MemSidePort::recvReqRetry</h3><p>内存总线结束忙态后，会调用MemSidePort类的recvReqRetry邀请MemSidePort重发之前被阻塞的请求数据包，即重发blockedPacket数据包。注意：在重发前，应该一定会有被阻塞的数据包，否则报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::MemSidePort::recvReqRetry()</span><br><span class="line">&#123;</span><br><span class="line">    // We should have a blocked packet if this function is called.</span><br><span class="line">    assert(blockedPacket != nullptr);</span><br><span class="line"></span><br><span class="line">    // Grab the blocked packet.</span><br><span class="line">    PacketPtr pkt = blockedPacket;</span><br><span class="line">    blockedPacket = nullptr;</span><br><span class="line"></span><br><span class="line">    // Try to resend it. It&#x27;s possible that it fails again.</span><br><span class="line">    sendPacket(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="textcolor-RGB-100-250-250-5-接收定时请求的响应-Mem-bus-–-CPU"><a href="#textcolor-RGB-100-250-250-5-接收定时请求的响应-Mem-bus-–-CPU" class="headerlink" title="$\textcolor[RGB]{100,250,250}{(5)接收定时请求的响应(Mem bus –&gt; CPU)} $"></a>$\textcolor[RGB]{100,250,250}{(5)接收定时请求的响应(Mem bus –&gt; CPU)} $</h2><p>内存总线处理完定时请求后，会向CPU发送该定时请求的响应。类似地，CPU也可能会因为处于忙态而拒绝接收响应，也<strong>可能会存在阻塞</strong></p>
<h3 id="1-SimpleMemobj-MemSidePort-recvTimingResp"><a href="#1-SimpleMemobj-MemSidePort-recvTimingResp" class="headerlink" title="1. SimpleMemobj::MemSidePort::recvTimingResp"></a>1. SimpleMemobj::MemSidePort::recvTimingResp</h3><p>MemSidePort直接将请求传递给其父对象SimpleMemobj</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">SimpleMemobj::MemSidePort::recvTimingResp(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Just forward to the memobj.</span><br><span class="line">    return owner-&gt;handleResponse(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-SimpleMemobj-handleResponse"><a href="#2-SimpleMemobj-handleResponse" class="headerlink" title="2. SimpleMemobj::handleResponse"></a>2. SimpleMemobj::handleResponse</h3><p>SimpleMemobj处理响应时，首先因为收到了响应所以消除阻塞状态，然后根据数据包的属性确定是发送给指令端口还是数据端口。</p>
<p>结束了阻塞状态以后，会尝试通过trySendRetry()函数让CPU重发未能成功发送的请求（如果有的话）。</p>
<p>注意：在接收响应时，SimpleMemobj应该一定处于阻塞状态，否则报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">SimpleMemobj::handleResponse(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    assert(blocked);</span><br><span class="line">    DPRINTF(SimpleMemobj, &quot;Got response for addr %#x\n&quot;, pkt-&gt;getAddr());</span><br><span class="line"></span><br><span class="line">    // The packet is now done. We&#x27;re about to put it in the port, no need for</span><br><span class="line">    // this object to continue to stall.</span><br><span class="line">    // We need to free the resource before sending the packet in case the CPU</span><br><span class="line">    // tries to send another request immediately (e.g., in the same callchain).</span><br><span class="line">    blocked = false;</span><br><span class="line"></span><br><span class="line">    // Simply forward to the memory port</span><br><span class="line">    if (pkt-&gt;req-&gt;isInstFetch()) &#123;</span><br><span class="line">        instPort.sendPacket(pkt);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dataPort.sendPacket(pkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // For each of the cpu ports, if it needs to send a retry, it should do it</span><br><span class="line">    // now since this memory object may be unblocked now.</span><br><span class="line">    instPort.trySendRetry();</span><br><span class="line">    dataPort.trySendRetry();</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-SimpleMemobj-CPUSidePort-sendPacket"><a href="#3-SimpleMemobj-CPUSidePort-sendPacket" class="headerlink" title="3. SimpleMemobj::CPUSidePort::sendPacket"></a>3. SimpleMemobj::CPUSidePort::sendPacket</h3><p>CPUSidePort的sendPacket会调用sendTimingReq函数（在其父类中定义，可直接使用）发送响应数据包给CPU。如果发送不成功，则将要发送的数据包指针保存下来，准备重发该数据包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::CPUSidePort::sendPacket(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Note: This flow control is very simple since the memobj is blocking.</span><br><span class="line"></span><br><span class="line">    panic_if(blockedPacket != nullptr, &quot;Should never try to send if blocked!&quot;);</span><br><span class="line"></span><br><span class="line">    // If we can&#x27;t send the packet across the port, store it for later.</span><br><span class="line">    if (!sendTimingResp(pkt)) &#123;</span><br><span class="line">        blockedPacket = pkt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-SimpleMemobj-CPUSidePort-trySendRetry"><a href="#4-SimpleMemobj-CPUSidePort-trySendRetry" class="headerlink" title="4. SimpleMemobj::CPUSidePort::trySendRetry"></a>4. SimpleMemobj::CPUSidePort::trySendRetry</h3><p>尝试让CPU重发未能发送的请求</p>
<p>如果needRetry为True，则说明之前CPU有未能发送的请求；如果blockedPacket指针为空，说明SimpleMemobj未处于阻塞状态，则可以通过sendRetryReq函数（父类中已经实现，可直接使用）让CPU重发请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::CPUSidePort::trySendRetry()</span><br><span class="line">&#123;</span><br><span class="line">    if (needRetry &amp;&amp; blockedPacket == nullptr) &#123;</span><br><span class="line">        // Only send a retry if the port is now completely free</span><br><span class="line">        needRetry = false;</span><br><span class="line">        DPRINTF(SimpleMemobj, &quot;Sending retry req for %d\n&quot;, id);</span><br><span class="line">        sendRetryReq();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-SimpleMemobj-CPUSidePort-recvRespRetry"><a href="#5-SimpleMemobj-CPUSidePort-recvRespRetry" class="headerlink" title="5. SimpleMemobj::CPUSidePort::recvRespRetry"></a>5. SimpleMemobj::CPUSidePort::recvRespRetry</h3><p>CPU忙态结束以后，会通过调用CPUSidePort类的recvRespRetry函数邀请CPUSidePort重新发送之前被阻塞的响应数据包，即重发blockedPacket数据包。注意：在重发前，应该一定会有被阻塞的数据包，否则报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::CPUSidePort::recvRespRetry()</span><br><span class="line">&#123;</span><br><span class="line">    // We should have a blocked packet if this function is called.</span><br><span class="line">    assert(blockedPacket != nullptr);</span><br><span class="line"></span><br><span class="line">    // Grab the blocked packet.</span><br><span class="line">    PacketPtr pkt = blockedPacket;</span><br><span class="line">    blockedPacket = nullptr;</span><br><span class="line"></span><br><span class="line">    // Try to resend it. It&#x27;s possible that it fails again.</span><br><span class="line">    sendPacket(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五、配置脚本"><a href="#五、配置脚本" class="headerlink" title="五、配置脚本"></a>五、配置脚本</h1><p>实例化SimpleMemobj对象，并运行hello world负载的配置脚本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import m5</span><br><span class="line">from m5.objects import *</span><br><span class="line"></span><br><span class="line">system = System()</span><br><span class="line">system.clk_domain = SrcClockDomain()</span><br><span class="line">system.clk_domain.clock = &#x27;1GHz&#x27;</span><br><span class="line">system.clk_domain.voltage_domain = VoltageDomain()</span><br><span class="line">system.mem_mode = &#x27;timing&#x27;</span><br><span class="line">system.mem_ranges = [AddrRange(&#x27;512MB&#x27;)]</span><br><span class="line"></span><br><span class="line">system.cpu = TimingSimpleCPU()</span><br><span class="line"></span><br><span class="line">system.memobj = SimpleMemobj()</span><br><span class="line"></span><br><span class="line">system.cpu.icache_port = system.memobj.inst_port</span><br><span class="line">system.cpu.dcache_port = system.memobj.data_port</span><br><span class="line"></span><br><span class="line">system.membus = SystemXBar()</span><br><span class="line"></span><br><span class="line">system.memobj.mem_side = system.membus.slave</span><br><span class="line"></span><br><span class="line">system.cpu.createInterruptController()</span><br><span class="line">system.cpu.interrupts[0].pio = system.membus.master</span><br><span class="line">system.cpu.interrupts[0].int_master = system.membus.slave</span><br><span class="line">system.cpu.interrupts[0].int_slave = system.membus.master</span><br><span class="line"></span><br><span class="line">system.mem_ctrl = DDR3_1600_8x8()</span><br><span class="line">system.mem_ctrl.range = system.mem_ranges[0]</span><br><span class="line">system.mem_ctrl.port = system.membus.master</span><br><span class="line"></span><br><span class="line">system.system_port = system.membus.slave</span><br><span class="line"></span><br><span class="line">process = Process()</span><br><span class="line">process.cmd = [&#x27;tests/test-progs/hello/bin/x86/linux/hello&#x27;]</span><br><span class="line">system.cpu.workload = process</span><br><span class="line">system.cpu.createThreads()</span><br><span class="line"></span><br><span class="line">root = Root(full_system = False, system = system)</span><br><span class="line">m5.instantiate()</span><br><span class="line"></span><br><span class="line">print &quot;Beginning simulation!&quot;</span><br><span class="line">exit_event = m5.simulate()</span><br><span class="line">print &#x27;Exiting @ tick %i because %s&#x27; % (m5.curTick(), exit_event.getCause())</span><br></pre></td></tr></table></figure>

<ol>
<li>在命令行执行以下命令，可以运行模拟系统</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/X86/gem5.opt configs/learning_gem5/part2/simple_memobj.py</span><br></pre></td></tr></table></figure>

<p>输出内容出现Hello World则模拟成功。</p>
<ol start="2">
<li>在命令行执行以下命令，可以在debug模式下运行模拟系统，由于输出较多，只输出前五十行。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/X86/gem5.opt --debug-flags=SimpleMemobj configs/learning_gem5/part2/simple_memobj.py | head -n 50</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Beginning simulation!</span><br><span class="line">      0: system.memobj: Got request for addr 0x190</span><br><span class="line">  77000: system.memobj: Got response for addr 0x190</span><br><span class="line">  77000: system.memobj: Got request for addr 0x190</span><br><span class="line"> 126000: system.memobj: Got response for addr 0x190</span><br><span class="line"> 126000: system.memobj: Got request for addr 0x190</span><br><span class="line"> 175000: system.memobj: Got response for addr 0x190</span><br><span class="line"> 175000: system.memobj: Got request for addr 0x94db0</span><br><span class="line"> 238000: system.memobj: Got response for addr 0x94db0</span><br><span class="line"> 238000: system.memobj: Got request for addr 0x190</span><br><span class="line"> 287000: system.memobj: Got response for addr 0x190</span><br><span class="line"> 287000: system.memobj: Got request for addr 0x198</span><br><span class="line"> 336000: system.memobj: Got response for addr 0x198</span><br><span class="line"> 336000: system.memobj: Got request for addr 0x198</span><br><span class="line"> 385000: system.memobj: Got response for addr 0x198</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Gem5/" rel="tag"># Gem5</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/10/25/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E6%8B%BC%E6%8E%A5/" rel="prev" title="数字图像处理——图片拼接">
                  <i class="fa fa-angle-left"></i> 数字图像处理——图片拼接
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="next" title="Cache基础知识">
                  Cache基础知识 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Lang Yi Qun</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
