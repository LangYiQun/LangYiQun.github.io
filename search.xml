<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多级存储层次</title>
      <link href="/2023/10/31/%E5%A4%9A%E7%BA%A7%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1/"/>
      <url>/2023/10/31/%E5%A4%9A%E7%BA%A7%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、多级存储层次"><a href="#一、多级存储层次" class="headerlink" title="一、多级存储层次"></a>一、多级存储层次</h1><p>用多种存储器构成存储层次结构是提高存储系统整体性能的必要方法。</p><h2 id="1-1-为什么需要多级存储层次"><a href="#1-1-为什么需要多级存储层次" class="headerlink" title="1.1 为什么需要多级存储层次"></a>1.1 为什么需要多级存储层次</h2><p>存储器的三个主要指标是<strong>容量</strong>、<strong>速度</strong>和<strong>单位价格</strong>。我们希望设计“容量大、速度快、价格低”的存储系统，例如，大规模应用程序要求存储系统容量大、价格低；然而，存储系统又应该在CPU执行程序时以足够快的素的向CPU提供指令和数据。然而，目前还没有一种存储器技术能满足这三个要求，现有的存储器技术只能满足其中一或两个要求。</p><p>解决这些矛盾的方法，就是采用多种存储器技术，构成多级存储层次。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cache基础知识</title>
      <link href="/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Cache技术"><a href="#一、Cache技术" class="headerlink" title="一、Cache技术"></a>一、Cache技术</h1><p>现代计算机都在CPU和主存之间设置一个高速、小容量的缓冲处理器，称为Cache。Cache的存在填补了CPU和主存在速度上的巨大差距，对于提高整个计算机系统的性能有重要意义，是现代计算系统必不可少的部件，然而，<strong>Cache对程序员是透明的</strong>。</p><p>此外，Cache技术这个此被广泛用于指代利用缓冲技术来实现局部数据再利用的技术。其能够缓解两个部件之间访问数据速度差距较大的问题，在硬盘、网页中都能看见缓冲技术的身影，本文专指CPU与主存之间的Cache。</p><h1 id="二、Cache结构"><a href="#二、Cache结构" class="headerlink" title="二、Cache结构"></a>二、Cache结构</h1><p>Cache 和主存间信息的交互<strong>按块来组织</strong>。Cache和主存均被分割为大小相同的块，块大小（blocksize）通常为2的幂次方字节。</p><p>【图一：Cache、内存被分割为块】</p><p>CPU通过访存指令中的主存地址向Cache请求主存数据，该主存地址被分割为两部分：<strong>块地址</strong>和<strong>块内位移</strong></p><img src="/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231031155331776.png" class="" title="内存地址分割为块地址和块内偏移"><p>【图二：主存地址被分割为块地址和块内偏移】</p><p>硬件会<u>根据<strong>块地址</strong>查找该块在Cache中的位置</u>，再<u>通过<strong>块内位移</strong>确定所访问的数据再该块中的位置</u>。</p><h1 id="三、Cache工作原理"><a href="#三、Cache工作原理" class="headerlink" title="三、Cache工作原理"></a>三、Cache工作原理</h1><p>在每个存储层次中，都绕不开这四个关键问题：</p><ul><li>映像规则：当把一个块从主存调入Cache时，可以放到哪些位置上？</li><li>查找算法：当所要访问的块在Cache中时，如何找到该块？</li><li>替换算法：当发生失效时，应该替换Cache中的哪一个块？</li><li>写策略：当进行写访问时，应该如何操作？</li></ul><p>下面一一进行探讨：</p><h2 id="（1）映像规则"><a href="#（1）映像规则" class="headerlink" title="（1）映像规则"></a>（1）映像规则</h2><p>当要把一个块从主存调入Cache中时，首先要确定这个块可以放在Cache中的哪些位置上。一般来说，主存的容量远远大于Cache的容量，因此要确定较多的主存块与较少的Cache块之间的对应关系，这就是Cache与主存间的映像规则。主要有以下三种：</p><h3 id="1-直接映像"><a href="#1-直接映像" class="headerlink" title="1. 直接映像"></a>1. 直接映像</h3><p>直接映像（Direct Mapping）是指每个主存块只能被放置到唯一的一个Cache块位置。</p><p>通常采用直接取模的方式进行映像。对于主存的第i块（即块地址为i），设它映像到Cache的第j块（即块地址为j），Cache总共有M块，则对应关系为：<br>$$<br>j &#x3D; i mod M<br>$$</p><h3 id="2-全相联映像"><a href="#2-全相联映像" class="headerlink" title="2. 全相联映像"></a>2. 全相联映像</h3><p>全相联映像（Fully Associative Mapping）是指每个主存块可以被放置到任何一个Cache块位置。</p><h3 id="3-组相联映像"><a href="#3-组相联映像" class="headerlink" title="3. 组相联映像"></a>3. 组相联映像</h3><p>组相联映像（Set Associative Mapping）是指每个主存块可以被放置到Cache中唯一的一个组中的任何一个块位置。</p><p>这里引入了组的概念，Cache被等分为若干个组，每组由若干个块构成。具体地，假设组相联Cache一共有M个块，这M个块被分为G组，则每组有n&#x3D;M&#x2F;G个块，称该映像规则为n路组相联（n-way Set Associative）,直接映像实际上即为1路组相联，全相联即为M路组相联。</p><p>通常也通过直接取模的方法进行组的映像，对于主存的第i块（即块地址为i），设它映像到Cache的第k组，Cache总共有G组，则对应关系为：<br>$$<br>k &#x3D; i mod G<br>$$<br>相联度的高低有利有弊，在实际设计时是一个值得tradeoff的事情。</p><p>相联度越高，Cache空间的利用率越高，块冲突的概率就越低，因此Cache的失效率就越低。但高相联度的查找块过程较复杂，会使Cache的实现复杂度和代价增大，从而降低访问速度。</p><table><thead><tr><th></th><th>利</th><th>弊</th></tr></thead><tbody><tr><td>高相联度</td><td>Cache失效率低</td><td>访问Cache速度慢</td></tr><tr><td>低相联度</td><td>访问Cache速度块</td><td>Cache失效率高</td></tr></tbody></table><h2 id="（2）查找方法"><a href="#（2）查找方法" class="headerlink" title="（2）查找方法"></a>（2）查找方法</h2><p>前面提到，当CPU发送内存地址给Cache后，Cache需要查找该地址所在的主存块当前是否在Cache中，如果在，则命中（Hit），如果不在，则失效（Miss）。主存地址被分为块地址和块内位移，我们需要根据块地址来进行查找。</p><p>无论采取哪种映像规则，多个主存块都可能映像到同一个Cache块的位置，为了区分当前某Cache块位置保存的是哪一个主存块，必须记录唯一标识此主存块的信息，记录这些信息的硬件结构称为<strong>目录表</strong>。目录表共有M项，每个目录项对应于Cache中的一个块，目录项记录了其对应保存的主存块的块地址中除了索引意外的部分，称为标识（tag），每个主存块能唯一地由其标识来确定。此外，每个目录项还有一个有效位，用以指示该项是否有效。</p><p>当要在Cache中查找某一块时，首先根据索引找到块（组）的位置，然后通过查找目录表来确定该块是否在这些位置中的一个。</p><p>查找Cache块的方法基本取决于Cache的映像规则，下面分别进行讨论：</p><h3 id="1-查找直接映像Cache"><a href="#1-查找直接映像Cache" class="headerlink" title="1. 查找直接映像Cache"></a>1. 查找直接映像Cache</h3><p>对于直接映像Cache，其主存块地址被分为tag和块索引，该主存块在Cache中具有唯一位置。因此当CPU访问该主存块时，利用块索引查找到这个位置对应的唯一一个目录项，如果主存地址的tag于该目录项的tag相同，且该目录项有效位为1，则命中；否则失效。</p><img src="/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231031163658464.png" class="" title="直接映像Cache块地址划分"><h3 id="2-查找组相联Cache"><a href="#2-查找组相联Cache" class="headerlink" title="2. 查找组相联Cache"></a>2. 查找组相联Cache</h3><p>对于组相联Cache，其主存地址划分为tag和组索引，该主存块在Cache中具有唯一组别。因此当CPU访问该主存块时，首先通过组索引找到具有该组索引的若干目录项，然后比较这些目录项的tag与主存地址的tag，如果其中有一个目录项的tag与主存地址tag相同，且该目录项有效位为1，则该目录项命中；否则失效。</p><img src="/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231031163555331.png" class="" title="4路组相联"><h3 id="3-查找全相联Cache"><a href="#3-查找全相联Cache" class="headerlink" title="3. 查找全相联Cache"></a>3. 查找全相联Cache</h3><p>对于全相联Cache，其主存块地址即为tag，该主存块可能在Cache的任意位置。当CPU访问该主存块时，该tag需要与Cache中所有块对应的tag比较，若其中有一个块的tag与主存地址的tag相同，且该目录项有效位为1，则该目录项命中；否则失效。</p><img src="/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231031164639343.png" class="" title="全相联"><h2 id="（3）替换算法"><a href="#（3）替换算法" class="headerlink" title="（3）替换算法"></a>（3）替换算法</h2><p>之前说过，无论哪种映像，都会有较多主存块共享一个（或一组）Cache块的位置的情况，所以当一个块要从主存调入Cache时。可能会出现该块所映像的一个（或一组）Cache块位置已经全部被占用的情况。这是需要通过替换算法选择一个块位置来存放这个新调入的块，替换掉这个位置原来的块。</p><ul><li>对于直接映像Cache，每个内存块只映像到一个Cache块位置，因此必定是原来在该位置的块被替换，不存在替换策略。</li><li>对于组相联和全相联Cache，每个内存块映像到一组或全部Cache块，有多个Cache块可能被选择替换掉，则就需要使用合理的替换策略，以<strong>达到尽可能避免替换掉马上就要用的Cache块的目的</strong>。</li></ul><p>主要的替换算法有以下几种：</p><h4 id="1-随机法"><a href="#1-随机法" class="headerlink" title="1. 随机法"></a>1. 随机法</h4><p>顾名思义，随机法在可能被替换的Cache块中随机地选择，<u>以便均匀使用一组中的各个块</u></p><h4 id="2-先进先出法"><a href="#2-先进先出法" class="headerlink" title="2. 先进先出法"></a>2. 先进先出法</h4><p>先进先出法（First In First Out, FIFO）选择最早调入地块作为被替换的块。其很容易实现，但<u>与局部性原理相左</u>，因为最先进入的块很可能马上就要再次使用。</p><h4 id="3-最近最少使用法"><a href="#3-最近最少使用法" class="headerlink" title="3. 最近最少使用法"></a>3. 最近最少使用法</h4><p>最近最少使用法（Least Recently Used, LRU）选择近期最久没有被访问过的块作为被替换的块，它所依据的是<u>局部性原理的推论：如果最近刚使用的块很可能就是马上要再用到的块，那么最久没有被用过的块就是最不可能再被用到的块</u></p><h4 id="4-最不常使用法"><a href="#4-最不常使用法" class="headerlink" title="4. 最不常使用法"></a>4. 最不常使用法</h4><p>最不常使用法（Least Frequently Used, LFU）选择过去一个时间段内访问次数最少的数据块，是<u>最符合局部性原理的算法</u>，但这种算法需要记录一段时间内各块被访问的次数，实现起来代价很大。</p><h2 id="（4）写策略"><a href="#（4）写策略" class="headerlink" title="（4）写策略"></a>（4）写策略</h2><p>相较于读操作，写操作显然更为复杂，因为写会更新数据，改变Cache中数据的状态，而读不会。写策略需要解决以下两个问题：</p><p>如果被写的块不在Cache中（写失效），应该怎样更新？</p><p>如果被写的块在Cache中（写命中），应该只更新Cache，还是同时更新主存中的内容？</p><h3 id="1-对于写失效情况，可以选择是否将响应的块调入Cache"><a href="#1-对于写失效情况，可以选择是否将响应的块调入Cache" class="headerlink" title="1. 对于写失效情况，可以选择是否将响应的块调入Cache"></a>1. 对于写失效情况，可以选择是否将响应的块调入Cache</h3><ul><li><strong>按写分配（Write Allocate）</strong>：先把需要写的块从内存调入Cache，然后再进行写操作。</li><li><strong>不按写分配（No Write Allocate）</strong>：直接写入内存。也称为<strong>绕写（Write Around）</strong>。</li></ul><h3 id="2-对于写命中或写失效时按写分配，有两种策略来维护Cache与主存的一致性"><a href="#2-对于写命中或写失效时按写分配，有两种策略来维护Cache与主存的一致性" class="headerlink" title="2. 对于写命中或写失效时按写分配，有两种策略来维护Cache与主存的一致性"></a>2. 对于写命中或写失效时按写分配，有两种策略来维护Cache与主存的一致性</h3><ul><li><p><strong>写直达（Write Through）</strong>：把数据写入Cache中相应的块，同时也写入主存中相应的块。也称为<strong>写穿透</strong>。</p></li><li><p><strong>写回（Write Back）</strong>：只把数据写入Cache中相应的块，只有后面在该块被替换时，才会写回内存。</p></li><li><p>按写分配通常与写回搭配；不按写分配通常与写直达搭配。</p></li><li><p>在写回法中，为了减少在替换时块的写回，常采用“脏位”标志，即为每个Cache中的块设置一个脏位（dirty）。当该块第一次被改写时，该块的脏位就会置为1，表示这个Cache块曾经被修改过，如果之后再次被改写，脏位仍为1，如果该块需要被替换回内存，则需要将该块写回内存的对应块中。反之，若该块一次都没有被改写，则不需要写回内存。</p></li><li><p>写回与写直达比较</p><table><thead><tr><th></th><th>优点</th></tr></thead><tbody><tr><td>写回</td><td>1. <strong>速度快</strong>。写操作能以Cache的速度进行       2. <strong>使用存储器带宽小</strong>。多次写只需更新一次</td></tr><tr><td>写直达</td><td>1. <strong>实现简单</strong>  2. <strong>简化了数据一致性问题</strong>。内存中的数据总是最新的</td></tr></tbody></table></li><li><p>在进行写直达时，若写操作中CPU必须等待数据写入内存，则称CPU<strong>写停顿（Write Stall）</strong>，造成性能大量损失。为了缓解该问题，可采用<strong>写缓冲器（Write Buffer）</strong>来减少写停顿的时间，写访问数据一旦进入该缓冲器，CPU就可以继续执行，从而实现延迟隐藏。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（四）</title>
      <link href="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本文是官网教程<a href="https://www.gem5.org/documentation/learning_gem5/part2/memoryobject/">gem5: Creating SimObjects in the memory system</a>的学习笔记。</p><p>本节教程是创建一个位于CPU和内存总线之间的阻塞式简单内存对象，主要实现了基本请求的传递。在下一节教程中，会在本节创建的简单内存对象之上增加部分逻辑，使其成为一个非常简单的阻塞单处理器缓存。下图是整个系统的示意图，其中，我们创建的内存对象有两个CPU侧的从端口（slave port）和一个内存总线侧的主端口（master port）。它将实现将请求从CPU传递到内存总线，并将响应从内存总线传递到CPU。</p><img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/simple_memobj.png" class="" title="System with a simple memory object which sits between a CPU and the memory bus."><h1 id="一、主从端口"><a href="#一、主从端口" class="headerlink" title="一、主从端口"></a>一、主从端口</h1><p>主端口（master port）和从端口（slave port）是模拟器中创造的概念，用于描述计算机系统中不同组件之间的数据传输关系。在模拟器中用于连接计算机系统中的各种组件。其中，<strong>主端口负责发送请求（send req）、接收响应（recv resp）</strong>；<strong>从端口负责接受请求（recv req）、发送响应（send resp）</strong>，因此，<u>主从端口必须配对使用</u>。</p><p>以本模拟系统为例，memory object有两个CPU侧的从端口，用于接收CPU的请求，并向其返回响应；同时有一个mem bus侧的主接口，用于向mem bus发送请求，并接收其响应。</p><p>这些端口实现三种不同的存储系统模式：</p><ul><li>定时模式（timing mode）。唯一的产生正确模拟结果的模式，最常用。</li><li>原子模式（atomic mode）。</li><li>功能模式（functional mode）。</li></ul><p>其他模式暂时不懂。。。</p><h1 id="二、数据包"><a href="#二、数据包" class="headerlink" title="二、数据包"></a>二、数据包</h1><p>在gem5中，<strong>端口通过发送数据包（packet）实现交互</strong>。数据包由MemReq组成，MemReq是内存请求对象。MemReq保存初始化包的原始请求的信息，例如请求者、地址和请求类型（读、写等）。数据包还有一个MemCmd，它是数据包的当前命令。此命令可以在数据包的整个生命周期中改变（例如，一旦满足内存命令，请求就变成响应）。最常见的MemCmd是ReadReq（读请求）、ReadResp（读响应）、WriteReq（写请求）、WriteResp（写响应）。还有缓存和许多其他命令类型的写回请求（WritebackDirty、WritebackClean）</p><h1 id="三、主从交互"><a href="#三、主从交互" class="headerlink" title="三、主从交互"></a>三、主从交互</h1><p>在定时模式下，主从端口的交互有以下三种情况，需要理清其函数调用链</p><h2 id="（1）正常情况下的主从交互"><a href="#（1）正常情况下的主从交互" class="headerlink" title="（1）正常情况下的主从交互"></a>（1）正常情况下的主从交互</h2><p>正常情况下，主机通过调用sendTimingReq函数发送请求，从机的recvTimingReq函数也随之被调用，如果从机目前可以接受此请求，则返回true，表示从机已经接受此次请求。从机接受请求后随即开始处理此请求。</p><p>从机处理完请求后，通过调用sendTimingResp函数发送此次请求的响应，类似地，主机的recvTimingResp函数随之被调用，如果主机目前可以接受此响应，则返回true，表示主机已经接受了此次响应。交互结束。</p><img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/master_slave_1.png" class="" title="Simple master-slave interaction when both can accept the request and the response."><h2 id="（2）从机忙时的主从交互"><a href="#（2）从机忙时的主从交互" class="headerlink" title="（2）从机忙时的主从交互"></a>（2）从机忙时的主从交互</h2><p>以上情况是主从都顺利接收的理想情况，但当从机接受请求或主机接受响应时，它们可能正忙。</p><p>下面就是从机忙时主从交互的过程。</p><p>从机忙时，从机无法接受主机发送的请求，因此recvTimingReq函数返回false，拒绝接受此次请求。但当从机结束忙态后，会通过调用sendReqRetry函数通知主机，“邀请”主机再次重试发送请求，主机通过recvReqRetry函数接收重试通知后，随机再次发起新的请求。当然，新请求也可能再次因为从机忙而被拒绝。</p><img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzgxMTM1,size_16,color_FFFFFF,t_70.png" class="" title="交互"><h2 id="（3）主机忙时的主从交互"><a href="#（3）主机忙时的主从交互" class="headerlink" title="（3）主机忙时的主从交互"></a>（3）主机忙时的主从交互</h2><p>类似地，在主机忙时，主机无法接收从机发送的响应，因此recvTimingResp函数返回false，拒绝接收此次响应。但当主机结束忙态后，会通过调用sendRespRetry函数通知从机，“邀请”从机再次重试发送响应，从机通过recvRespRetry函数接收重试通知后，随机再次发起新的响应。</p><img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzgxMTM1,size_16,color_FFFFFF,t_70-169863203577313.png" class="" title="交互"><h1 id="四、SimpleMemobj主从端口函数实现"><a href="#四、SimpleMemobj主从端口函数实现" class="headerlink" title="四、SimpleMemobj主从端口函数实现"></a>四、SimpleMemobj主从端口函数实现</h1><p>在本节的简单内存对象（SimpleMemobj）下定义了两个嵌套类CPUSidePort和MemSidePort，它们分别继承自ResponsePort&#x2F;SlavePort和RequstPort&#x2F;MasterPort，即从端口和主端口。</p><ul><li>SimpleMemobj类的成员变量<ul><li><strong>CPU侧从端口</strong>  CPUSidePort instPort; CPUSidePort dataPort;</li><li><strong>内存总线侧主端口</strong>  MemSidePort memPort; </li><li><strong>阻塞标志</strong> 目前是否正在阻塞等待一个响应 bool blocked;</li></ul></li><li>CPUSidePort类的成员变量<ul><li><strong>父对象指针（即SimpleMemobj对象）</strong> SimpleMemobj *owner;</li><li><strong>是否需要重发</strong> bool needRetry;</li><li><strong>被阻塞的数据包指针</strong> PacketPtr blockedPacket;</li></ul></li><li>MemSidePort类的成员变量<ul><li><strong>父对象指针（即SimpleMemobj对象）</strong> SimpleMemobj *owner;</li><li><strong>被阻塞的数据包指针</strong> PacketPtr blockedPacket;</li></ul></li></ul><p>各类的成员函数如下图，其中，加粗函数为必须实现的函数，未加粗的函数为在父类中已经实现的函数。</p><img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/memobj_api.png" class="" title="Interaction between SimpleMemobj and its ports"><p>下面按上图顺序分别对五个函数调用链进行梳理 </p><h2 id="textcolor-RGB-250-106-106-1-获取内存模型的地址范围-CPU-–-Mem-bus"><a href="#textcolor-RGB-250-106-106-1-获取内存模型的地址范围-CPU-–-Mem-bus" class="headerlink" title="$\textcolor[RGB]{250,106,106}{(1)获取内存模型的地址范围         (CPU –&gt; Mem bus)}$"></a>$\textcolor[RGB]{250,106,106}{(1)获取内存模型的地址范围         (CPU –&gt; Mem bus)}$</h2><p>CPU 发送请求，查询内存模型的地址范围，并返回一个 AddrRangeList 类型的值。这种查询请求<strong>不存在阻塞情况</strong>。</p><h3 id="1-SimpleMemobj-CPUSidePort-getAddrRanges"><a href="#1-SimpleMemobj-CPUSidePort-getAddrRanges" class="headerlink" title="1. SimpleMemobj::CPUSidePort::getAddrRanges"></a>1. SimpleMemobj::CPUSidePort::getAddrRanges</h3><p>CPUSidePort直接将请求传递给其父对象SimpleMemobj</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AddrRangeList</span><br><span class="line">SimpleMemobj::CPUSidePort::getAddrRanges() const</span><br><span class="line">&#123;</span><br><span class="line">    return owner-&gt;getAddrRanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SimpleMemobj-getAddrRanges"><a href="#2-SimpleMemobj-getAddrRanges" class="headerlink" title="2. SimpleMemobj::getAddrRanges"></a>2. SimpleMemobj::getAddrRanges</h3><p>SimpleMemobj同样直接将请求传递给其子对象MemSidePort </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AddrRangeList</span><br><span class="line">SimpleMemobj::getAddrRanges() const</span><br><span class="line">&#123;</span><br><span class="line">    DPRINTF(SimpleMemobj, &quot;Sending new ranges\n&quot;);</span><br><span class="line">    // Just use the same ranges as whatever is on the memory side.</span><br><span class="line">    return memPort.getAddrRanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MemSidePort.getAddrRanges()函数已经在MemSidePort的父类RequestPort中被实现了，返回地址范围，可直接使用。</p><h2 id="textcolor-RGB-100-106-255-2-通知内存模型的地址范围发生更改-Mem-bus-–-CPU"><a href="#textcolor-RGB-100-106-255-2-通知内存模型的地址范围发生更改-Mem-bus-–-CPU" class="headerlink" title="$\textcolor[RGB]{100,106,255}{(2)通知内存模型的地址范围发生更改(Mem bus –&gt; CPU)} $"></a>$\textcolor[RGB]{100,106,255}{(2)通知内存模型的地址范围发生更改(Mem bus –&gt; CPU)} $</h2><p>Mem bus发送请求，向CPU通知内存模型的地址范围发生更改，同样此通知也<strong>不会阻塞</strong>。</p><h3 id="1-SimpleMemobj-MemSidePort-recvRangeChange"><a href="#1-SimpleMemobj-MemSidePort-recvRangeChange" class="headerlink" title="1. SimpleMemobj::MemSidePort::recvRangeChange"></a>1. SimpleMemobj::MemSidePort::recvRangeChange</h3><p>MemSidePort 直接将请求传递给其父对象 SimpleMemobj</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::MemSidePort::recvRangeChange()</span><br><span class="line">&#123;</span><br><span class="line">    owner-&gt;sendRangeChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SimpleMemobj-sendRangeChange"><a href="#2-SimpleMemobj-sendRangeChange" class="headerlink" title="2. SimpleMemobj::sendRangeChange"></a>2. SimpleMemobj::sendRangeChange</h3><p>SimpleMemobj同样直接将请求传递给其子对象CPUSidePort</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::sendRangeChange()</span><br><span class="line">&#123;</span><br><span class="line">    instPort.sendRangeChange();</span><br><span class="line">    dataPort.sendRangeChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CPUSidePort.sendRangeChange函数同样已经在CPUSidePort的父类ResponsePort中被实现了，可直接使用。</p><h2 id="textcolor-RGB-250-250-100-3-功能请求与响应-CPU-–-Mem-bus"><a href="#textcolor-RGB-250-250-100-3-功能请求与响应-CPU-–-Mem-bus" class="headerlink" title="$\textcolor[RGB]{250,250,100}{(3)功能请求与响应(CPU –&gt; Mem bus)} $"></a>$\textcolor[RGB]{250,250,100}{(3)功能请求与响应(CPU –&gt; Mem bus)} $</h2><p>功能请求是指不改变系统状态的请求，通常用于读取数据或检查系统状态。同样这种请求也<strong>不会发生阻塞</strong>。</p><p>这个过程的调用链与获取地址范围大致相同，只不过需要传递数据包指针。</p><h3 id="1-SimpleMemobj-CPUSidePort-recvFunctional"><a href="#1-SimpleMemobj-CPUSidePort-recvFunctional" class="headerlink" title="1. SimpleMemobj::CPUSidePort::recvFunctional"></a>1. SimpleMemobj::CPUSidePort::recvFunctional</h3><p>CPUSidePort直接将请求传递给其父对象 SimpleMemobj</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::CPUSidePort::recvFunctional(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Just forward to the memobj.</span><br><span class="line">    return owner-&gt;handleFunctional(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SimpleMemobj-handleFunctional"><a href="#2-SimpleMemobj-handleFunctional" class="headerlink" title="2. SimpleMemobj::handleFunctional"></a>2. SimpleMemobj::handleFunctional</h3><p>SimpleMemobj同样直接将请求传递给其子对象MemSidePort </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::handleFunctional(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Just pass this on to the memory side to handle for now.</span><br><span class="line">    memPort.sendFunctional(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MemSidePort.sendFunctional()函数已经在MemSidePort的父类RequestPort中被实现了，可直接使用。</p><h2 id="textcolor-RGB-250-100-250-4-发送定时请求-CPU-–-Mem-bus"><a href="#textcolor-RGB-250-100-250-4-发送定时请求-CPU-–-Mem-bus" class="headerlink" title="$\textcolor[RGB]{250,100,250}{(4)发送定时请求(CPU –&gt; Mem bus)} $"></a>$\textcolor[RGB]{250,100,250}{(4)发送定时请求(CPU –&gt; Mem bus)} $</h2><p>定时请求是指需要等待一段时间后才能完成的请求，通常用于写入数据或执行耗时操作。由于CPU发送请求时，mem bus可能尚未处理完上一次请求，处于忙态，无法接收此次请求，因此这个过程<strong>可能会发生阻塞</strong>。</p><h3 id="1-SimpleMemobj-CPUSidePort-recvTimingReq"><a href="#1-SimpleMemobj-CPUSidePort-recvTimingReq" class="headerlink" title="1. SimpleMemobj::CPUSidePort::recvTimingReq"></a>1. SimpleMemobj::CPUSidePort::recvTimingReq</h3><p>CPUSidePort尝试通过父对象 SimpleMemobj的handleRequest函数发送定时请求</p><p>如果成功，返回true；</p><p>如果失败，将needRetry置为true并返回false，该请求被阻止，CPU在将来某个时候需要发送一个重试（SimpleMemobj::CPUSidePort::trySendRetry()函数）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">SimpleMemobj::CPUSidePort::recvTimingReq(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Just forward to the memobj.</span><br><span class="line">    if (!owner-&gt;handleRequest(pkt)) &#123;</span><br><span class="line">        needRetry = true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SimpleMemobj-handleRequest"><a href="#2-SimpleMemobj-handleRequest" class="headerlink" title="2. SimpleMemobj::handleRequest"></a>2. SimpleMemobj::handleRequest</h3><p>来到SimpleMemobj的handleRequest函数。首先检查目前没有在等待响应（被阻塞）</p><p>如果没有被阻塞，则将blocked置为true，即进入阻塞状态，并通过子对象MemSidePort的sendPacket函数发送数据包，并返回true；</p><p>反之如果被阻塞，直接返回false，拒绝此请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">SimpleMemobj::handleRequest(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    if (blocked) &#123;</span><br><span class="line">        // There is currently an outstanding request. Stall.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    DPRINTF(SimpleMemobj, &quot;Got request for addr %#x\n&quot;, pkt-&gt;getAddr());</span><br><span class="line">    </span><br><span class="line">    // This memobj is now blocked waiting for the response to this packet.</span><br><span class="line">    blocked = true;</span><br><span class="line">    </span><br><span class="line">    // Simply forward to the memory port</span><br><span class="line">    memPort.sendPacket(pkt);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-SimpleMemobj-MemSidePort-sendPacket"><a href="#3-SimpleMemobj-MemSidePort-sendPacket" class="headerlink" title="3. SimpleMemobj::MemSidePort::sendPacket"></a>3. SimpleMemobj::MemSidePort::sendPacket</h3><p>MemSidePort的sendPacket会调用sendTimingReq函数（在其父类中定义，可直接使用）发送请求数据包给内存总线。如果发送不成功，则将要发送的数据包指针保存下来，准备重发该数据包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::MemSidePort::sendPacket(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Note: This flow control is very simple since the memobj is blocking.</span><br><span class="line">    panic_if(blockedPacket != nullptr, &quot;Should never try to send if blocked!&quot;);</span><br><span class="line">    </span><br><span class="line">    // If we can&#x27;t send the packet across the port, store it for later.</span><br><span class="line">    if (!sendTimingReq(pkt)) &#123;</span><br><span class="line">        blockedPacket = pkt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-SimpleMemobj-MemSidePort-recvReqRetry"><a href="#4-SimpleMemobj-MemSidePort-recvReqRetry" class="headerlink" title="4. SimpleMemobj::MemSidePort::recvReqRetry"></a>4. SimpleMemobj::MemSidePort::recvReqRetry</h3><p>内存总线结束忙态后，会调用MemSidePort类的recvReqRetry邀请MemSidePort重发之前被阻塞的请求数据包，即重发blockedPacket数据包。注意：在重发前，应该一定会有被阻塞的数据包，否则报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::MemSidePort::recvReqRetry()</span><br><span class="line">&#123;</span><br><span class="line">    // We should have a blocked packet if this function is called.</span><br><span class="line">    assert(blockedPacket != nullptr);</span><br><span class="line"></span><br><span class="line">    // Grab the blocked packet.</span><br><span class="line">    PacketPtr pkt = blockedPacket;</span><br><span class="line">    blockedPacket = nullptr;</span><br><span class="line"></span><br><span class="line">    // Try to resend it. It&#x27;s possible that it fails again.</span><br><span class="line">    sendPacket(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="textcolor-RGB-100-250-250-5-接收定时请求的响应-Mem-bus-–-CPU"><a href="#textcolor-RGB-100-250-250-5-接收定时请求的响应-Mem-bus-–-CPU" class="headerlink" title="$\textcolor[RGB]{100,250,250}{(5)接收定时请求的响应(Mem bus –&gt; CPU)} $"></a>$\textcolor[RGB]{100,250,250}{(5)接收定时请求的响应(Mem bus –&gt; CPU)} $</h2><p>内存总线处理完定时请求后，会向CPU发送该定时请求的响应。类似地，CPU也可能会因为处于忙态而拒绝接收响应，也<strong>可能会存在阻塞</strong></p><h3 id="1-SimpleMemobj-MemSidePort-recvTimingResp"><a href="#1-SimpleMemobj-MemSidePort-recvTimingResp" class="headerlink" title="1. SimpleMemobj::MemSidePort::recvTimingResp"></a>1. SimpleMemobj::MemSidePort::recvTimingResp</h3><p>MemSidePort直接将请求传递给其父对象SimpleMemobj</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">SimpleMemobj::MemSidePort::recvTimingResp(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Just forward to the memobj.</span><br><span class="line">    return owner-&gt;handleResponse(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SimpleMemobj-handleResponse"><a href="#2-SimpleMemobj-handleResponse" class="headerlink" title="2. SimpleMemobj::handleResponse"></a>2. SimpleMemobj::handleResponse</h3><p>SimpleMemobj处理响应时，首先因为收到了响应所以消除阻塞状态，然后根据数据包的属性确定是发送给指令端口还是数据端口。</p><p>接触了阻塞状态以后，会尝试通过trySendRetry()函数让CPU重发未能成功发送的请求（如果有的话）。</p><p>注意：在接收响应时，SimpleMemobj应该一定处于阻塞状态，否则报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">SimpleMemobj::handleResponse(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    assert(blocked);</span><br><span class="line">    DPRINTF(SimpleMemobj, &quot;Got response for addr %#x\n&quot;, pkt-&gt;getAddr());</span><br><span class="line"></span><br><span class="line">    // The packet is now done. We&#x27;re about to put it in the port, no need for</span><br><span class="line">    // this object to continue to stall.</span><br><span class="line">    // We need to free the resource before sending the packet in case the CPU</span><br><span class="line">    // tries to send another request immediately (e.g., in the same callchain).</span><br><span class="line">    blocked = false;</span><br><span class="line"></span><br><span class="line">    // Simply forward to the memory port</span><br><span class="line">    if (pkt-&gt;req-&gt;isInstFetch()) &#123;</span><br><span class="line">        instPort.sendPacket(pkt);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dataPort.sendPacket(pkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // For each of the cpu ports, if it needs to send a retry, it should do it</span><br><span class="line">    // now since this memory object may be unblocked now.</span><br><span class="line">    instPort.trySendRetry();</span><br><span class="line">    dataPort.trySendRetry();</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-SimpleMemobj-CPUSidePort-sendPacket"><a href="#3-SimpleMemobj-CPUSidePort-sendPacket" class="headerlink" title="3. SimpleMemobj::CPUSidePort::sendPacket"></a>3. SimpleMemobj::CPUSidePort::sendPacket</h3><p>CPUSidePort的sendPacket会调用sendTimingReq函数（在其父类中定义，可直接使用）发送响应数据包给CPU。如果发送不成功，则将要发送的数据包指针保存下来，准备重发该数据包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::CPUSidePort::sendPacket(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Note: This flow control is very simple since the memobj is blocking.</span><br><span class="line"></span><br><span class="line">    panic_if(blockedPacket != nullptr, &quot;Should never try to send if blocked!&quot;);</span><br><span class="line"></span><br><span class="line">    // If we can&#x27;t send the packet across the port, store it for later.</span><br><span class="line">    if (!sendTimingResp(pkt)) &#123;</span><br><span class="line">        blockedPacket = pkt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-SimpleMemobj-CPUSidePort-trySendRetry"><a href="#4-SimpleMemobj-CPUSidePort-trySendRetry" class="headerlink" title="4. SimpleMemobj::CPUSidePort::trySendRetry"></a>4. SimpleMemobj::CPUSidePort::trySendRetry</h3><p>尝试让CPU重发未能发送的请求</p><p>如果needRetry为True，则说明之前CPU有未能发送的请求；如果blockedPacket指针为空，说明SimpleMemobj未处于阻塞状态，则可以通过sendRetryReq函数（父类中已经实现，可直接使用）让CPU重发请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::CPUSidePort::trySendRetry()</span><br><span class="line">&#123;</span><br><span class="line">    if (needRetry &amp;&amp; blockedPacket == nullptr) &#123;</span><br><span class="line">        // Only send a retry if the port is now completely free</span><br><span class="line">        needRetry = false;</span><br><span class="line">        DPRINTF(SimpleMemobj, &quot;Sending retry req for %d\n&quot;, id);</span><br><span class="line">        sendRetryReq();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-SimpleMemobj-CPUSidePort-recvRespRetry"><a href="#5-SimpleMemobj-CPUSidePort-recvRespRetry" class="headerlink" title="5. SimpleMemobj::CPUSidePort::recvRespRetry"></a>5. SimpleMemobj::CPUSidePort::recvRespRetry</h3><p>CPU忙态结束以后，会通过调用CPUSidePort类的recvRespRetry函数邀请CPUSidePort重新发送之前被阻塞的响应数据包，即重发blockedPacket数据包。注意：在重发前，应该一定会有被阻塞的数据包，否则报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::CPUSidePort::recvRespRetry()</span><br><span class="line">&#123;</span><br><span class="line">    // We should have a blocked packet if this function is called.</span><br><span class="line">    assert(blockedPacket != nullptr);</span><br><span class="line"></span><br><span class="line">    // Grab the blocked packet.</span><br><span class="line">    PacketPtr pkt = blockedPacket;</span><br><span class="line">    blockedPacket = nullptr;</span><br><span class="line"></span><br><span class="line">    // Try to resend it. It&#x27;s possible that it fails again.</span><br><span class="line">    sendPacket(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、配置脚本"><a href="#五、配置脚本" class="headerlink" title="五、配置脚本"></a>五、配置脚本</h1><p>实例化SimpleMemobj对象，并运行hello world负载的配置脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import m5</span><br><span class="line">from m5.objects import *</span><br><span class="line"></span><br><span class="line">system = System()</span><br><span class="line">system.clk_domain = SrcClockDomain()</span><br><span class="line">system.clk_domain.clock = &#x27;1GHz&#x27;</span><br><span class="line">system.clk_domain.voltage_domain = VoltageDomain()</span><br><span class="line">system.mem_mode = &#x27;timing&#x27;</span><br><span class="line">system.mem_ranges = [AddrRange(&#x27;512MB&#x27;)]</span><br><span class="line"></span><br><span class="line">system.cpu = TimingSimpleCPU()</span><br><span class="line"></span><br><span class="line">system.memobj = SimpleMemobj()</span><br><span class="line"></span><br><span class="line">system.cpu.icache_port = system.memobj.inst_port</span><br><span class="line">system.cpu.dcache_port = system.memobj.data_port</span><br><span class="line"></span><br><span class="line">system.membus = SystemXBar()</span><br><span class="line"></span><br><span class="line">system.memobj.mem_side = system.membus.slave</span><br><span class="line"></span><br><span class="line">system.cpu.createInterruptController()</span><br><span class="line">system.cpu.interrupts[0].pio = system.membus.master</span><br><span class="line">system.cpu.interrupts[0].int_master = system.membus.slave</span><br><span class="line">system.cpu.interrupts[0].int_slave = system.membus.master</span><br><span class="line"></span><br><span class="line">system.mem_ctrl = DDR3_1600_8x8()</span><br><span class="line">system.mem_ctrl.range = system.mem_ranges[0]</span><br><span class="line">system.mem_ctrl.port = system.membus.master</span><br><span class="line"></span><br><span class="line">system.system_port = system.membus.slave</span><br><span class="line"></span><br><span class="line">process = Process()</span><br><span class="line">process.cmd = [&#x27;tests/test-progs/hello/bin/x86/linux/hello&#x27;]</span><br><span class="line">system.cpu.workload = process</span><br><span class="line">system.cpu.createThreads()</span><br><span class="line"></span><br><span class="line">root = Root(full_system = False, system = system)</span><br><span class="line">m5.instantiate()</span><br><span class="line"></span><br><span class="line">print &quot;Beginning simulation!&quot;</span><br><span class="line">exit_event = m5.simulate()</span><br><span class="line">print &#x27;Exiting @ tick %i because %s&#x27; % (m5.curTick(), exit_event.getCause())</span><br></pre></td></tr></table></figure><ol><li>在命令行执行以下命令，可以运行模拟系统</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/X86/gem5.opt configs/learning_gem5/part2/simple_memobj.py</span><br></pre></td></tr></table></figure><p>输出内容出现Hello World则模拟成功。</p><ol start="2"><li>在命令行执行以下命令，可以在debug模式下运行模拟系统，由于输出较多，只输出前五十行。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/X86/gem5.opt --debug-flags=SimpleMemobj configs/learning_gem5/part2/simple_memobj.py | head -n 50</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Beginning simulation!</span><br><span class="line">      0: system.memobj: Got request for addr 0x190</span><br><span class="line">  77000: system.memobj: Got response for addr 0x190</span><br><span class="line">  77000: system.memobj: Got request for addr 0x190</span><br><span class="line"> 126000: system.memobj: Got response for addr 0x190</span><br><span class="line"> 126000: system.memobj: Got request for addr 0x190</span><br><span class="line"> 175000: system.memobj: Got response for addr 0x190</span><br><span class="line"> 175000: system.memobj: Got request for addr 0x94db0</span><br><span class="line"> 238000: system.memobj: Got response for addr 0x94db0</span><br><span class="line"> 238000: system.memobj: Got request for addr 0x190</span><br><span class="line"> 287000: system.memobj: Got response for addr 0x190</span><br><span class="line"> 287000: system.memobj: Got request for addr 0x198</span><br><span class="line"> 336000: system.memobj: Got response for addr 0x198</span><br><span class="line"> 336000: system.memobj: Got request for addr 0x198</span><br><span class="line"> 385000: system.memobj: Got response for addr 0x198</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Gem5模拟器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gem5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理——图片拼接</title>
      <link href="/2023/10/25/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E6%8B%BC%E6%8E%A5/"/>
      <url>/2023/10/25/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E6%8B%BC%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="问题导入"><a href="#问题导入" class="headerlink" title="问题导入"></a>问题导入</h1><p>图片全景拼接</p><p>观察者在同一个点，不是简单的平移旋转，需要运用投射关系（近大远小）</p><h1 id="图像全局变换"><a href="#图像全局变换" class="headerlink" title="图像全局变换"></a>图像全局变换</h1><p>研究对象为二维图像</p><h2 id="1-线性变换"><a href="#1-线性变换" class="headerlink" title="1. 线性变换"></a>1. 线性变换</h2><p>缩放 Scale</p><p>旋转 Rotation</p><p>剪切 Shear</p><p>镜像 mirror</p><p>S &#x3D; 2 * 2矩阵<br>$$<br>S &#x3D; \begin{bmatrix}<br> a &amp; b\<br> c &amp; d<br>\end{bmatrix}<br>$$</p><h2 id="2-仿射变换"><a href="#2-仿射变换" class="headerlink" title="2. 仿射变换"></a>2. 仿射变换</h2><p>仿射变换 &#x3D; 线性变换+平移</p><p>S &#x3D; 3 * 3矩阵<br>$$<br> S &#x3D; \begin{bmatrix} a &amp; b &amp; c\ d &amp; e &amp; f\ 0 &amp; 0 &amp; 1\end{bmatrix}<br>$$<br>6个未知数</p><h2 id="3-投影变换"><a href="#3-投影变换" class="headerlink" title="3. 投影变换"></a>3. 投影变换</h2><p>S &#x3D; 3 * 3矩阵<br>$$<br>S &#x3D; \begin{bmatrix}<br> a &amp; b &amp; c\<br> d &amp; e &amp; f\<br> g &amp; h &amp; 1<br>\end{bmatrix}<br>$$<br>8个未知数，即8个自由度，表示能力最强</p>]]></content>
      
      
      <categories>
          
          <category> 数字图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片拼接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（三）</title>
      <link href="/2023/10/24/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/10/24/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Gem5学习——创建一个简单的SimObject"><a href="#Gem5学习——创建一个简单的SimObject" class="headerlink" title="Gem5学习——创建一个简单的SimObject"></a>Gem5学习——创建一个简单的SimObject</h1><h2 id="一、名词解释"><a href="#一、名词解释" class="headerlink" title="一、名词解释"></a>一、名词解释</h2><ul><li><p>$\textcolor[RGB]{200,50,50}{SimObject}$</p><p>在gem5中，SimObject是一个基础类，用于<strong>创建和管理模拟对象</strong>。</p></li><li><p>$\textcolor[RGB]{200,50,50}{SimObjects}$</p><p>SimObjects是gem5中用于管理模拟对象的组件。通常，gem5中的模拟对象都会继承自SimpleObject类，并且通过SimObjects组件来进行管理。</p></li><li><p>$\textcolor[RGB]{200,50,50}{SimpleObject}$</p><p>SimpleObject是SimObject类的一个派生类，它在SimObject类的基础上增加了一些额外的功能，通常，在gem5中创建新的模拟对象时，都会从SimpleObject类进行派生，以便获得这些基本的功能。</p></li></ul><h2 id="二、创建一个简单的SimObject"><a href="#二、创建一个简单的SimObject" class="headerlink" title="二、创建一个简单的SimObject"></a>二、创建一个简单的SimObject</h2><p>即官网教程创建helloobject<a href="https://www.gem5.org/documentation/learning_gem5/part2/helloobject/">gem5: Creating a very simple SimObject</a></p><p><strong>$\textcolor[RGB]{100,200,50}{Gem5使用了Python和C++两种编程语言混合编程}$</strong></p><p>gem5一方面通过python语言配置模拟器运行的参数和控制模拟过程的脚本，优势在于便于快速阅读和编写配置脚本；另一方面通过C++实现gem5中的各种模型（SimObjects），优势在于C++是一种高性能的编程语言，能够保证其模拟性能。混合编程充分发挥了两种语言的优势。</p>]]></content>
      
      
      <categories>
          
          <category> Gem5模拟器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gem5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（二）</title>
      <link href="/2023/10/24/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/10/24/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>d69</p>]]></content>
      
      
      <categories>
          
          <category> Gem5模拟器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gem5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1023-1028</title>
      <link href="/2023/10/23/1023-1028/"/>
      <url>/2023/10/23/1023-1028/</url>
      
        <content type="html"><![CDATA[<p><strong>10月23日</strong></p><p>根据博客，继续学习gem5的构建模拟环境、创建simObject</p>]]></content>
      
      
      <categories>
          
          <category> 毕设学习记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SCons</title>
      <link href="/2023/10/23/SCons/"/>
      <url>/2023/10/23/SCons/</url>
      
        <content type="html"><![CDATA[<p>scons是一个Python写的自动化构建工具</p><p><a href="https://blog.csdn.net/danshiming/article/details/122771064?ops_request_misc=%7B%22request_id%22:%22169805899416777224422665%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=169805899416777224422665&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122771064-null-null.142%5Ev96%5Epc_search_result_base2&utm_term=SCons&spm=1018.2226.3001.4187">SCons简单入门（一）-CSDN博客</a></p><p><a href="https://www.scons.org/doc/production/HTML/scons-user/index.html">SCons 4.5.2官方文档</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Scons </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：指令系统</title>
      <link href="/2023/10/22/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/10/22/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-指令系统结构的分类"><a href="#1-指令系统结构的分类" class="headerlink" title="1 指令系统结构的分类"></a>1 指令系统结构的分类</h1><p>CPU中用来存放操作数的存储单元主要有三种：<strong>堆栈</strong>、<strong>累加器</strong>、<strong>通用寄存器组</strong>。据此，指令系统（Instruction Set Architecture）可分为三种：</p><ul><li><strong>$\color[RGB]{40,120,181}{堆栈型结构}$：</strong>堆栈栈顶和次栈顶中的数据，运算后写入栈顶。两个操作数都是隐式的。<strong>优点：</strong>指令字比较短，程序占用的空间小；<strong>缺点：</strong>不能随机地访问堆栈，难以生成有效的代码，而且对栈顶的访问是个瓶颈。</li><li><strong>$\color[RGB]{40,120,181}{累加器型结构}$：</strong>一个操作数是隐式的，即累加器；另一个是显示给出的。<strong>优点：</strong>指令字比较短，程序占用的空间小；<strong>缺点：</strong>只有一个中间结果暂存在累加器中，需要频繁访问存储器。</li></ul><p>早期计算机大多采用堆栈型结构或累加器型结构</p><ul><li><strong>$\color[RGB]{40,120,181}{通用寄存器型结构}$：</strong>所有操作数都是显示给出的。<strong>优点：</strong>1.寄存器的访问比存储器快得多 2. 编译器能够更加容易、有效地分配寄存器 。根据操作数显式给出的来源不同，又可以分为两类：<ul><li>$\color[RGB]{248,172,140}{寄存器-存储器型结构(RM结构)}:$一个操作数来自寄存器，另一个来自存储器。</li><li>$\color[RGB]{248,172,140}{寄存器-寄存器型结构(RR结构)}:$两个操作数都来自寄存器。</li></ul></li></ul><p>**显式给出:**用指令字中的操作数字段给出</p><p>**隐式给出:**用事先约定好的单元</p><h1 id="2-寻址方式"><a href="#2-寻址方式" class="headerlink" title="2. 寻址方式"></a>2. 寻址方式</h1><p>寻址方式（Addressing Mode）是指指令系统中产生所要访问的数据地址的方法。寻址方式可以指明指令中的操作数是一个<strong>立即数</strong>、一个<strong>寄存器操作数</strong>或者是一个<strong>存储器操作数</strong></p><h2 id="2-1-寻址方式举例"><a href="#2-1-寻址方式举例" class="headerlink" title="2.1 寻址方式举例"></a>2.1 寻址方式举例</h2><ul><li>寄存器寻址</li><li>立即数寻址</li><li>偏移寻址</li></ul><p>等等</p><h2 id="2-2-字节对齐"><a href="#2-2-字节对齐" class="headerlink" title="2.2 字节对齐"></a>2.2 字节对齐</h2><p>计算机中信息的单位可分为字节(8bit)、半字(16bit)、单字(32bit)、双字(64bit)。计算机中采用按字节编址，各类信息都是用改信息的首字节地址来寻址的。</p><h3 id="信息存储的整数边界"><a href="#信息存储的整数边界" class="headerlink" title="信息存储的整数边界"></a>信息存储的整数边界</h3><p>此外还需要对它们的存储方式进行限制，如果允许它们任意存储，就可能出现一个信息跨存储字边界而存储与两个存储单元的情况，而在这种情况下，读取该信息就需要花费两个存储周期，为了避免出现这个问题，就要求<strong>宽度不超过主存宽度的信息必须存放在一个存储字内，信息在主存中存放的起始地址必须是该信息宽度（字节数）的整数倍</strong>，从而避免了跨边界，保证了访问速度。</p><p>对于一个32位机器（主存宽度为32位），要求：</p><h5 id="字节信息的起始地址为：x…xxxx"><a href="#字节信息的起始地址为：x…xxxx" class="headerlink" title="字节信息的起始地址为：x…xxxx"></a>字节信息的起始地址为：x…xxxx</h5><h5 id="半字信息的起始地址为：x…xxx0"><a href="#半字信息的起始地址为：x…xxx0" class="headerlink" title="半字信息的起始地址为：x…xxx0"></a>半字信息的起始地址为：x…xxx0</h5><h5 id="单字信息的起始地址为：x…xx00"><a href="#单字信息的起始地址为：x…xx00" class="headerlink" title="单字信息的起始地址为：x…xx00"></a>单字信息的起始地址为：x…xx00</h5><h5 id="双字信息的起始地址为：x…x000"><a href="#双字信息的起始地址为：x…x000" class="headerlink" title="双字信息的起始地址为：x…x000"></a>双字信息的起始地址为：x…x000</h5>]]></content>
      
      
      <categories>
          
          <category> 《计算机体系结构》学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
            <tag> 指令系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1019-1021</title>
      <link href="/2023/10/19/1019-1021/"/>
      <url>/2023/10/19/1019-1021/</url>
      
        <content type="html"><![CDATA[<h1 id="10-18"><a href="#10-18" class="headerlink" title="10.18"></a>10.18</h1><p>在Ubuntu20.04系统上成功配置gem5模拟器，并根据官网的教程编译了第一个单核x86架构系统，并运行hello world负载。</p><h1 id="10-19"><a href="#10-19" class="headerlink" title="10.19"></a>10.19</h1><p>进一步学习官网教程，阅读博客</p><p><a href="https://csdiy.wiki/">CS自学指南 (csdiy.wiki)</a></p>]]></content>
      
      
      <categories>
          
          <category> 毕设学习记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo主题和插件</title>
      <link href="/2023/10/18/hexo%E4%B8%BB%E9%A2%98%E5%92%8C%E6%8F%92%E4%BB%B6/"/>
      <url>/2023/10/18/hexo%E4%B8%BB%E9%A2%98%E5%92%8C%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Hexo主题"><a href="#1-Hexo主题" class="headerlink" title="1. Hexo主题"></a>1. Hexo主题</h1><p>hexo官方提供了很多的主题模板，可以在<a href="https://hexo.io/themes/index.html">hexo主题官网</a>中看到，<a href="https://hexo.io/zh-cn/docs/themes.html">官方教程</a>中也有配置主题操作</p><h2 id="Next主题"><a href="#Next主题" class="headerlink" title="Next主题"></a><strong>Next主题</strong></h2><p>在众多主题中，Next是最受欢迎的主题之一，它提供了许多的界面模板，并且支持安装许多的插件。</p><h2 id="Next主题下载"><a href="#Next主题下载" class="headerlink" title="Next主题下载"></a><strong>Next主题下载</strong></h2><ol><li><p>$\color[RGB]{200, 100, 10}{下载}$。在git bash窗口中通过git clone即可下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>下载成功后，在<strong>blog&#x2F;themes</strong>文件夹下即可找到下载的next主题文件夹，其中包含了next主题的配置信息</p></li><li><p>$\color[RGB]{200, 100, 10}{修改Hexo主题}$。返回<strong>bolg根目录</strong>，打开**_config.yml 文件**，并将其中的theme项的值改为next</p></li></ol><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src=hexo主题和插件/image-20231019001323077.png>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #FFF;    padding: 2px;">hexo主题修改为next</div></center><p>经过以上两步，hexo的主题就成功更换为next啦！然后就通过hexo g重新生成博客，再通过hexo s 或 hexo d发布新的博客，看看新主题的样子。</p><hr><h1 id="2-添加分类、标签、关于"><a href="#2-添加分类、标签、关于" class="headerlink" title="2. 添加分类、标签、关于"></a>2. 添加分类、标签、关于</h1><p><a href="https://blog.csdn.net/weixin_48927364/article/details/123295436">【Hexo】nexT主题使用攻略基础——添加分类、标签及关于_hexo 分类-CSDN博客</a></p><h1 id="3-Hexo常用插件"><a href="#3-Hexo常用插件" class="headerlink" title="3. Hexo常用插件"></a>3. Hexo常用插件</h1><h2 id="（1）插入数学公式"><a href="#（1）插入数学公式" class="headerlink" title="（1）插入数学公式"></a>（1）插入数学公式</h2><p>在用markdown写技术文档时，免不了会碰到数学公式。Next这种大主题也集成了渲染数学公式的功能</p><p>目前Next提供两种数学公式渲染引擎，分别是Mathjax和Katex。</p><p>可以在Next主题的配置文件_config.yml中看到这两个项</p><img src="/2023/10/18/hexo%E4%B8%BB%E9%A2%98%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231019132036641.png" class="" title="Next主题的配置文件_config.yml"><p>默认情况下两个引擎的enable使能选项均为false，只需要改为true就可以渲染数学公式了</p><p>其中every_page项置为true的时候，引擎会默认对每篇博客中的数学公式进行渲染，但对于不含数学公式的博客，加载速度会额外变慢；而当置为false是，只会对在开头处声明使用mathjax引擎的博客进行渲染。</p><img src="/2023/10/18/hexo%E4%B8%BB%E9%A2%98%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231019145600478.png" class="" title="博客开头声明使用mathjax引擎"><p><strong>效果展示：</strong></p><ul><li><p>行内公式：</p><p>$f\left( x \right) &#x3D; \sum\limits_{i &#x3D; 1}^n {X_i^2} $</p><p>$MD\left(n_{i, j}, n_{x, y}\right)&#x3D;|i-x|+|j-y|$</p></li><li><p>行间公式：</p><p>$$ f\left( x \right) &#x3D; \sum\limits_{i &#x3D; 1}^n {X_i^2} $$</p><p>$$ MD\left(n_{i, j}, n_{x, y}\right)&#x3D;|i-x|+|j-y|$$</p></li></ul><p>（2）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu虚拟机</title>
      <link href="/2023/10/17/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2023/10/17/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu20-04-iso镜像国内阿里源下载"><a href="#Ubuntu20-04-iso镜像国内阿里源下载" class="headerlink" title="Ubuntu20.04 iso镜像国内阿里源下载"></a>Ubuntu20.04 iso镜像国内阿里源下载</h1><p><a href="http://mirrors.aliyun.com/ubuntu-releases/20.04/">ubuntu-releases-20.04安装包下载_开源镜像站-阿里云 (aliyun.com)</a></p><h1 id="Ubuntu20-04更换清华源"><a href="#Ubuntu20-04更换清华源" class="headerlink" title="Ubuntu20.04更换清华源"></a>Ubuntu20.04更换清华源</h1><p>Ubuntu安装完之后进行更换为国内源可以让下载更新的的速度快一点。</p><p>以下是具体操作的博客</p><p><a href="https://www.cnblogs.com/Lxk0825/p/9520002.html">ubuntu 执行apt-get update报错Failed to fetch - Lxk- - 博客园 (cnblogs.com)</a></p><p>使用清华源，将以下代码输入&#x2F;etc&#x2F;apt&#x2F;sources.list文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（一）</title>
      <link href="/2023/10/17/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/10/17/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Gem5模拟器简介"><a href="#一、Gem5模拟器简介" class="headerlink" title="一、Gem5模拟器简介"></a>一、Gem5模拟器简介</h1><p>gem5是一个开源、模块化的时钟精确的全系统模拟器，应用于计算机体系结构研究。该模拟器可以对CPU、存储系统、片上互连系统、I&#x2F;O等系统组件进行详细的建模，并通过修改不同组件的具体实现和各个组件的配置参数可以灵活配置不同的计算系统。</p><h2 id="1-1-模拟组件"><a href="#1-1-模拟组件" class="headerlink" title="1.1 模拟组件"></a>1.1 模拟组件</h2><ul><li><p><strong>$\color[RGB]{0,150,255}{多种ISA}$</strong> ：gem5支持常见的各种指令集：X86、ARM、RISCV、SPARC、POWER、MIPS。不同的指令集包含了每条指令执行的完整过程。当前gem5中可用于全系统模拟的ISA主要有ARM、X86和RISCV；</p></li><li><p><strong>$\color[RGB]{0,150,255}{多种CPU模型}$</strong> ：gem5支持4种CPU模型：Simple、In-Order、Out-of-Order(简称O3)和KVM。每种CPU的具体实现和ISA不关联，因此CPU模型和ISA间可以任意搭配以组成多种计算机系统；</p></li><li><p><strong>$\color[RGB]{0,150,255}{Port  Interface}$</strong> ：该组件的主要功能是将系统中各个组件通过端口进行连接，屏蔽不同架构硬件实现细节，简化不同组件间的连接方式并增强系统通用性；</p></li><li><p><strong>$\color[RGB]{0,150,255}{Cache模型}$</strong> ：在gem5中支持Ruby和Classic Cache两种模型。</p></li><li><p><strong>Ruby存储模型</strong>:用户可以自定义不同Cache一致性协议，并对片上网络(Network-of-Chip, NoC)进行了详细建模；</p></li><li><p><strong>Classic存储模型</strong>: 支持硬编码的层次MOESI一致性协议</p></li><li><p><strong>$\color[RGB]{0,150,255}{DRAM模型}$</strong> ：gem5中的DRAM模型是事件驱动的，支持多种市面上常见的DRAM，如DDR3、DDR4、DDR5、GDDR、HMC、HBM等。在gem5中，DRAM模型不是时钟精确的，但是可以和时钟精确的DRAM模拟器DRAMSim3结合使用，gem5中提供了和DRAMSim连接的接口；</p></li><li><p><strong>$\color[RGB]{0,150,255}{GPU模型}$</strong> ：其GPU模型基于AMD的Graphic Core Next(GCN),是一种基于计算的时钟级GPU，支持多种异构系统的计算应用程序，不支持图形应用程序。一般都使用AMD的APU模拟器(基于gem5)对GPU进行模拟；</p></li><li><p><strong>$\color[RGB]{0,150,255}{I&#x2F;O设备}$</strong> ：支持常见的磁盘控制器、PCI、Ethernet等等，是进行全系统模拟必不可少的系统组件；</p></li><li><p><strong>$\color[RGB]{0,150,255}{丰富的接口}$</strong>  ：虽然gem5模拟器功能全面、配置灵活，但是在对各个组件进行建模的过程中，考虑复杂性和实现等方面因素，并不是对所有系统组件进行详细建模，因此配置了多种其他体系结构模拟器的结构，如SST、SystemC、DRAMSys、DRAMSim。</p></li></ul><h2 id="1-2-模拟模式"><a href="#1-2-模拟模式" class="headerlink" title="1.2 模拟模式"></a>1.2 模拟模式</h2><p>gem5支持两种系统模拟方式，一种是System Call Emulation(SE)，也叫系统调用模拟模式；另一种是Full System Simuluation(FS)，也叫全系统模拟模式。</p><ul><li><p>系统调用模拟模式 System Call Emulation(SE)</p></li><li><p>全系统模拟模式 Full System Simuluation(FS)</p></li></ul><h1 id="二、Gem5安装与测试"><a href="#二、Gem5安装与测试" class="headerlink" title="二、Gem5安装与测试"></a>二、Gem5安装与测试</h1><p>官网教程<a href="https://www.gem5.org/documentation/learning_gem5/part1/building/">gem5: Building gem5</a></p><h2 id="2-1-下载gem5源码"><a href="#2-1-下载gem5源码" class="headerlink" title="2.1 下载gem5源码"></a>2.1 下载gem5源码</h2><p>通过gitee网站下载源码，速度较快</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/koverlu/gem5.git</span><br></pre></td></tr></table></figure><h2 id="2-2-安装依赖"><a href="#2-2-安装依赖" class="headerlink" title="2.2 安装依赖"></a>2.2 安装依赖</h2><p>根据官网的安装命令一键安装全部依赖，主要包括git,gcc,python,protobuf,Boost</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential git m4 scons zlib1g zlib1g-dev \</span><br><span class="line">    libprotobuf-dev protobuf-compiler libprotoc-dev libgoogle-perftools-dev \</span><br><span class="line">    python3-dev python-is-python3 libboost-all-dev pkg-config</span><br></pre></td></tr></table></figure><h2 id="2-3-设置swap交换分区"><a href="#2-3-设置swap交换分区" class="headerlink" title="2.3 设置swap交换分区"></a>2.3 设置swap交换分区</h2><p>关于设置交换分区，读者可以自行百度或者看这篇博客<a href="https://www.vpsgo.com/linux-swap.html">Linux Swap交换分区设置教程</a>。简单说，Swap分区的作用就是在内存不够的情况下，操作系统先把内存中暂时不用的数据，存到硬盘的交换空间，腾出内存来让别的程序运行。而构建gem5环境是需要很大的内存，因此很需要通过交换分区来“扩大”内存。否则会因为内存补不足而报错如下：</p><img src="/2023/10/17/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/image-20231025185902443.png" class="" title="error"><p>linux下设置swap分区的操作如下：</p><ul><li><p><strong>清空默认的Swap分区</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure></li><li><p><strong>创建分区文件并指定大小</strong></p><p>&#x2F;var&#x2F;swapfile是分区文件的位置，bs*count为文件大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dd if=/dev/zero of=/var/swapfile bs=1M count=10240</span><br></pre></td></tr></table></figure></li><li><p>格式化为Swap分区文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkswap /var/swapfile</span><br></pre></td></tr></table></figure></li><li><p>启动Swap分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo swapon /var/swapfile</span><br></pre></td></tr></table></figure></li><li><p>查看分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure><p>输出如下所示，分区创建成功，我的虚拟机设置的2GB内存+10GB分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu:~/Desktop/gem5$ free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:          1.9Gi       1.2Gi       116Mi        33Mi       567Mi       471Mi</span><br><span class="line">Swap:           9Gi       351Mi       9.7Gi</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-4-编译gem5环境"><a href="#2-4-编译gem5环境" class="headerlink" title="2.4 编译gem5环境"></a>2.4 编译gem5环境</h2><p>下面创建一个简单的x86环境试一下，首先进入gem5目录，然后通过以下命令构建环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scons build/X86/gem5.opt -j8</span><br></pre></td></tr></table></figure><p>这里使用SCons构建工具，SCons使用当前目录和每个子目录的SConstruct文件查找和编译所有gem5源代码。</p><p>命令中build&#x2F;X86&#x2F;gem5.opt是构建环境的目标文件（opt后缀代表它是一个带有调试符号的优化二进制文件，其他后缀后面会介绍）。同时SCons还支持多线程构建，加快构建速度，-j8即代表使用8核进行构建，具体使用多少核可以根据电脑配置决定。</p><p>编译时间或许会有些长（我的破电脑跑了九九八十一天终于炼出来了）</p><p>出现以下log则表示模拟环境构建成功！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Checking for C header file Python.h... yes</span><br><span class="line">Checking for C library pthread... yes</span><br><span class="line">Checking for C library dl... yes</span><br><span class="line">Checking for C library util... yes</span><br><span class="line">Checking for C library m... yes</span><br><span class="line">Checking for C library python2.7... yes</span><br><span class="line">Checking for accept(0,0,0) in C++ library None... yes</span><br><span class="line">Checking for zlibVersion() in C++ library z... yes</span><br><span class="line">Checking for GOOGLE_PROTOBUF_VERIFY_VERSION in C++ library protobuf... yes</span><br><span class="line">Checking for clock_nanosleep(0,0,NULL,NULL) in C library None... yes</span><br><span class="line">Checking for timer_create(CLOCK_MONOTONIC, NULL, NULL) in C library None... no</span><br><span class="line">Checking for timer_create(CLOCK_MONOTONIC, NULL, NULL) in C library rt... yes</span><br><span class="line">Checking for C library tcmalloc... yes</span><br><span class="line">Checking for backtrace_symbols_fd((void*)0, 0, 0) in C library None... yes</span><br><span class="line">Checking for C header file fenv.h... yes</span><br><span class="line">Checking for C header file linux/kvm.h... yes</span><br><span class="line">Checking size of struct kvm_xsave ... yes</span><br><span class="line">Checking for member exclude_host in struct perf_event_attr...yes</span><br><span class="line">Building in /local.chinook/gem5/gem5-tutorial/gem5/build/X86</span><br><span class="line">Variables file /local.chinook/gem5/gem5-tutorial/gem5/build/variables/X86 not found,</span><br><span class="line">  using defaults in /local.chinook/gem5/gem5-tutorial/gem5/build_opts/X86</span><br><span class="line">scons: done reading SConscript files.</span><br><span class="line">scons: Building targets ...</span><br><span class="line"> [ISA DESC] X86/arch/x86/isa/main.isa -&gt; generated/inc.d</span><br><span class="line"> [NEW DEPS] X86/arch/x86/generated/inc.d -&gt; x86-deps</span><br><span class="line"> [ENVIRONS] x86-deps -&gt; x86-environs</span><br><span class="line"> [     CXX] X86/sim/main.cc -&gt; .o</span><br><span class="line"> ....</span><br><span class="line"> .... &lt;lots of output&gt;</span><br><span class="line"> ....</span><br><span class="line"> [   SHCXX] nomali/lib/mali_midgard.cc -&gt; .os</span><br><span class="line"> [   SHCXX] nomali/lib/mali_t6xx.cc -&gt; .os</span><br><span class="line"> [   SHCXX] nomali/lib/mali_t7xx.cc -&gt; .os</span><br><span class="line"> [      AR]  -&gt; drampower/libdrampower.a</span><br><span class="line"> [   SHCXX] nomali/lib/addrspace.cc -&gt; .os</span><br><span class="line"> [   SHCXX] nomali/lib/mmu.cc -&gt; .os</span><br><span class="line"> [  RANLIB]  -&gt; drampower/libdrampower.a</span><br><span class="line"> [   SHCXX] nomali/lib/nomali_api.cc -&gt; .os</span><br><span class="line"> [      AR]  -&gt; nomali/libnomali.a</span><br><span class="line"> [  RANLIB]  -&gt; nomali/libnomali.a</span><br><span class="line"> [     CXX] X86/base/date.cc -&gt; .o</span><br><span class="line"> [    LINK]  -&gt; X86/gem5.opt</span><br><span class="line">scons: done building targets. &lt;这个代表环境构建成功&gt;</span><br></pre></td></tr></table></figure><h2 id="2-5-测试gem5"><a href="#2-5-测试gem5" class="headerlink" title="2.5 测试gem5"></a>2.5 测试gem5</h2><p>环境构建成功以后，就可以根据官网的指南编写python配置文件进行系统模拟了。</p><p>这里借助官网提供的默认配置文件se.py进行配置，并运行hello world程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/X86/gem5.opt ./configs/example/se.py -c ./tests/test-progs/hello/bin/x86/linux/hello</span><br></pre></td></tr></table></figure><p>出现以下输出则表示模拟正确</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">gem5 Simulator System.  https://www.gem5.org</span><br><span class="line">gem5 is copyrighted software; use the --copyright option for details.</span><br><span class="line"></span><br><span class="line">gem5 version 22.1.0.0</span><br><span class="line">gem5 compiled Oct 24 2023 01:52:12</span><br><span class="line">gem5 started Oct 24 2023 02:00:27</span><br><span class="line">gem5 executing on ubuntu, pid 28261</span><br><span class="line">command line: ./build/X86/gem5.opt ./configs/example/se.py -c ./tests/test-progs/hello/bin/x86/linux/hello</span><br><span class="line"></span><br><span class="line">warn: The `get_runtime_isa` function is deprecated. Please migrate away from using this function.</span><br><span class="line">warn: The `get_runtime_isa` function is deprecated. Please migrate away from using this function.</span><br><span class="line">Global frequency set at 1000000000000 ticks per second</span><br><span class="line">warn: No dot file generated. Please install pydot to generate the dot file and pdf.</span><br><span class="line">build/X86/mem/dram_interface.cc:690: warn: DRAM device capacity (8192 Mbytes) does not match the address range assigned (512 Mbytes)</span><br><span class="line">0: system.remote_gdb: listening for remote gdb on port 7000</span><br><span class="line">**** REAL SIMULATION ****</span><br><span class="line">build/X86/sim/simulate.cc:192: info: Entering event queue @ 0.  Starting simulation...</span><br><span class="line">Hello world!</span><br><span class="line">Exiting @ tick 5985500 because exiting with last active thread context</span><br></pre></td></tr></table></figure><h1 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h1><p><a href="https://blog.csdn.net/qq_45726331/article/details/129757815?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-129757815-blog-128272972.235%5Ev38%5Epc_relevant_sort_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-129757815-blog-128272972.235%5Ev38%5Epc_relevant_sort_base2&utm_relevant_index=5">有关gem5模拟器的资料导航</a></p><p><a href="https://www.gem5.org/">Gem5官网</a></p><p><a href="https://www.gem5.org/documentation/learning_gem5/introduction/">Gem5官方学习向导</a></p><p><a href="https://mp.weixin.qq.com/s/VoPI0jbAERg8VK98oVff4Q">gem5学习笔记一：模拟器安装与使用 (qq.com)</a></p><p><a href="https://www.terapines.com/post/767/">兆松科技研发的基于gem5的模拟器zemu</a></p><p><a href="https://blog.csdn.net/qq_43381135/article/details/104371236">GEM5教程–gem5开始之旅（一）-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_46675545/category_12120503.html">Gem5模拟器_好啊啊啊啊的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/ivy_reny/category_6666068.html">gem5_ivy_reny的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/wyj7260/category_1301132.html">gem5_wyj7260的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Gem5模拟器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gem5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown常用语法</title>
      <link href="/2023/10/07/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/10/07/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>markdown是一种被广泛使用的轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，Markdown文件的后缀名是“.md”。</p><h1 id="修改文字颜色"><a href="#修改文字颜色" class="headerlink" title="修改文字颜色"></a>修改文字颜色</h1><p>默认字体颜色自然是黑色啦，想要修改字体颜色有两种方法</p><h2 id="1-html格式"><a href="#1-html格式" class="headerlink" title="1. html格式"></a>1. html格式</h2><h3 id="（1）英文单词指示颜色"><a href="#（1）英文单词指示颜色" class="headerlink" title="（1）英文单词指示颜色"></a>（1）英文单词指示颜色</h3><p>可以通过html的各种英文颜色名来使用颜色</p><p><a href="https://www.runoob.com/html/html-colornames.html">HTML 颜色名</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color=&#x27;red&#x27;&gt;文本&lt;/font&gt;</span><br></pre></td></tr></table></figure><h3 id="（2）RGB指示颜色"><a href="#（2）RGB指示颜色" class="headerlink" title="（2）RGB指示颜色"></a>（2）RGB指示颜色</h3><p>RGB颜色格式：$#RRGGBB$，RGB均用16进制数字表示</p><p>其中两个R代表了红色光，两个G代表了绿色光，两个B代表了蓝色光</p><p>如$#FF0000$代表了255份红色光，0份绿色光和0份蓝色光。</p><p><a href="http://www.yini.org/liuyan/rgbcolor.htm">RGB颜色表</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color=#FF0000&gt;文本&lt;/font&gt;</span><br></pre></td></tr></table></figure><h3 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h3><p><font color='red'>我是红色</font></p><p><font color=#119966>我是#119966</font></p><h2 id="2-通过LaTeX内联公式"><a href="#2-通过LaTeX内联公式" class="headerlink" title="2. 通过LaTeX内联公式"></a>2. 通过LaTeX内联公式</h2><h3 id="（1）英文单词指示颜色-1"><a href="#（1）英文单词指示颜色-1" class="headerlink" title="（1）英文单词指示颜色"></a>（1）英文单词指示颜色</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$\textcolor&#123;Blue&#125;&#123;文本&#125;$</span><br><span class="line">或者简写为</span><br><span class="line">$\color&#123;Blue&#125;&#123;文本&#125;$</span><br></pre></td></tr></table></figure><p>$ \color{Blue}{文本} \mu $</p><h3 id="（2）RGB指示颜色-1"><a href="#（2）RGB指示颜色-1" class="headerlink" title="（2）RGB指示颜色"></a>（2）RGB指示颜色</h3><p>有两种通过RGB指示颜色的语法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$\textcolor[rgb]&#123;r,g,b&#125;&#123;文本&#125;$</span><br><span class="line">其中&#123;r,g,b&#125;代表red、green和blue三种颜色的组合，取值范围为[0-1]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$\textcolor[RGB]&#123;R,G,B&#125;&#123;文本&#125;$</span><br><span class="line">其中&#123;R,G,B&#125;代表red、green和blue三种颜色的组合，取值范围为[0-255]</span><br></pre></td></tr></table></figure><p>$$<br>\textcolor[RGB]{0,0,255}{文本}<br>$$</p><p>$\textcolor[RGB]{0,0,255}{文本}$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo上传图片</title>
      <link href="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
      <url>/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>Hexo网站已经搭建好了，我们可以开始愉快地写博客了！</p><h2 id="1-Typora编辑器"><a href="#1-Typora编辑器" class="headerlink" title="1. Typora编辑器"></a>1. Typora编辑器</h2><p>Typora是一种markdown语言的常用编辑器，这个软件的方便之处在于可以直接将markdown语法呈现出其效果，并且集成了许多有用的工具，是编辑markdown的不二之选。</p><p><a href="https://typora.io/">Typora官网</a></p><hr><h2 id="2-Hexo插入本地图片遇到的问题"><a href="#2-Hexo插入本地图片遇到的问题" class="headerlink" title="2. Hexo插入本地图片遇到的问题"></a>2. Hexo插入本地图片遇到的问题</h2><p>markdown的图片插入语法为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片描述](图片路径)</span><br></pre></td></tr></table></figure><p>如果使用Typora，可以直接将图片复制粘贴在想要放置的位置，十分方便</p><p>当我们将图片直接复制到Typora中时，会出现图片可以在markdown中显示，但却无法在网页中显示的问题。</p><span id="more"></span><p><img src="/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007210728956.png" alt="图一：Typora视角"></p><p><img src="/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007210809543.png" alt="图二：网页视角"></p><hr><h2 id="3-将本地图片上传至Github"><a href="#3-将本地图片上传至Github" class="headerlink" title="3. 将本地图片上传至Github"></a>3. 将本地图片上传至Github</h2><p>这其实很好理解，因为使用的图片还在你的本地，markdown语法也使用的是本地路径（如图三），而静态网页不可能在你电脑本地找图片，所以需要我们将图片也一起上传。</p><p><img src="/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007205825905.png" alt="图三：我从微信直接复制粘贴到Typora的一张图片"></p><p>上传图片等资源十分简单，只需要在Hexo的配置文件_config.yml里将post_asset_folder这一个选项配置从false更改为true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>于是每当你新建一个博客时，Hexo会自动在相同目录建立一个同名的资源文件夹，只需要将图片放到资源文件夹中，然会在markdown中通过相对路径找到图片就可以啦！</p><p>然而，每次在博客中添加图片还要手动放到资源文件夹中，然后再用语法![]()去描述图片，实在是麻烦！</p><p>好在我们可以使用Typora中的工具，依次在Typora中进入文件-&gt;偏好设置-&gt;图像，然后在插入图片时选择复制到指定路径，也就是那个在同目录下同名的资源文件夹.&#x2F;&amp;{filename}，并勾选</p><ul><li><p>对本地位置的图片应用上述规则</p></li><li><p>对网络位置的图片应用上述规则</p></li><li><p>优先使用相对路径</p></li></ul><p>建议都勾选上，至少要勾选上第一项</p><p><img src="/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007211935125.png" alt="图四"></p><img src="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007212121607.png" class="" title="图五"><p>于是，复制粘贴过来的图片就可以自动保存在资源文件夹中，并且也自动将图片路径指向了资源文件夹中的这张图片，真方便！</p><img src="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007212607249.png" class="" title="图六"><img src="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007212643086.png" class="" title="图七"><p>当我满心欢喜地将博客部署到Github上时，却发现还是和图二一样没法显示</p><p>这是问什么呢？！</p><hr><h2 id="4-Hexo显示图像语法"><a href="#4-Hexo显示图像语法" class="headerlink" title="4. Hexo显示图像语法"></a>4. Hexo显示图像语法</h2><p>翻阅Hexo<a href="https://hexo.io/zh-cn/docs/asset-folders#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%BC%95%E7%94%A8%E7%9A%84%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6">官方教程之后</a>，才发现Hexo并不可以直接将markdown显示图片的![]()语法在网页中显示图片，而必须使用以下图像标签插件来插入图片，否则图片会路径错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure><p>在markdown中编辑如下代码之后，卡比终于能在网页上出现了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img c0229a294ce2c67e2ba3d44298fcb98.jpg [我正在学习，请不要打扰] %&#125;</span><br></pre></td></tr></table></figure><img src="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231008110447546.png" class="" title="图八：使用Hexo插入图片语法——在页面中的视角"><p>然而，这种插入图片的Hexo语法不仅较为繁琐，而且在编辑的时候还不可以在编辑器里即时查看图片，这十分不方便。。</p><img src="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231008110647937.png" class="" title="图九：使用Hexo插入图片语法——在编辑器中的视角"><p>至此，我们现在有了两种都不完美的插入图片的方法</p><ol><li>使用markdown语法，好处是可以很方便地插入图片，而且可以享受实时预览图片，但坏处是根本因为路径问题无法在网页显示图片。</li><li>使用Hexo语法，可以在网页显示图片，但每插入一张图片需要手动编辑图片代码，还要手动把图片放进资源文件夹，还不能实时预览。</li></ol><p>既然如此，我们可不可以将两种方法结合起来，实现无痛插入图片的梦想？</p><p>使用Hexo的插件就可以实现！</p><hr><h2 id="5-Hexo插件实现无痛插入图片"><a href="#5-Hexo插件实现无痛插入图片" class="headerlink" title="5. Hexo插件实现无痛插入图片"></a>5. Hexo插件实现无痛插入图片</h2><p><a href="https://github.com/xcodebuild/hexo-asset-image">hexo-asset-img</a>插件可以在文章编译为html之前，自动地将markdown的图片语法自动转换成Hexo的图片语法，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![example](blogname/example.jpg) --&gt; &#123;% asset_img example.jpg example %&#125;</span><br></pre></td></tr></table></figure><p>hexo-asset-img的安装命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>ps.或者可以使用以下命令安装，安装后删除node_modules文件夹中的hexo-asset-image文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure><p>pps.有不少教程安装了 hexo-asset-image 包，但我电脑上不行，踩了一天坑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>安装好插件后，还需要在Hexo的配置文件_config.yml里加入两个配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure><p>如此，就可以在网页上看到插入的图片了！</p><img src="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231008123837571.png" class="" title="图十：博客中插入本地图片效果图"><hr><h2 id="6-全部步骤"><a href="#6-全部步骤" class="headerlink" title="6. 全部步骤"></a>6. 全部步骤</h2><ol><li><p>安装Typora编辑器</p></li><li><p>在Typora中进入文件-&gt;偏好设置-&gt;图像，在插入图片时选择复制到指定路径，也就是那个在同目录下同名的资源文件夹.&#x2F;&amp;{filename}，并勾选</p><ul><li><p>对本地位置的图片应用上述规则</p></li><li><p>对网络位置的图片应用上述规则</p></li><li><p>优先使用相对路径</p></li></ul></li><li><p>通过以下命令安装插件hexo-asset-img</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure></li><li><p>在Hexo的配置文件_config.yml里将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>这个配置项由false改为ture</p><p>并加入以下两个配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="7-最终效果"><a href="#7-最终效果" class="headerlink" title="7. 最终效果"></a>7. 最终效果</h2><p>经过以上操作，我们以后就在Hexo博客中很方便地插入本地图片啦。</p><p>只需要将图片直接复制粘贴到Typora编辑器中，图片就会自动保存在资源文件夹中，并通过正确的路径保存，同时还可以支持编辑过程中的实时预览！</p><p>ps：有对于图片如何添加题注感兴趣的小伙伴可以看这篇博客</p><p><a href="https://blog.csdn.net/Lincain/article/details/89892249">Markdown 图片居中并添加标题_markdown图片标题-CSDN博客</a></p><p>参考链接🔗：</p><ul><li><p><a href="https://moeci.com/posts/hexo-typora/">Hexo + Typora + 开发Hexo插件 解决图片路径不一致 | yiyun’s Blog (moeci.com)</a></p></li><li><p><a href="http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/">hexo中完美插入本地图片 | ETRD</a></p></li><li><p><a href="https://hexo.io/zh-cn/docs/asset-folders">资源文件夹 | Hexo</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 插入图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络配置</title>
      <link href="/2023/10/05/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/10/05/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-ifconfig（Linux）-ipconfig（windows）"><a href="#1-ifconfig（Linux）-ipconfig（windows）" class="headerlink" title="1. ifconfig（Linux） &#x2F; ipconfig（windows）"></a>1. ifconfig（Linux） &#x2F; ipconfig（windows）</h2><p>作用：用于查看网卡配置信息</p><p>如IPV4地址、IPV6地址、工作状态、网络类型</p><p>参考博客：<a href="https://blog.csdn.net/l_liangkk/article/details/114959914">查看网卡信息：ifconfig命令及详细介绍_ifconfig ether_-纸短情长的博客-CSDN博客</a> </p><p><img src="/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20231007104602303.png" alt="image-20231007104602303"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo网站搭建教程</title>
      <link href="/2023/09/26/Hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
      <url>/2023/09/26/Hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果</p><p>你也可以像我一样</p><p>拥有一篇属于你自己的Hexo框架博客网站</p><p>那我觉得</p><p>这件事情</p><p>泰酷辣！！！！！！！！！</p><p><img src="/Hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/1684920495319.png" alt="泰裤辣"></p></blockquote><hr><p>这是一个手把手教你如何搭建一个属于你自己的Hexo框架博客网站的教程</p><hr><h2 id="第一节-Hexo简介"><a href="#第一节-Hexo简介" class="headerlink" title="第一节  Hexo简介"></a>第一节  Hexo简介</h2><p>Hexo是一款基于Node.js的静态博客框架，Hexo 使用 <a href="https://link.zhihu.com/?target=http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，可以方便地生成静态网页，并托管在GitHub和Gitee上，是搭建博客的首选框架，让你实现在不用购买云服务器的情况下拥有一个属于自己的博客网站的梦想。</p><span id="more"></span><hr><h2 id="第二节-前期准备"><a href="#第二节-前期准备" class="headerlink" title="第二节 前期准备"></a>第二节 前期准备</h2><p>在安装Hexo之前，需要安装Node.js</p><p>进一步想要将Hexo部署到Github或Gitee上，还必须通过Git</p><h3 id="2-1-安装Node-js"><a href="#2-1-安装Node-js" class="headerlink" title="2.1 安装Node.js"></a>2.1 安装Node.js</h3><ul><li>Windows：</li></ul><p>在官网下载LTS版本（下载nodejs自带npm）</p><p><img src="/Hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/image-20231003193554011.png" alt="image-20231003193554011"></p><p>官网下载地址：<a href="https://nodejs.org/en">Node.js (nodejs.org)</a></p><ul><li>Linux</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><p>安装成功验证：</p><p>在命令行中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>能够顺利输出node和npm的版本号即可</p><h3 id="2-2-安装git"><a href="#2-2-安装git" class="headerlink" title="2.2 安装git"></a>2.2 安装git</h3><ul><li><p>Windows</p><p>点击Git官网下载安装包，然后按Wizard安装即可</p></li></ul><ul><li><p>Linux (Ubuntu, Debian)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git-core</span><br></pre></td></tr></table></figure></li><li><p>Linux (Fedora, Red Hat, CentOS)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install git-core</span><br></pre></td></tr></table></figure></li></ul><p>git -v查看版本，验证是否安装成功</p><h3 id="2-3-安装Hexo"><a href="#2-3-安装Hexo" class="headerlink" title="2.3 安装Hexo"></a>2.3 安装Hexo</h3><p>通过npm可以直接安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>hexo -v查看版本，验证是否安装成功</p><hr><h2 id="第三节-搭建本地静态博客"><a href="#第三节-搭建本地静态博客" class="headerlink" title="第三节 搭建本地静态博客"></a>第三节 搭建本地静态博客</h2><h3 id="3-1-初始化Hexo博客框架"><a href="#3-1-初始化Hexo博客框架" class="headerlink" title="3.1  初始化Hexo博客框架"></a>3.1  初始化Hexo博客框架</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2-进入新建的文件夹，安装一下npm"><a href="#3-2-进入新建的文件夹，安装一下npm" class="headerlink" title="3.2  进入新建的文件夹，安装一下npm"></a>3.2  进入新建的文件夹，安装一下npm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><ul><li><p>npm install 更新可能会较慢，如果失败，可以尝试配置npm代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//  配置nmp代理来提高速度，如设置淘宝镜像</span><br><span class="line">npm config set registry https://registry.npm.taobao.org </span><br><span class="line"></span><br><span class="line">// 查看配置是否成功</span><br><span class="line">npm config get registry </span><br><span class="line"></span><br><span class="line">// 成功后重新npm install安装</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li></ul><p>进入文件夹后，目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p><strong>_config.yml</strong></p><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p><p><strong>package.json</strong></p><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> 渲染引擎 已默认安装，您可以自由移除。</p><p><strong>scaffolds</strong></p><p><a href="https://hexo.io/zh-cn/docs/writing#%E6%A8%A1%E7%89%88%EF%BC%88Scaffold%EF%BC%89">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来创建文件。</p><p>Hexo 的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改 <code>scaffold/post.md</code> 中的 Front-matter 内容，那么每次新建一篇文章时都会包含这个修改。</p><p><strong>source</strong></p><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p><p><strong>themes</strong></p><p><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p><h3 id="3-3-生成静态博客网站"><a href="#3-3-生成静态博客网站" class="headerlink" title="3.3  生成静态博客网站"></a>3.3  生成静态博客网站</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><h3 id="3-4-启动服务器"><a href="#3-4-启动服务器" class="headerlink" title="3.4  启动服务器"></a>3.4  启动服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>默认情况下，访问网址为：<a href="http://localhost:4000/%EF%BC%8C%E8%AE%BF%E9%97%AE%E8%BF%99%E4%B8%AA%E6%9C%AC%E5%9C%B0%E7%BD%91%E5%9D%80%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E8%87%AA%E5%B7%B1%E7%94%9F%E6%88%90%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99">http://localhost:4000/，访问这个本地网址就可以看到自己生成的博客网站</a></p><hr><h2 id="第四节-将博客部署到Github"><a href="#第四节-将博客部署到Github" class="headerlink" title="第四节 将博客部署到Github"></a>第四节 将博客部署到Github</h2><p>生成的博客网站只能在自己电脑本地访问当然没意思，所以接下来看看如何把写好的博客部署到Github Pages上。</p><h5 id="GitHub-Pages-是什么"><a href="#GitHub-Pages-是什么" class="headerlink" title="GitHub Pages 是什么?"></a>GitHub Pages 是什么?</h5><ul><li><a href="https://link.zhihu.com/?target=https://help.github.com/en/articles/what-is-github-pages">What is GitHub Pages? - GitHub Help</a></li></ul><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。</p><h5 id="Hexo-Github-Pages-发布博客原理"><a href="#Hexo-Github-Pages-发布博客原理" class="headerlink" title="Hexo + Github Pages 发布博客原理"></a>Hexo + Github Pages 发布博客原理</h5><p>在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 上完成博文的发布。</p><p>下面看看怎么实现</p><h3 id="4-1-Github创建个人仓库"><a href="#4-1-Github创建个人仓库" class="headerlink" title="4.1 Github创建个人仓库"></a>4.1 Github创建个人仓库</h3><p>点击New repository，开始新建仓库</p><p>新仓库的名字有固定格式要求，否组无法建站</p><p>格式为：用户名 + .github.oi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repository name eg.     yourusername.github.oi</span><br></pre></td></tr></table></figure><h3 id="4-2-安装hexo上传插件"><a href="#4-2-安装hexo上传插件" class="headerlink" title="4.2 安装hexo上传插件"></a>4.2 安装hexo上传插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="4-3-修改hexo配置文件指定仓库路径"><a href="#4-3-修改hexo配置文件指定仓库路径" class="headerlink" title="4.3 修改hexo配置文件指定仓库路径"></a>4.3 修改hexo配置文件指定仓库路径</h3><p>打开文件夹中的_config.yml文件，在文件最下面的Deployment部分修改配置</p><ol><li>type项填入”git”</li><li>repo项填入你的仓库的https或者ssh地址（点开仓库主页那个绿色的Code就能看到）</li><li>branch项填入你的仓库的分支名</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line"> type: git</span><br><span class="line"> repo: 你的仓库的https或者ssh地址</span><br><span class="line"> branch: &lt;你的仓库的分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="4-4-部署博客到Github"><a href="#4-4-部署博客到Github" class="headerlink" title="4.4 部署博客到Github"></a>4.4 部署博客到Github</h3><p>部署命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>部署完成后，可以在仓库主页的Deployment</p><hr><h2 id="第五节-常用命令"><a href="#第五节-常用命令" class="headerlink" title="第五节 常用命令"></a>第五节 常用命令</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a><font color=#0080ff>new</font></h3><p>新建一个博客。执行以下命令后，会在blog&#x2F;source&#x2F;_posts&#x2F;文件夹中新建一个同名的博客文件（.md格式）。通过设置tags字段还可以给这个文章添加标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;博客名称&quot;</span><br></pre></td></tr></table></figure><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a><font color=#0080ff>clean</font></h3><p>清除缓存文件（db.json）和已经生成的静态博客文件（public文件夹下的内容）.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a><font color=#0080ff>generate</font></h3><p>生成静态博客</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">简写为:hexo g</span><br></pre></td></tr></table></figure><p><font color=#0080ff>server</font></p><p>启动本地的博客服务器。默认情况下，访问网址为：<code>http://localhost:4000/</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line">简写为:hexo s</span><br></pre></td></tr></table></figure><p><font color=#0080ff>deploy</font></p><p>在相应的网站服务器（一般是Github或Gitee）中部署博客</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">简写为:hexo d</span><br></pre></td></tr></table></figure><hr><h2 id="第六节-访问网站"><a href="#第六节-访问网站" class="headerlink" title="第六节 访问网站"></a>第六节 访问网站</h2><p>部署在Github后的默认网站url为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://你的用户名.github.io/</span><br></pre></td></tr></table></figure><p>如果能成功访问，那么恭喜！你已经成功部署了一个属于自己的博客网站！</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
