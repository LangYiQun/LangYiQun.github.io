<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言-类型转换</title>
      <link href="/2024/02/25/C%E8%AF%AD%E8%A8%80-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2024/02/25/C%E8%AF%AD%E8%A8%80-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>类型转换是指把一种类型的数据（变量、数值、表达式的结果等）转换成另一种类型的数据</p><p>由于各种数据类型在<strong>表示范围</strong>和<strong>精度</strong>上是不同的，所以可能会造成精度损失。</p><p>各种数据类型的级别如下：（由高到低）</p><table><thead><tr><th>数据类型</th><th>意义</th><th>字节大小</th><th>级别</th></tr></thead><tbody><tr><td>long double</td><td><strong>长</strong>双精度浮点</td><td>8 B</td><td>最高</td></tr><tr><td>double</td><td>双精度浮点</td><td>8 B</td><td></td></tr><tr><td>float</td><td>单精度浮点</td><td>4 B</td><td></td></tr><tr><td>unsigned long int（unsigned long）</td><td>无符号<strong>长整型</strong></td><td>4 B</td><td></td></tr><tr><td>signed long int（long）</td><td>有符号<strong>长整型</strong></td><td>4 B</td><td></td></tr><tr><td>unsigned int（unsigned）</td><td>无符号<strong>整型</strong></td><td>4 B</td><td></td></tr><tr><td>signed int（int）</td><td>有符号<strong>整型</strong></td><td>4 B</td><td></td></tr><tr><td>unsigned short int（unsigned short）</td><td>无符号<strong>短整型</strong></td><td>2 B</td><td></td></tr><tr><td>signed short（short）</td><td>有符号<strong>短整型</strong></td><td>2 B</td><td></td></tr><tr><td>unsigned char</td><td>无符号字符</td><td>1 B</td><td></td></tr><tr><td>signed char（char）</td><td>有符号字符</td><td>1 B</td><td>最低</td></tr></tbody></table><p>助记规律：</p><ul><li>浮点类型 &gt; 整型 &gt; 字符类型</li><li>长 &gt; ‘ ‘ &gt; 短</li><li>无符号 &gt; 有符号</li></ul><p>类型转换分为两类：隐式类型转换和显示类型转换</p><h1 id="隐式（自动）类型转换"><a href="#隐式（自动）类型转换" class="headerlink" title="隐式（自动）类型转换"></a>隐式（自动）类型转换</h1><p>隐式类型转换是在编译时由编译器按照一定规则自动完成的类型转换。</p><p>需要注意的是，隐式类型转换并不一定是安全的。对于不安全的类型转换，编译器一般会给出警告（长类型转换为短类型时发生的截断）。</p><p>C语言会在以下四种情况下进行隐式类型转换：</p><h3 id="（1）赋值表达式"><a href="#（1）赋值表达式" class="headerlink" title="（1）赋值表达式"></a>（1）赋值表达式</h3><p>将一种类型的数据赋值给另外一种类型的变量时就会发生隐式类型转换</p><p><strong>转换规则</strong>：在赋值运算中，赋值号两边的数据类型不同时，需要把右边表达式的类型转换为左边变量的类型。这可能会导致数据失真，或者精度降低。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f = <span class="number">100</span>; <span class="comment">// 100是int类型的数据，需要先转换为 float 类型才能赋值给变量 f</span></span><br><span class="line"><span class="type">int</span> n = f; <span class="comment">// f 是 float 类型的数据，需要先转换为 int 类型才能赋值给变量 n</span></span><br></pre></td></tr></table></figure><h3 id="（2）算术表达式"><a href="#（2）算术表达式" class="headerlink" title="（2）算术表达式"></a>（2）算术表达式</h3><p><strong>转换规则</strong>：</p><ul><li>把表达式中不同类型的数据转换成精度最高、占用内存最多的那个数据类型。</li><li>表达式中如果有char、short和enum类型的数据时，自动转换为int类型。（其实是因为运算最终还是要放到通用寄存器中）</li><li>float类型在运算时一律转换为double类型，以提高运算精度。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">short</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="type">float</span> d = <span class="number">1.1</span>;</span><br><span class="line"><span class="type">int</span> result = a + b + c + d;</span><br><span class="line"><span class="comment">// 运算时会将a, b, c, d都转换为double类型再相加</span></span><br></pre></td></tr></table></figure><h3 id="（3）函数调用中参数传递"><a href="#（3）函数调用中参数传递" class="headerlink" title="（3）函数调用中参数传递"></a>（3）函数调用中参数传递</h3><p>隐式地将实参转换为形参的类型，然后赋值给形参</p><h3 id="（4）函数返回值"><a href="#（4）函数返回值" class="headerlink" title="（4）函数返回值"></a>（4）函数返回值</h3><p>隐式地将返回表达式的结果转换为返回值类型，然后赋值给caller函数</p><h1 id="显示（强制）类型转换"><a href="#显示（强制）类型转换" class="headerlink" title="显示（强制）类型转换"></a>显示（强制）类型转换</h1><h3 id="显示类型转换语法"><a href="#显示类型转换语法" class="headerlink" title="显示类型转换语法"></a>显示类型转换语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(&lt;目标数据类型&gt;)&lt;原数据类型的数据&gt;</span><br><span class="line">e.g.</span><br><span class="line">(int) 3.14将浮点数3.14转换成整数3</span><br><span class="line">(double) 4将4转换成双精度浮点数4.0</span><br></pre></td></tr></table></figure><h1 id="数据类型的扩充与截断"><a href="#数据类型的扩充与截断" class="headerlink" title="数据类型的扩充与截断"></a>数据类型的扩充与截断</h1><h3 id="一、小数据类型-大数据类型"><a href="#一、小数据类型-大数据类型" class="headerlink" title="一、小数据类型 -&gt; 大数据类型"></a>一、小数据类型 -&gt; 大数据类型</h3><p>数据类型扩充：发生在占用内存空间小的整型变量赋值给占用内存空间大的整型变量的情况。</p><p>这种情况下，较小的数据类型的值、正负均不变，<strong>数据不失真</strong>。</p><p>转换规则：</p><ul><li>如果原数据类型为无符号整型，进行零扩展</li><li>如果原数据类型为有符号整型，进行符号扩展</li></ul><p>注意：与目标数据类型无关！！！</p><h3 id="二、大数据类型-小数据类型"><a href="#二、大数据类型-小数据类型" class="headerlink" title="二、大数据类型 -&gt; 小数据类型"></a>二、大数据类型 -&gt; 小数据类型</h3><p>数据类型截断：发生在占用内存空间小的整型变量赋值给占用内存空间大的整型变量的情况。</p><p>这种情况下，<strong>数据可能会失真</strong></p><p>转换规则：</p><ul><li>无论原数据类型有无符号，丢弃高位数据。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="type">char</span> c = <span class="number">128</span>;<span class="comment">// 存储空间：0b1000_0000 char的角度看是-1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> uc = <span class="number">128</span>;<span class="comment">// 0b1000_0000 unsigned char的角度看是128</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> ushort;</span><br><span class="line"></span><br><span class="line">ushort = (<span class="type">unsigned</span> <span class="type">short</span>)c + uc;</span><br><span class="line"><span class="comment">//翻译成汇编后，这一条语句做的事情如下</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* Step 1</span></span><br><span class="line"><span class="comment">将c从char强制类型转换为unsigned short，需要进行扩展，原数据类型是有符号的，所以进行符号扩展</span></span><br><span class="line"><span class="comment">0b 1000_0000 =&gt; 0b 1111_1111_1000_0000 unsigned short的角度看是一个很大的数</span></span><br><span class="line"><span class="comment">* Step 2</span></span><br><span class="line"><span class="comment">将c从unsigned short隐式转换为int，需要进行扩展，原数据类型是无符号的，所以进行零扩展</span></span><br><span class="line"><span class="comment">0b 1111_1111_1000_0000 =&gt; 0b 0000_0000_0000_0000_1111_1111_1000_0000</span></span><br><span class="line"><span class="comment">将uc从unsigned char隐式转换为int，需要进行扩展，原数据类型是无符号的，所以进行零扩展</span></span><br><span class="line"><span class="comment">0b1000_0000 =&gt; 0b 0000_0000_0000_0000_0000_0000_1000_0000</span></span><br><span class="line"><span class="comment">* Step 3</span></span><br><span class="line"><span class="comment">进行加法</span></span><br><span class="line"><span class="comment"> 0b 0000_0000_0000_0000_1111_1111_1000_0000</span></span><br><span class="line"><span class="comment">+0b 0000_0000_0000_0000_0000_0000_1000_0000</span></span><br><span class="line"><span class="comment">=0b 0000_0000_0000_0001_0000_0000_0000_0000</span></span><br><span class="line"><span class="comment">* Step 4</span></span><br><span class="line"><span class="comment">由于左值是unsigned short，空间为2B，所以取最低的2B，即 0b 0000_0000_0000_0000，unsigned short的角度看是0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>参考链接🔗：</p><p>一些数据类型转换的例子：<a href="https://blog.csdn.net/xiaoxiaoguailou/article/details/121692317">【C语言】数据类型的扩充和截断_以数据内部存储格式说明计算机中不同数据类型之间转换截断的概念-CSDN博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2024/02/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2024/02/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>正则表达式语法</p><p><a href="https://juejin.cn/post/6844903845227659271">正则表达式不要背 - 掘金 (juejin.cn)</a></p><p>正则表达式本质上是一个状态机（词法分析）</p><p>演示网站：<a href="https://regexper.com/">Regexper</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蜂鸟E203 Soc</title>
      <link href="/2024/02/04/%E8%9C%82%E9%B8%9FE203-Soc/"/>
      <url>/2024/02/04/%E8%9C%82%E9%B8%9FE203-Soc/</url>
      
        <content type="html"><![CDATA[<h1 id="一、项目流程"><a href="#一、项目流程" class="headerlink" title="一、项目流程"></a>一、项目流程</h1><p>下面以DDR200T的板子为例，搭建蜂鸟E203 SoC的Vivado工程</p><p>环境：Win11</p><h2 id="0-项目准备"><a href="#0-项目准备" class="headerlink" title="0. 项目准备"></a>0. 项目准备</h2><ul><li><p>下载Vivado</p></li><li><p>从<a href="https://github.com/SI-RISCV/e200_opensource">github</a>或<a href="https://gitee.com/riscv-mcu/e203_hbirdv2.git">gitee</a>下载蜂鸟E203项目源码</p></li></ul><h2 id="1-新建工程"><a href="#1-新建工程" class="headerlink" title="1. 新建工程"></a>1. 新建工程</h2><p>选择DDR200T的FPGA芯片 <code>xc7a200tfbg484-2</code></p><p><img src="/%E8%9C%82%E9%B8%9FE203-Soc/image-20240204211919180.png" alt="image-20240204211919180"></p><p>参考链接：</p><p><a href="https://blog.csdn.net/qq_43858116/article/details/123648746">Vivado 蜂鸟 e203 MCU200T&#x2F;DDR200T 逻辑综合 RISC-V 详细教程_蜂鸟e203 dc综合-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 蜂鸟处理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“一生一芯”学习笔记 2 【Verilator】</title>
      <link href="/2024/01/24/%E2%80%9C%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF%E2%80%9D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E3%80%90Verilator%E3%80%91/"/>
      <url>/2024/01/24/%E2%80%9C%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF%E2%80%9D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E3%80%90Verilator%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Verilator"><a href="#什么是Verilator" class="headerlink" title="什么是Verilator?"></a>什么是Verilator?</h1><p>Verilator 将 Verilog 和 SystemVerilog 硬件描述语言(HDL)设计转换为 C + + 或 SystemC 模型，编译后可以执行该模型。<strong>Verilator 不是传统的模拟器，而是编译器。</strong></p><p>Verilator 的主要功能就是<strong>将 Verilog 代码转化为 SystemC 或 C++ 代码</strong></p><h1 id="Verilator-具体工作原理"><a href="#Verilator-具体工作原理" class="headerlink" title="Verilator 具体工作原理"></a>Verilator 具体工作原理</h1><p><img src="/%E2%80%9C%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF%E2%80%9D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E3%80%90Verilator%E3%80%91/verilator.png" alt="verilator"></p><h1 id="Verilator-命令行参数配置"><a href="#Verilator-命令行参数配置" class="headerlink" title="Verilator 命令行参数配置"></a>Verilator 命令行参数配置</h1><ul><li><p><code>--cc</code>表示将根据HDL生成C++文件，<code>--sc</code>表示将生成System C文件</p><blockquote><p>{prefix}.cpp为模型的C文件</p><p>{prefix}.h为模型的头文件</p><p>{prefix}.mk为模型编译时的makefile</p></blockquote></li><li><p><code>--build</code>表示直接根据{prefix}.mk生成模拟时模型的库。</p><blockquote><p>{prefix}__ALL.a 包含所有必须对象的库</p><p>既可以直接buil得到库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">verilator -cc --exe --build -j top.v sim_main.cpp</span><br><span class="line">obj_dir/Vtop</span><br></pre></td></tr></table></figure><p>也可以不直接build</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">verilator -cc --exe sim_main.cpp top.v</span><br><span class="line">make -j -C obj_dir -f Vtop.mk Vtop</span><br><span class="line">./obj_dir/Vtop</span><br></pre></td></tr></table></figure></blockquote></li><li><p><code>--exe</code>表示生成模型的二进制文件，在Vtop.mk中体现</p></li><li><p><code>--main</code>表示将会自动生成一个含main函数的cpp文件，即wrapper file，这个文件将会读取命令行参数、实例化模型，并驱动模拟</p><blockquote><p>{prefix}__main.cpp</p></blockquote></li><li><p>前缀{prefix}可以通过<code>--prefix</code>指定。</p></li><li><p>生成的所有文件都在目标文件夹中，可以由<code>--Mdir</code>指定，默认为“obj_dir”</p></li><li><p><code>--top-module</code>or <code>--top</code>指定顶层模块</p></li><li><p><code>-j &#123;&#125;</code>指定编译线程数</p></li><li><p><code>-o &#123;file abspath&#125;</code>指定生成目标文件的路径和名称</p></li></ul><p>命令行参数：<a href="https://verilator.org/guide/latest/exe_verilator.html#cmdoption-top-module">verilator Arguments — Verilator Devel 5.021 documentation</a></p><p>生成的文件：<a href="https://verilator.org/guide/latest/files.html#files-read-written">Files — Verilator Devel 5.021 documentation</a></p><p><a href="https://verilator.org/guide/latest/overview.html">Overview — Verilator Devel 5.021 documentation</a></p><p><a href="https://soc.ustc.edu.cn/CECS/lab2/verilator/">Verilator 使用指南 - USTC CECS 2023</a></p><h1 id="wrapper-驱动"><a href="#wrapper-驱动" class="headerlink" title="wrapper 驱动"></a>wrapper 驱动</h1><p>需要使用&lt;verilated.h&gt;中的VerilatedContext类构建一个环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;verilated.h&gt;</span><br><span class="line"></span><br><span class="line">//创建仿真环境</span><br><span class="line">VerilatedContext* contextp = new VerilatedContext;</span><br><span class="line"></span><br><span class="line">//接收命令行参数</span><br><span class="line">contextp-&gt;commandArgs(argc, argv);</span><br><span class="line"></span><br><span class="line">//推动仿真时间</span><br><span class="line">contextp-&gt;timeInc(n)</span><br></pre></td></tr></table></figure><h1 id="Verilator-GTKwave-查看仿真波形"><a href="#Verilator-GTKwave-查看仿真波形" class="headerlink" title="Verilator + GTKwave 查看仿真波形"></a>Verilator + GTKwave 查看仿真波形</h1><p>在 C++ wrapper中，控制产生波形</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;verilated_vcd_c.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    VerilatedVcdC* tfp = <span class="keyword">new</span> VerilatedVcdC; <span class="comment">//初始化VCD对象指针</span></span><br><span class="line">  contextp-&gt;<span class="built_in">traceEverOn</span>(<span class="literal">true</span>); <span class="comment">//打开追踪功能</span></span><br><span class="line">  top-&gt;<span class="built_in">trace</span>(tfp, <span class="number">0</span>); <span class="comment">//</span></span><br><span class="line">  tfp-&gt;<span class="built_in">open</span>(<span class="string">&quot;wave.vcd&quot;</span>); <span class="comment">//设置输出的文件wave.vcd</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>()&#123;</span><br><span class="line">        ...</span><br><span class="line">        tfp-&gt;<span class="built_in">dump</span>(contextp-&gt;<span class="built_in">time</span>()); <span class="comment">//dump wave</span></span><br><span class="line">    contextp-&gt;<span class="built_in">timeInc</span>(<span class="number">1</span>); <span class="comment">//推动仿真时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tfp-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> tfp;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在verilator的编译命令行中开启<code>--trace</code>选项，然后运行程序，会生成wave.vcd波形文件</p><p>用GTKwave打开波形文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gtkwave wave.vcd</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/%E2%80%9C%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF%E2%80%9D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E3%80%90Verilator%E3%80%91/image-20240124094646036.png" alt="image-20240124094646036"></p><p>GTKwave波形 <a href="https://gtkwave.sourceforge.net/">GTKWave (sourceforge.net)</a></p><p><a href="https://blog.csdn.net/qq_27148893/article/details/124621380">Verilator+gtkwave-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> “一生一芯” </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“一生一芯”学习笔记 1 【搭建环境】</title>
      <link href="/2024/01/24/%E2%80%9C%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF%E2%80%9D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E3%80%90%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E3%80%91/"/>
      <url>/2024/01/24/%E2%80%9C%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF%E2%80%9D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E3%80%90%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>有时间再补吧</p>]]></content>
      
      
      
        <tags>
            
            <tag> “一生一芯” </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile</title>
      <link href="/2024/01/16/Makefile/"/>
      <url>/2024/01/16/Makefile/</url>
      
        <content type="html"><![CDATA[<p><a href="https://soc.ustc.edu.cn/CECS/lab1/makefile/">Makefile 常用语法 - USTC CECS 2023</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git学习</title>
      <link href="/2024/01/11/Git%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/01/11/Git%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="103-x69-116-64-x67-x69-x74-x68-117-98-x2e-x63-x6f-x6d-Permission-denied-publickey"><a href="#103-x69-116-64-x67-x69-x74-x68-117-98-x2e-x63-x6f-x6d-Permission-denied-publickey" class="headerlink" title="&#103;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;: Permission denied (publickey)."></a><a href="mailto:&#103;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;">&#103;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;</a>: Permission denied (publickey).</h2><p>需要在本机生成公钥，并公钥添加到github网页上</p><p><a href="https://geek-docs.com/git/git-questions/549_git_git_permission_denied_publickey.html">Git 权限被拒绝（publickey）|极客教程 (geek-docs.com)</a></p><p><a href="https://missing-semester-cn.github.io/2020/version-control/">版本控制(Git) · the missing semester of your cs education (missing-semester-cn.github.io)</a></p><p><a href="https://git-scm.com/book/en/v2">https://git-scm.com/book/en/v2</a></p><p><a href="https://git-scm.com/book/zh/v2">Git - Book (git-scm.com)</a></p><p>git游戏 <a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>资源大地图</title>
      <link href="/2024/01/11/%E8%B5%84%E6%BA%90%E5%A4%A7%E5%9C%B0%E5%9B%BE/"/>
      <url>/2024/01/11/%E8%B5%84%E6%BA%90%E5%A4%A7%E5%9C%B0%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="课程资源"><a href="#课程资源" class="headerlink" title="课程资源"></a>课程资源</h1><h2 id="MIT-Linux工具使用系列课程"><a href="#MIT-Linux工具使用系列课程" class="headerlink" title="MIT Linux工具使用系列课程"></a>MIT Linux工具使用系列课程</h2><p>MIT的Linux工具使用系列课程: <a href="https://missing-semester-cn.github.io/">The Missing Semester of Your CS Education</a>中文版. 通过学习这些课程, 你将会了解到如何使用Linux中的工具来方便地完成各种任务, 这将大大提升你的工作效率.</p><p>B站视频：<a href="https://www.bilibili.com/video/BV1x7411H7wa">https://www.bilibili.com/video/BV1x7411H7wa</a></p><h2 id="中科院”一生一芯“计划"><a href="#中科院”一生一芯“计划" class="headerlink" title="中科院”一生一芯“计划"></a>中科院”一生一芯“计划</h2><p>官网：<a href="https://ysyx.oscc.cc/">一生一芯 (oscc.cc)</a></p><p>B站视频：</p>]]></content>
      
      
      
        <tags>
            
            <tag> Links </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>体系结构基础知识</title>
      <link href="/2023/12/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/12/20/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是指令集？"><a href="#一、什么是指令集？" class="headerlink" title="一、什么是指令集？"></a>一、什么是指令集？</h1><p>业界泰斗、ACM 和 IEEE 两院院士、2017 年图灵奖得主、 RISC-V 基金会的董事会副主席 David Patterson 给了非常通俗易懂的定义：<strong>软件通过一个专业词汇上称为指令集的东西和硬件讲话</strong>。换句话说，<strong>指令集是软硬件之间沟通的桥梁。</strong></p><p>而<strong>指令集</strong>与<strong>ISA</strong>和<strong>架构</strong>是同一个概念，实现一个指令集的CPU叫<strong>微架构</strong>。</p><p>例如：ARMv，这是一个指令集，也是一个架构版本。ARM 的 Cortex-A72 处理器，就是一个实现了ARMv8 指令集的具体 CPU，是一个微架构。ARM 的 Cortex-A72 是一个支持 ARMv8 指令集的 CPU IP，就是一堆 RTL 代码。瑞芯微的 RK3399 芯片就是一个集成了2个 Cortex- A72 之后的芯片，是一个物理体，这个芯片支持 ARMv8 指令集。凡是支持 ARMv8 的软件，都可以在 RK3399 上运行。</p><p>指令集</p>]]></content>
      
      
      
        <tags>
            
            <tag> 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（九）————配置文件</title>
      <link href="/2023/12/14/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
      <url>/2023/12/14/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="fs-py配置文件"><a href="#fs-py配置文件" class="headerlink" title="fs.py配置文件"></a>fs.py配置文件</h1><p>fs.py文件是可以运行FS模式模拟的通用配置文件，但由于其编写的时间很早，部分指令集的新功能没有更新。</p><p>如不支持RISCV</p><h2 id="一、导入库"><a href="#一、导入库" class="headerlink" title="一、导入库"></a>一、导入库</h2><p>fs.py自己的路径<code>configs/example/fs.py</code>是知道的，它用addToPath(“…&#x2F;…&#x2F;”)，使得可以直接导入<code>confis/</code>中的模块，然后引用了configs里自带的一些python文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [fs.py]</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 由于在之前的配置文件中将src/python/文件夹也加入了库搜索路径，所以可以import m5</span></span><br><span class="line"><span class="keyword">import</span> m5</span><br><span class="line"><span class="keyword">from</span> m5.defines <span class="keyword">import</span> buildEnv</span><br><span class="line"><span class="keyword">from</span> m5.objects <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> m5.util <span class="keyword">import</span> addToPath, fatal, warn</span><br><span class="line"><span class="keyword">from</span> m5.util.fdthelper <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">addToPath(<span class="string">&#x27;../&#x27;</span>)</span><br><span class="line"><span class="comment"># confis/ 中含有ruby/和common/</span></span><br><span class="line"><span class="keyword">from</span> ruby <span class="keyword">import</span> Ruby</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> common.FSConfig <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> common.SysPaths <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> common.Benchmarks <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> common <span class="keyword">import</span> Simulation</span><br><span class="line"><span class="keyword">from</span> common <span class="keyword">import</span> CacheConfig</span><br><span class="line"><span class="keyword">from</span> common <span class="keyword">import</span> CpuConfig</span><br><span class="line"><span class="keyword">from</span> common <span class="keyword">import</span> MemConfig</span><br><span class="line"><span class="keyword">from</span> common <span class="keyword">import</span> ObjectList</span><br><span class="line"><span class="keyword">from</span> common.Caches <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> common <span class="keyword">import</span> Options</span><br></pre></td></tr></table></figure><h2 id="二、命令行参数"><a href="#二、命令行参数" class="headerlink" title="二、命令行参数"></a>二、命令行参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [fs.py]</span></span><br><span class="line"><span class="comment"># Add args</span></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">Options.addCommonOptions(parser)   <span class="comment"># 添加常用参数。如CPU类型、CPU时钟频率等</span></span><br><span class="line">Options.addFSOptions(parser)       <span class="comment"># 添加FS模拟参数。如使用的内核、镜像文件等</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the ruby specific and protocol specific args</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;--ruby&#x27;</span> <span class="keyword">in</span> sys.argv:</span><br><span class="line">    Ruby.define_options(parser)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure><p>第2行通过标准库argparse的ArgumentParser()方法初始化了parser类</p><p>第3、4行通过configs&#x2F;common&#x2F;Options.py模块中的两个方法中添加相应命令行选项。</p><p>第7行检查是否配置了ruby。如果配置了，则在第8行，通过confis&#x2F;ruby&#x2F;Ruby.py模块中的define_options()方法配置ruby相关的参数，其中，network相关参数也会配置。</p><p>最后，通过标准库argparse的解析函数对parser进行参数解析，得到了args，所有参数都存储在args中。</p><p>args 是一个包含所有命令行参数值的命名空间对象。每个命令行参数都成为这个对象的一个属性，可以通过 args.参数名 的形式访问。<br>在 gem5 的上下文中，这意味着 args 包含了模拟器运行所需的所有配置信息，如是否启用 Ruby 模拟、文件系统的配置等。</p><p>以上代码定义了argparse解析器并添加了命令行参数。然后它解析了这些参数，并基于这些参数来设置CPU类和内存类。</p><h2 id="三、确定CPU和Memory类型"><a href="#三、确定CPU和Memory类型" class="headerlink" title="三、确定CPU和Memory类型"></a>三、确定CPU和Memory类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># system under test can be any CPU</span></span><br><span class="line">(TestCPUClass, test_mem_mode, FutureClass) = Simulation.setCPUClass(args)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Match the memories with the CPUs, based on the options for the test system</span></span><br><span class="line">TestMemClass = Simulation.setMemClass(args)</span><br></pre></td></tr></table></figure><h2 id="四、配置benchmark"><a href="#四、配置benchmark" class="headerlink" title="四、配置benchmark"></a>四、配置benchmark</h2><p>Benchmarks为一个字典，在configs&#x2F;common&#x2F;Benchmark.py中定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.benchmark:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bm = Benchmarks[args.benchmark]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error benchmark %s has not been defined.&quot;</span> % args.benchmark)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Valid benchmarks are: %s&quot;</span> % DefinedBenchmarks)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> args.dual:</span><br><span class="line">        bm = [SysConfig(disks=args.disk_image, rootdev=args.root_device,</span><br><span class="line">                        mem=args.mem_size, os_type=args.os_type),</span><br><span class="line">              SysConfig(disks=args.disk_image, rootdev=args.root_device,</span><br><span class="line">                        mem=args.mem_size, os_type=args.os_type)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        bm = [SysConfig(disks=args.disk_image, rootdev=args.root_device,</span><br><span class="line">                        mem=args.mem_size, os_type=args.os_type)]</span><br></pre></td></tr></table></figure><h2 id="五、root"><a href="#五、root" class="headerlink" title="五、root"></a>五、root</h2><p>在gem5中，root是整个模拟环境的最顶层容器，它通常包含了模拟的计算机系统（如处理器、内存、总线等）以及与这些组件连接的所有设备和系统的配置。这样的结构设计允许gem5能够方便地访问和管理模拟的不同部分。</p><p>本质上，fs.py只是运行了最后一行的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [fs.py]</span></span><br><span class="line">Simulation.run(args, root, test_sys, FutureClass)</span><br></pre></td></tr></table></figure><p>其中，args是所有参数，root是仿真的硬件，test_sys是模拟的系统</p><p>如果模拟的是一个<strong>双系统</strong>（dual系统），那么root会通过调用makeDualRoot()函数被创建，这意味着会有两个系统（test_sys和drive_sys）并行运行在模拟中。<br>如果启用了<strong>分布式模拟</strong>（dist模式），则通过调用makeDistRoot()函数创建root，此时root代表的系统会作为分布式模拟中的一个节点。<br>如果模拟的是<strong>单个系统</strong>，那么root会简单地通过Root(full_system&#x3D;True, system&#x3D;test_sys)创建，其中test_sys是通过build_test_system()函数构建的测试系统</p><p>之后，它构建测试系统，可能还会构建驱动系统，最后创建一个root根对象来启动模拟。</p><p>在gem5中，root是整个模拟环境的最顶层容器，它通常包含了模拟的计算机系统（如处理器、内存、总线等）以及与这些组件连接的所有设备和系统的配置。</p><h2 id="六、构建系统"><a href="#六、构建系统" class="headerlink" title="六、构建系统"></a>六、构建系统</h2><p>构造系统是配置文件的主要工作，因此通过函数单独实现。</p><p>通过代码中的build_test_system()函数构造测试系统；如果双系统，还会通过build_drive_system()构建驱动系统。</p><p>并分别通过Root()、makeDualRoot()、makeDistRoot()构建单系统、双系统、分布式系统的root。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">np = args.num_cpus</span><br><span class="line"></span><br><span class="line">test_sys = build_test_system(np)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(bm) == <span class="number">2</span>:</span><br><span class="line">    drive_sys = build_drive_system(np)</span><br><span class="line">    root = makeDualRoot(<span class="literal">True</span>, test_sys, drive_sys, args.etherdump)</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">len</span>(bm) == <span class="number">1</span> <span class="keyword">and</span> args.dist:</span><br><span class="line">    <span class="comment"># This system is part of a dist-gem5 simulation</span></span><br><span class="line">    root = makeDistRoot(test_sys,</span><br><span class="line">                        args.dist_rank,</span><br><span class="line">                        args.dist_size,</span><br><span class="line">                        args.dist_server_name,</span><br><span class="line">                        args.dist_server_port,</span><br><span class="line">                        args.dist_sync_repeat,</span><br><span class="line">                        args.dist_sync_start,</span><br><span class="line">                        args.ethernet_linkspeed,</span><br><span class="line">                        args.ethernet_linkdelay,</span><br><span class="line">                        args.etherdump);</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">len</span>(bm) == <span class="number">1</span>:</span><br><span class="line">    root = Root(full_system=<span class="literal">True</span>, system=test_sys)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error I don&#x27;t know how to create more than 2 systems.&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="构造测试系统"><a href="#构造测试系统" class="headerlink" title="构造测试系统"></a>构造测试系统</h3><p>不同的ISA不同，以X86为例：</p><p>第3行~第30行：首先通过makeLinuxX86System，创建一个基础的test_sys。</p><p>第32行~第62行：然后再指定一些细节，如cpu等。</p><p>第64行~第134行：如果使用ruby，test_sys有更多细节。</p><p>第136行~第148行：如果使用KVM加速，则设置KVM。</p><p>最后返回测试系统test_sys。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build_test_system</span>(<span class="params">np</span>):</span><br><span class="line">    cmdline = cmd_line_template()</span><br><span class="line">    <span class="keyword">if</span> buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] == <span class="string">&quot;mips&quot;</span>:</span><br><span class="line">        test_sys = makeLinuxMipsSystem(test_mem_mode, bm[<span class="number">0</span>], cmdline=cmdline)</span><br><span class="line">    <span class="keyword">elif</span> buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] == <span class="string">&quot;sparc&quot;</span>:</span><br><span class="line">        test_sys = makeSparcSystem(test_mem_mode, bm[<span class="number">0</span>], cmdline=cmdline)</span><br><span class="line">    <span class="keyword">elif</span> buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] == <span class="string">&quot;riscv&quot;</span>:</span><br><span class="line">        test_sys = makeBareMetalRiscvSystem(test_mem_mode, bm[<span class="number">0</span>],</span><br><span class="line">                                            cmdline=cmdline)</span><br><span class="line">    <span class="keyword">elif</span> buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] == <span class="string">&quot;x86&quot;</span>:</span><br><span class="line">        test_sys = makeLinuxX86System(test_mem_mode, np, bm[<span class="number">0</span>], args.ruby,</span><br><span class="line">                                      cmdline=cmdline)</span><br><span class="line">    <span class="keyword">elif</span> buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] == <span class="string">&quot;arm&quot;</span>:</span><br><span class="line">        test_sys = makeArmSystem(</span><br><span class="line">            test_mem_mode,</span><br><span class="line">            args.machine_type,</span><br><span class="line">            np,</span><br><span class="line">            bm[<span class="number">0</span>],</span><br><span class="line">            args.dtb_filename,</span><br><span class="line">            bare_metal=args.bare_metal,</span><br><span class="line">            cmdline=cmdline,</span><br><span class="line">            external_memory=args.external_memory_system,</span><br><span class="line">            ruby=args.ruby,</span><br><span class="line">            vio_9p=args.vio_9p,</span><br><span class="line">            bootloader=args.bootloader,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> args.enable_context_switch_stats_dump:</span><br><span class="line">            test_sys.enable_context_switch_stats_dump = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fatal(<span class="string">&quot;Incapable of building %s full system!&quot;</span>, buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set the cache line size for the entire system</span></span><br><span class="line">    test_sys.cache_line_size = args.cacheline_size</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a top-level voltage domain</span></span><br><span class="line">    test_sys.voltage_domain = VoltageDomain(voltage = args.sys_voltage)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a source clock for the system and set the clock period</span></span><br><span class="line">    test_sys.clk_domain = SrcClockDomain(clock =  args.sys_clock,</span><br><span class="line">            voltage_domain = test_sys.voltage_domain)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a CPU voltage domain</span></span><br><span class="line">    test_sys.cpu_voltage_domain = VoltageDomain()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a source clock for the CPUs and set the clock period</span></span><br><span class="line">    test_sys.cpu_clk_domain = SrcClockDomain(clock = args.cpu_clock,</span><br><span class="line">                                             voltage_domain =</span><br><span class="line">                                             test_sys.cpu_voltage_domain)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] == <span class="string">&#x27;riscv&#x27;</span>:</span><br><span class="line">        test_sys.workload.bootloader = args.kernel</span><br><span class="line">    <span class="keyword">elif</span> args.kernel <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        test_sys.workload.object_file = binary(args.kernel)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.script <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        test_sys.readfile = args.script</span><br><span class="line"></span><br><span class="line">    test_sys.init_param = args.init_param</span><br><span class="line"></span><br><span class="line">    <span class="comment"># For now, assign all the CPUs to the same clock domain</span></span><br><span class="line">    test_sys.cpu = [TestCPUClass(clk_domain=test_sys.cpu_clk_domain, cpu_id=i)</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(np)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.ruby:</span><br><span class="line">        bootmem = <span class="built_in">getattr</span>(test_sys, <span class="string">&#x27;_bootmem&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">        Ruby.create_system(args, <span class="literal">True</span>, test_sys, test_sys.iobus,</span><br><span class="line">                           test_sys._dma_ports, bootmem)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Create a seperate clock domain for Ruby</span></span><br><span class="line">        test_sys.ruby.clk_domain = SrcClockDomain(clock = args.ruby_clock,</span><br><span class="line">                                        voltage_domain = test_sys.voltage_domain)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Connect the ruby io port to the PIO bus,</span></span><br><span class="line">        <span class="comment"># assuming that there is just one such port.</span></span><br><span class="line">        test_sys.iobus.mem_side_ports = test_sys.ruby._io_port.in_ports</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i, cpu) <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_sys.cpu):</span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="comment"># Tie the cpu ports to the correct ruby system ports</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            cpu.clk_domain = test_sys.cpu_clk_domain</span><br><span class="line">            cpu.createThreads()</span><br><span class="line">            cpu.createInterruptController()</span><br><span class="line"></span><br><span class="line">            test_sys.ruby._cpu_ports[i].connectCpuPorts(cpu)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> args.caches <span class="keyword">or</span> args.l2cache:</span><br><span class="line">            <span class="comment"># By default the IOCache runs at the system clock</span></span><br><span class="line">            test_sys.iocache = IOCache(addr_ranges = test_sys.mem_ranges)</span><br><span class="line">            test_sys.iocache.cpu_side = test_sys.iobus.mem_side_ports</span><br><span class="line">            test_sys.iocache.mem_side = test_sys.membus.cpu_side_ports</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> args.external_memory_system:</span><br><span class="line">            test_sys.iobridge = Bridge(delay=<span class="string">&#x27;50ns&#x27;</span>, ranges = test_sys.mem_ranges)</span><br><span class="line">            test_sys.iobridge.cpu_side_port = test_sys.iobus.mem_side_ports</span><br><span class="line">            test_sys.iobridge.mem_side_port = test_sys.membus.cpu_side_ports</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Sanity check</span></span><br><span class="line">        <span class="keyword">if</span> args.simpoint_profile:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ObjectList.is_noncaching_cpu(TestCPUClass):</span><br><span class="line">                fatal(<span class="string">&quot;SimPoint generation should be done with atomic cpu&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> np &gt; <span class="number">1</span>:</span><br><span class="line">                fatal(<span class="string">&quot;SimPoint generation not supported with more than one CPUs&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(np):</span><br><span class="line">            <span class="keyword">if</span> args.simpoint_profile:</span><br><span class="line">                test_sys.cpu[i].addSimPointProbe(args.simpoint_interval)</span><br><span class="line">            <span class="keyword">if</span> args.checker:</span><br><span class="line">                test_sys.cpu[i].addCheckerCpu()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ObjectList.is_kvm_cpu(TestCPUClass):</span><br><span class="line">                <span class="keyword">if</span> args.bp_type:</span><br><span class="line">                    bpClass = ObjectList.bp_list.get(args.bp_type)</span><br><span class="line">                    test_sys.cpu[i].branchPred = bpClass()</span><br><span class="line">                <span class="keyword">if</span> args.indirect_bp_type:</span><br><span class="line">                    IndirectBPClass = ObjectList.indirect_bp_list.get(</span><br><span class="line">                        args.indirect_bp_type)</span><br><span class="line">                    test_sys.cpu[i].branchPred.indirectBranchPred = \</span><br><span class="line">                        IndirectBPClass()</span><br><span class="line">            test_sys.cpu[i].createThreads()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># If elastic tracing is enabled when not restoring from checkpoint and</span></span><br><span class="line">        <span class="comment"># when not fast forwarding using the atomic cpu, then check that the</span></span><br><span class="line">        <span class="comment"># TestCPUClass is DerivO3CPU or inherits from DerivO3CPU. If the check</span></span><br><span class="line">        <span class="comment"># passes then attach the elastic trace probe.</span></span><br><span class="line">        <span class="comment"># If restoring from checkpoint or fast forwarding, the code that does this for</span></span><br><span class="line">        <span class="comment"># FutureCPUClass is in the Simulation module. If the check passes then the</span></span><br><span class="line">        <span class="comment"># elastic trace probe is attached to the switch CPUs.</span></span><br><span class="line">        <span class="keyword">if</span> args.elastic_trace_en <span class="keyword">and</span> args.checkpoint_restore == <span class="literal">None</span> <span class="keyword">and</span> \</span><br><span class="line">            <span class="keyword">not</span> args.fast_forward:</span><br><span class="line">            CpuConfig.config_etrace(TestCPUClass, test_sys.cpu, args)</span><br><span class="line"></span><br><span class="line">        CacheConfig.config_cache(args, test_sys)</span><br><span class="line"></span><br><span class="line">        MemConfig.config_mem(args, test_sys)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ObjectList.is_kvm_cpu(TestCPUClass) <span class="keyword">or</span> \</span><br><span class="line">        ObjectList.is_kvm_cpu(FutureClass):</span><br><span class="line">        <span class="comment"># Assign KVM CPUs to their own event queues / threads. This</span></span><br><span class="line">        <span class="comment"># has to be done after creating caches and other child objects</span></span><br><span class="line">        <span class="comment"># since these mustn&#x27;t inherit the CPU event queue.</span></span><br><span class="line">        <span class="keyword">for</span> i,cpu <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_sys.cpu):</span><br><span class="line">            <span class="comment"># Child objects usually inherit the parent&#x27;s event</span></span><br><span class="line">            <span class="comment"># queue. Override that and use the same event queue for</span></span><br><span class="line">            <span class="comment"># all devices.</span></span><br><span class="line">            <span class="keyword">for</span> obj <span class="keyword">in</span> cpu.descendants():</span><br><span class="line">                obj.eventq_index = <span class="number">0</span></span><br><span class="line">            cpu.eventq_index = i + <span class="number">1</span></span><br><span class="line">        test_sys.kvm_vm = KvmVM()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> test_sys</span><br></pre></td></tr></table></figure><h3 id="构造驱动系统"><a href="#构造驱动系统" class="headerlink" title="构造驱动系统"></a>构造驱动系统</h3><p>与测试系统的构造大致一致，先构建基本系统，然后再指定一些细节。</p><p>最后返回驱动系统drive_sys</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build_drive_system</span>(<span class="params">np</span>):</span><br><span class="line">    <span class="comment"># driver system CPU is always simple, so is the memory</span></span><br><span class="line">    <span class="comment"># Note this is an assignment of a class, not an instance.</span></span><br><span class="line">    DriveCPUClass = AtomicSimpleCPU</span><br><span class="line">    drive_mem_mode = <span class="string">&#x27;atomic&#x27;</span></span><br><span class="line">    DriveMemClass = SimpleMemory</span><br><span class="line"></span><br><span class="line">    cmdline = cmd_line_template()</span><br><span class="line">    <span class="keyword">if</span> buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] == <span class="string">&#x27;mips&#x27;</span>:</span><br><span class="line">        drive_sys = makeLinuxMipsSystem(drive_mem_mode, bm[<span class="number">1</span>], cmdline=cmdline)</span><br><span class="line">    <span class="keyword">elif</span> buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] == <span class="string">&#x27;sparc&#x27;</span>:</span><br><span class="line">        drive_sys = makeSparcSystem(drive_mem_mode, bm[<span class="number">1</span>], cmdline=cmdline)</span><br><span class="line">    <span class="keyword">elif</span> buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] == <span class="string">&#x27;x86&#x27;</span>:</span><br><span class="line">        drive_sys = makeLinuxX86System(drive_mem_mode, np, bm[<span class="number">1</span>],</span><br><span class="line">                                       cmdline=cmdline)</span><br><span class="line">    <span class="keyword">elif</span> buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] == <span class="string">&#x27;arm&#x27;</span>:</span><br><span class="line">        drive_sys = makeArmSystem(drive_mem_mode, args.machine_type, np,</span><br><span class="line">                                  bm[<span class="number">1</span>], args.dtb_filename, cmdline=cmdline)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a top-level voltage domain</span></span><br><span class="line">    drive_sys.voltage_domain = VoltageDomain(voltage = args.sys_voltage)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a source clock for the system and set the clock period</span></span><br><span class="line">    drive_sys.clk_domain = SrcClockDomain(clock =  args.sys_clock,</span><br><span class="line">            voltage_domain = drive_sys.voltage_domain)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a CPU voltage domain</span></span><br><span class="line">    drive_sys.cpu_voltage_domain = VoltageDomain()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a source clock for the CPUs and set the clock period</span></span><br><span class="line">    drive_sys.cpu_clk_domain = SrcClockDomain(clock = args.cpu_clock,</span><br><span class="line">                                              voltage_domain =</span><br><span class="line">                                              drive_sys.cpu_voltage_domain)</span><br><span class="line"></span><br><span class="line">    drive_sys.cpu = DriveCPUClass(clk_domain=drive_sys.cpu_clk_domain,</span><br><span class="line">                                  cpu_id=<span class="number">0</span>)</span><br><span class="line">    drive_sys.cpu.createThreads()</span><br><span class="line">    drive_sys.cpu.createInterruptController()</span><br><span class="line">    drive_sys.cpu.connectBus(drive_sys.membus)</span><br><span class="line">    <span class="keyword">if</span> args.kernel <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        drive_sys.workload.object_file = binary(args.kernel)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ObjectList.is_kvm_cpu(DriveCPUClass):</span><br><span class="line">        drive_sys.kvm_vm = KvmVM()</span><br><span class="line"></span><br><span class="line">    drive_sys.iobridge = Bridge(delay=<span class="string">&#x27;50ns&#x27;</span>,</span><br><span class="line">                                ranges = drive_sys.mem_ranges)</span><br><span class="line">    drive_sys.iobridge.cpu_side_port = drive_sys.iobus.mem_side_ports</span><br><span class="line">    drive_sys.iobridge.mem_side_port = drive_sys.membus.cpu_side_ports</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create the appropriate memory controllers and connect them to the</span></span><br><span class="line">    <span class="comment"># memory bus</span></span><br><span class="line">    drive_sys.mem_ctrls = [DriveMemClass(<span class="built_in">range</span> = r)</span><br><span class="line">                           <span class="keyword">for</span> r <span class="keyword">in</span> drive_sys.mem_ranges]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(drive_sys.mem_ctrls)):</span><br><span class="line">        drive_sys.mem_ctrls[i].port = drive_sys.membus.mem_side_ports</span><br><span class="line"></span><br><span class="line">    drive_sys.init_param = args.init_param</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> drive_sys</span><br></pre></td></tr></table></figure><h1 id="se-py配置文件"><a href="#se-py配置文件" class="headerlink" title="se.py配置文件"></a>se.py配置文件</h1><h1 id="fs-linux-py配置文件"><a href="#fs-linux-py配置文件" class="headerlink" title="fs_linux.py配置文件"></a>fs_linux.py配置文件</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Garnet</title>
      <link href="/2023/12/11/Garnet/"/>
      <url>/2023/12/11/Garnet/</url>
      
        <content type="html"><![CDATA[<p>GEM5 Garnet官方教程：乔治亚理工课程<a href="https://tusharkrishna.ece.gatech.edu/teaching/icn_s17/">https://tusharkrishna.ece.gatech.edu/teaching/icn_s17/</a></p><p>配套实验网站<a href="https://tusharkrishna.ece.gatech.edu/teaching/garnet_gt/">https://tusharkrishna.ece.gatech.edu/teaching/garnet_gt/</a></p><p><a href="https://synergy.ece.gatech.edu/tools/garnet/">https://synergy.ece.gatech.edu/tools/garnet/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文献阅读</title>
      <link href="/2023/11/30/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
      <url>/2023/11/30/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="拉丁文缩写"><a href="#拉丁文缩写" class="headerlink" title="拉丁文缩写"></a>拉丁文缩写</h1><h2 id="i-e-也就是说"><a href="#i-e-也就是说" class="headerlink" title="i.e. 也就是说"></a>i.e. 也就是说</h2><p><strong>id est</strong>（“that is” , “in other words”。进一步解释用，意为：也就是）的缩写。目的是用来进一步解释前面所说的观点（不像后文的e.g.那样引入实例来形象化），意思是“那就是说，换句话说”。</p><blockquote><p>例句1：Each of these items are actionable, <strong>i.e</strong>. you can actually do them.</p></blockquote><h2 id="e-g-例如"><a href="#e-g-例如" class="headerlink" title="e.g. 例如"></a>e.g. 例如</h2><p><strong>e.g.<strong>是</strong>exempli gratia</strong>（”for example; for instance;such as”。举例用，意为：例如）的缩写，其目的用若干例子来让前面说法更具体，更易感知。</p><blockquote><p>例句1: I like sports, <strong>e.g.</strong>, football.</p></blockquote><h2 id="etc-等等"><a href="#etc-等等" class="headerlink" title="etc. 等等"></a>etc. 等等</h2><p><strong>etc.<strong>是</strong>et cetera</strong>(“and so forth; and the others; and other things; and the rest; and so on”。举例用，意为：等等)的缩写。它放在列表的最后，表示前面的例子还没列举完，最后加个词“等等”。</p><blockquote><p>例句1: I need to go to the store and buy some pie, milk, cheese, <strong>etc.</strong></p></blockquote><blockquote><p>例句1：I like to eat boardwalk food, <strong>i.e.</strong>, funnel cake and french fries.<br>例句2：I like to eat boardwalk food, <strong>e.g.</strong>, funnel cake and french fries.</p></blockquote><p>例句1表示只有 funnel cake and french fries这两种boardwalk食物，而且这两种我都喜欢。例句2表示我喜欢boardwalk食物，比如 funnel cake and french fries；但是诸如snow cones and corn dogs等其他类型，我也可能喜欢。</p><h2 id="viz-即"><a href="#viz-即" class="headerlink" title="viz. 即"></a>viz. 即</h2><p><strong>viz.<strong>是</strong>videlicet</strong>（ “namely”, “towit”, “precisely”, “that is to say”。进一步解释用，意为：即）的缩写，与e.g.不同，<strong>viz位于同位列表之前，要把它前面单词所包含的项目全部列出。</strong>（不常用，渐渐被i.e.取代）</p><blockquote><p>例句1：The school offers two modules in Teaching English as a Foreign Language, <strong>viz.</strong> Principles and Methods of Language Teaching and Applied Linguistics.（该校提供两个模块用于英语作为外语的教学，即语言教学的原理方法和应用语言学。）<br>例句2: In this paper, a new TDNN architecture with two input variable, <strong>viz.</strong> wave form and its phase difference, is developed to reduce the grain noise.（本文提出了一种新的TDNN结构用于降低粗晶材料结构噪声，该结构具有波形及其相位差组成的双变量输入。）</p></blockquote><h2 id="et-al-等其他人"><a href="#et-al-等其他人" class="headerlink" title="et al. 等其他人"></a>et al. 等其他人</h2><p><strong>et al.<strong>是</strong>et alia</strong>（”and others; and co-workers”。在引用文献作者时用，意为:等其他人）的缩写。它几乎都是在列文献作者时使用，即把主要作者列出后，其它作者全放在et al. 里面。</p><p><strong>人的场合用et al，而无生命的场合用etc.(et cetera)。</strong></p><blockquote><p>例句1: These results agree with the ones published by Pelon <strong>et al</strong>. (2002).<br>例句2: Clegg <strong>et al.</strong> (1995) explain that in the electronics industry linear-programming models can be used to analyse the viability of the recovered parts in remanufacturing.（克莱格等人（1995）解释说，电子行业的线性规划模型可以用来分析在再制造过程中回收零部件的可行性。）</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>互联网络</title>
      <link href="/2023/11/29/%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/11/29/%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="片上网络（NoC）"><a href="#片上网络（NoC）" class="headerlink" title="片上网络（NoC）"></a>片上网络（NoC）</h1><p>单芯片多处理器系统（Chip Multiprocessor，CMP）通过在单款芯片上集成多个处理器和以挖掘线程级并行和任务级并行。</p><p>然而，传统的总线和交叉开关等片上互联结构的<strong>可扩展性较差</strong>，它们只能满足较少量的计算核的通信需求。因此，人们将“报文交换”的思想引入片上互联结构中，提出了“片上网络”（Network on Chip，NoC）的概念。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>网络的每个节点包含一个处理器核和一个路由器。处理器核通过网络接口将报文注入网络，或者从网络接收报文，路由器通过物理链路在网络节点间转发报文。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>与传统的总线和交叉开关等片上互联结构相比，片上网络具有以下特点和优势:</p><ol><li><strong>更高的可扩展性和可重用性</strong>。当增加处理器核数时，只需要在片上网络中增加相应数量的路由器和网络接口，不需要重新设计整个网络。片上网络的开销与网络节点数目成线性关系，易于扩展。新增路由器与现有路由器的结构基本相同，可以复用路由器设计。</li><li>通过路由器<strong>将芯片长连线切分成多条短连线</strong>，从而可以控制通信延迟和功耗。</li><li><strong>采用分布式控制策略</strong>，比采用集中式控制策略的总线支持更高的事务并发性。</li><li>由于片上网络时相互独立的，它可以采用全局异步局部同步（Global Asynchronous Local Synchronous，GALS）的时钟策略，<strong>将网络划分成多个细粒度时钟域</strong>，独立控制每个时钟域的电压和频率，灵活管理功耗。</li></ol><h2 id="片上网络与片外网络的差异"><a href="#片上网络与片外网络的差异" class="headerlink" title="片上网络与片外网络的差异"></a>片上网络与片外网络的差异</h2><p>片上网络与片外网络都采用了“报文交换”的思想，但有许多差异：</p><ol><li>片上网络互联的是单个芯片上的多个处理器；而片外网络是用于超级计算机和集群系统的。</li><li><strong>链路资源差异</strong>。现代集成电路的多层互联金属层为片上网络提供了丰富的连线资源，允许相邻路由器间的链路带宽达到<u>数百位</u>；然而对于片外网络，受限于芯片引脚数目限制，片外网络的链路带宽仅为数十位。</li><li><strong>延迟构成差异</strong>。片上网络相邻路由器之间距离较短，一般可以在一个时钟周期内完成链路传输；片外网络相邻路由器之间距离较大，链路传输需要多个时钟周期。然而较小的片上网络链路延迟增加了路由器延迟对新能的影响。</li><li><strong>串行总线Vs并行总线</strong>。片上网络主要采用并行总线，但由于片外并行总线的串扰难以控制，片外网路大多采用串行总线。</li><li><strong>面积和功耗资源</strong>。片上网络与处理器核竞争芯片有限的面积和功耗资源，与采用独立芯片实现的片外网络路由器相比，片上网络路由器面临着更为严格的面积和功耗限制。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 互联网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（八）————通过Ruby实现缓存一致性协议</title>
      <link href="/2023/11/25/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89/"/>
      <url>/2023/11/25/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h1><p>Ruby是一个详细的内存子系统的模拟模型。可以通过各种替换策略、一致性协议实现、互连网络、DMA和内存控制器、发起内存请求和处理响应的各种定序器来建模包含（inclusive）&#x2F;独占（exclusive）缓存层次结构。这些模型是模块化的、灵活的和高度可配置的。</p><p>Ruby有以下三个特点：</p><ul><li><strong>关注点分离</strong>。将内存系统的各个模型模块化，例如，一致性协议规范与替换策略和缓存索引映射是分开的，网络拓扑结构与实现也是分开指定的。</li><li><strong>丰富的可配置性</strong>。几乎所有影响内存层次结构的功能和时序都可以控制。</li><li><strong>快速的原型设计</strong>。使用一种高级规范语言SLICC来指定各种控制器的功能。</li></ul><p><strong>SLICC + 一致性协议</strong></p><p>SLICC：Specification Language for Implementing Cache Coherence，是一种特定领域的语言，用于指定缓存一致性协议。</p><p>缓存一致性协议以状态机的方式工作，而SLICC用于指定状态机的行为。SLICC文件以“.sm”结尾，它们是状态机文件。每个文件描述状态、某些事件从开始状态到结束状态的转换，以及在转换过程中要采取的操作。</p><p>每个一致性协议都由多个SLICC状态机文件组成。这些文件是用SLCC编译器编译的，该编译器是用Python编写的，也是gem5源代码的一部分。SLIC编译器<u>获取状态机文件</u>并<u>输出一组C++文件</u>，这些文件与gem5的所有其他文件一起编译。这些文件包括SimObject声明文件以及SimObjects和其他C++对象的实现文件。</p><h1 id="实现一致性协议的步骤"><a href="#实现一致性协议的步骤" class="headerlink" title="实现一致性协议的步骤"></a>实现一致性协议的步骤</h1><p>以下是对官网教程<a href="https://www.gem5.org/documentation/learning_gem5/part3/MSIintro/">gem5: Introduction to Ruby</a>的内容整理，教程的目标是实现MSI协议，协议的具体内容可以在《A Primer on Memory Consistency and Cache Coherence》书的第8.2节找到 (pages 141-149)</p><h2 id="1-注册状态机"><a href="#1-注册状态机" class="headerlink" title="1. 注册状态机"></a>1. 注册状态机</h2><p>MSI协议是通过SLICC语言编写的状态机文件实现的，这些状态机文件是用SLCC编译器编译的，会通过scons与gem5其他文件一起编译，因此需要为SCons创建一个文件，以便知道要编译什么。这里我们创建一个<code>Sconsopts</code>文件，而不是<code>Sconscript</code>文件，这是因为<code>Sconsopts</code>会在<code>Sconscript</code>之前执行，而我们也需要在编译gem5之前编译状态机文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Import(&#x27;*&#x27;)</span><br><span class="line"># 注册协议名‘MSI’，Scons将假定一个名为MSI.slicc的文件</span><br><span class="line">main.Append(ALL_PROTOCOLS=[&#x27;MSI&#x27;])</span><br><span class="line"># 告诉SCons在当前目录中查找要传递给SLCC编译器的文件。</span><br><span class="line">main.Append(PROTOCOL_DIRS=[Dir(&#x27;.&#x27;)])</span><br></pre></td></tr></table></figure><h2 id="2-编写状态机文件"><a href="#2-编写状态机文件" class="headerlink" title="2.编写状态机文件"></a>2.编写状态机文件</h2><p>编写状态机文件是实现一致性协议的最主要工作，状态机文件通常包含以下几个部分：</p><ul><li><p>Parameters</p><p>These are the parameters for the SimObject that will be generated from the SLICC code.</p></li><li><p>Declaring required structures and functions</p><p>This section declares the states, events, and many other required structures for the state machine.</p></li><li><p>In port code blocks</p><p>Contain code that looks at incoming messages from the (<code>in_port</code>) message buffers and determines what events to trigger.</p></li><li><p>Actions</p><p>These are simple one-effect code blocks (e.g., send a message) that are executed when going through a transition.</p></li><li><p>Transitions</p><p>Specify actions to execute given a starting state and an event and the final state. This is the meat of the state machine definition.</p></li></ul><p>Over the next few sections we will go over how to write each of these components of the protocol.</p><h3 id="2-1-状态机声明"><a href="#2-1-状态机声明" class="headerlink" title="2.1 状态机声明"></a>2.1 状态机声明</h3><p>创建一个名为<code>MSI-call.sm</code>的文件，并按以下格式声明状态机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">machine(MachineType:L1Cache, &quot;MSI cache&quot;)</span><br><span class="line">    : &lt;parameters&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &lt;All state machine code&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MachineType:L1Cache</code>将状态机命名为<code>L1Cache</code>，SLICC 将使用该名称为我们生成许多不同的对象。例如，一旦编译了这个文件，就会有一个新的 SimObject: <code>L1Cache_Controller</code> 作为缓存控制器。这个声明中还包括对这个状态机的描述: “ MSI cache”。</p><h3 id="2-2-状态机参数声明"><a href="#2-2-状态机参数声明" class="headerlink" title="2.2 状态机参数声明"></a>2.2 状态机参数声明</h3><p>状态机参数的声明在冒号（：）之后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">machine(MachineType:L1Cache, &quot;MSI cache&quot;)</span><br><span class="line">: Sequencer *sequencer;</span><br><span class="line">  CacheMemory *cacheMemory;</span><br><span class="line">  bool send_evictions;</span><br><span class="line">  # “To” buffer</span><br><span class="line">  MessageBuffer * requestToDir, network=&quot;To&quot;, virtual_network=&quot;0&quot;, vnet_type=&quot;request&quot;;</span><br><span class="line">  MessageBuffer * responseToDirOrSibling, network=&quot;To&quot;, virtual_network=&quot;2&quot;, vnet_type=&quot;response&quot;;</span><br><span class="line">  # “From” buffer</span><br><span class="line">  MessageBuffer * forwardFromDir, network=&quot;From&quot;, virtual_network=&quot;1&quot;, vnet_type=&quot;forward&quot;;</span><br><span class="line">  MessageBuffer * responseFromDirOrSibling, network=&quot;From&quot;, virtual_network=&quot;2&quot;, vnet_type=&quot;response&quot;;</span><br><span class="line">  # “To” buffer</span><br><span class="line">  MessageBuffer * mandatoryQueue;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>排序器（Sequencer）</p><p>Sequencer是一个带有从端口的gem5 MemObject，因此它可以接受来自其他对象的内存请求。Swquencer接受来自CPU（或其他主端口）的请求，并将gem5数据包转换为RubyRequest。最后，RubyRequest被推送到状态机的强制队列（commandoryQueue）中。</p></li><li><p>缓存数据（Cache Memory）</p><p>用于保存缓存数据（即缓存条目）的内容。</p></li><li><p>消息缓冲区（MessageBuffer）</p><p>消息缓冲区是状态机和Ruby网络之间的接口。通过消息缓冲区发送和接收消息。因此，对于我们协议中的每个虚拟通道，我们都需要一个单独的消息缓冲区。</p><p>虚拟网络的作用是防止死锁。MSI协议需要三个不同的虚拟网络。在该协议中，最高优先级是响应Response（虚拟网络2），其次是转发的请求Forwarded Requests（虚拟网络1），然后请求Requests具有最低优先级（虚拟网络0）。</p><p>代码中有两个”To” buffer，两个”From” buffer和一个Special buffer。其中，”To” buffer类似于gem5中的主端口，是此控制器用来向系统中的其他控制器发送消息的消息缓冲区；”From” buffer类似于gem5中的从端口，是此控制器用来接收系统中其他控制器发送的消息的消息缓冲区；对于Special buffer，Sequencer使用此消息缓冲区将gem5数据包转换为Ruby请求。与其他消息缓冲区不同，commandoryQueue不连接到Ruby网络，并且，此消息缓冲区的名称是硬编码的，必须为“commandoryQueue”</p><p>两个”To” buffer一个用于低优先级请求，另一个用于高优先级响应。优先级基于其他控制器查看消息缓冲区的顺序。类似地，两个”From” buffer使该缓存可以通过两种不同的方式接收消息，要么作为来自目录的转发请求，要么作为对该控制器发出的请求的响应。响应的优先级高于转发的请求。</p></li></ul><p>如前所述，状态机文件在经过SLICC编译后会成为Simobject文件，以上代码编译后产生的文件为<code>L1Cache_Controller.py</code>，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from m5.params import *</span><br><span class="line">from m5.SimObject import SimObject</span><br><span class="line">from Controller import RubyController</span><br><span class="line"></span><br><span class="line">class L1Cache_Controller(RubyController):</span><br><span class="line">    type = &#x27;L1Cache_Controller&#x27;</span><br><span class="line">    cxx_header = &#x27;mem/protocol/L1Cache_Controller.hh&#x27;</span><br><span class="line">    sequencer = Param.RubySequencer(&quot;&quot;)</span><br><span class="line">    cacheMemory = Param.RubyCache(&quot;&quot;)</span><br><span class="line">    send_evictions = Param.Bool(&quot;&quot;)</span><br><span class="line">    requestToDir = Param.MessageBuffer(&quot;&quot;)</span><br><span class="line">    responseToDirOrSibling = Param.MessageBuffer(&quot;&quot;)</span><br><span class="line">    forwardFromDir = Param.MessageBuffer(&quot;&quot;)</span><br><span class="line">    responseFromDirOrSibling = Param.MessageBuffer(&quot;&quot;)</span><br><span class="line">    mandatoryQueue = Param.MessageBuffer(&quot;&quot;)</span><br></pre></td></tr></table></figure><p>对这个文件，<strong>不能做任何修改！</strong></p><h3 id="2-3-状态声明"><a href="#2-3-状态声明" class="headerlink" title="2.3 状态声明"></a>2.3 状态声明</h3><p>通过<code>state_declaration</code>声明状态机的所有稳定和瞬态。对瞬态的命名遵循Sorin等人的命名约定。例如，瞬态“IM_AD”对应于在等待确认（A）和数据（D）时从无效（I）移动到已修改（M）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">state_declaration(State, desc=&quot;Cache states&quot;) &#123;</span><br><span class="line">    I,      AccessPermission:Invalid,</span><br><span class="line">                desc=&quot;Not present/Invalid&quot;;</span><br><span class="line"></span><br><span class="line">    // States moving out of I</span><br><span class="line">    IS_D,   AccessPermission:Invalid,</span><br><span class="line">                desc=&quot;Invalid, moving to S, waiting for data&quot;;</span><br><span class="line">    IM_AD,  AccessPermission:Invalid,</span><br><span class="line">                desc=&quot;Invalid, moving to M, waiting for acks and data&quot;;</span><br><span class="line">    IM_A,   AccessPermission:Busy,</span><br><span class="line">                desc=&quot;Invalid, moving to M, waiting for acks&quot;;</span><br><span class="line"></span><br><span class="line">    S,      AccessPermission:Read_Only,</span><br><span class="line">                desc=&quot;Shared. Read-only, other caches may have the block&quot;;</span><br><span class="line"></span><br><span class="line">    // States moving out of S</span><br><span class="line">    SM_AD,  AccessPermission:Read_Only,</span><br><span class="line">                desc=&quot;Shared, moving to M, waiting for acks and &#x27;data&#x27;&quot;;</span><br><span class="line">    SM_A,   AccessPermission:Read_Only,</span><br><span class="line">                desc=&quot;Shared, moving to M, waiting for acks&quot;;</span><br><span class="line"></span><br><span class="line">    M,      AccessPermission:Read_Write,</span><br><span class="line">                desc=&quot;Modified. Read &amp; write permissions. Owner of block&quot;;</span><br><span class="line"></span><br><span class="line">    // States moving to Invalid</span><br><span class="line">    MI_A,   AccessPermission:Busy,</span><br><span class="line">                desc=&quot;Was modified, moving to I, waiting for put ack&quot;;</span><br><span class="line">    SI_A,   AccessPermission:Busy,</span><br><span class="line">                desc=&quot;Was shared, moving to I, waiting for put ack&quot;;</span><br><span class="line">    II_A,   AccessPermission:Invalid,</span><br><span class="line">                desc=&quot;Sent valid data before receiving put ack. &quot;Waiting for put ack.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个状态都有一个相关的访问权限<code>AccessPermission</code>，包括无效（<strong>Invalid</strong>）、不存在（<strong>NotPresent</strong>）、忙（<strong>Busy</strong>）、只读（<strong>Read_Only</strong>）、读写（<strong>Read_Write</strong>），访问权限用于对缓存进行功能访问<em>functional accesses</em>。对于功能访问，将检查所有缓存，看它们是否有具有匹配地址的相应块。</p><h3 id="2-4-事件声明"><a href="#2-4-事件声明" class="headerlink" title="2.4 事件声明"></a>2.4 事件声明</h3><p>声明由该缓存控制器的传入消息触发的所有事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">enumeration(Event, desc=&quot;Cache events&quot;) &#123;</span><br><span class="line">    // From the processor/sequencer/mandatory queue</span><br><span class="line">    Load,           desc=&quot;Load from processor&quot;;</span><br><span class="line">    Store,          desc=&quot;Store from processor&quot;;</span><br><span class="line"></span><br><span class="line">    // Internal event (only triggered from processor requests)</span><br><span class="line">    Replacement,    desc=&quot;Triggered when block is chosen as victim&quot;;</span><br><span class="line"></span><br><span class="line">    // Forwarded request from other cache via dir on the forward network</span><br><span class="line">    FwdGetS,        desc=&quot;Directory sent us a request to satisfy GetS. We must have the block in M to respond to this.&quot;;</span><br><span class="line">    FwdGetM,        desc=&quot;Directory sent us a request to satisfy GetM. We must have the block in M to respond to this.&quot;;</span><br><span class="line">    Inv,            desc=&quot;Invalidate from the directory.&quot;;</span><br><span class="line">    PutAck,         desc=&quot;Response from directory after we issue a put. This must be on the fwd network to avoid deadlock.&quot;;</span><br><span class="line"></span><br><span class="line">    // Responses from directory</span><br><span class="line">    DataDirNoAcks,  desc=&quot;Data from directory (acks = 0)&quot;;</span><br><span class="line">    DataDirAcks,    desc=&quot;Data from directory (acks &gt; 0)&quot;;</span><br><span class="line"></span><br><span class="line">    // Responses from other caches</span><br><span class="line">    DataOwner,      desc=&quot;Data from owner&quot;;</span><br><span class="line">    InvAck,         desc=&quot;Invalidation ack from other cache after Inv&quot;;</span><br><span class="line"></span><br><span class="line">    // Special event to simplify implementation</span><br><span class="line">    LastInvAck,     desc=&quot;Triggered after the last ack is received&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态和事件可以参考表8.3的缓存控制器转换表</p><p><img src="/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89/image-20231204190803198.png" alt="image-20231204190803198"></p><h3 id="2-5-用户定义结构体"><a href="#2-5-用户定义结构体" class="headerlink" title="2.5 用户定义结构体"></a>2.5 用户定义结构体</h3><p>下面定义的是在这个控制器的其他地方用到的结构体</p><h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><p>这是存储在CacheMemory中的结构。它只需要包含数据和状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">structure(Entry, desc=&quot;Cache entry&quot;, interface=&quot;AbstractCacheEntry&quot;) &#123;</span><br><span class="line">    State CacheState,        desc=&quot;cache state&quot;;</span><br><span class="line">    DataBlock DataBlk,       desc=&quot;Data in the block&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TBE"><a href="#TBE" class="headerlink" title="TBE"></a>TBE</h4><p>TBE是“事务缓冲区条目”。这存储了瞬态期间所需的信息。这就像MSHR。它在该协议中起MSHR的作用，但该条目也被分配用于其他用途。在该协议中，它将存储状态（通常需要）、数据（通常也需要）以及该块当前正在等待的ack数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">structure(TBE, desc=&quot;Entry for transient requests&quot;) &#123;</span><br><span class="line">    State TBEState,         desc=&quot;State of block&quot;;</span><br><span class="line">    DataBlock DataBlk,      desc=&quot;Data for the block. Needed for MI_A&quot;;</span><br><span class="line">    int AcksOutstanding, default=0, desc=&quot;Number of acks left to receive.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TBETable"><a href="#TBETable" class="headerlink" title="TBETable"></a>TBETable</h4><p>还需要一个存放所有TBE的地方。其中<code>external=&quot;yes&quot;</code>表明这是一个外部定义的类；它是在SLICC之外的C++中定义的。因此，我们需要声明我们将要使用它，并声明我们将对其调用的任何函数。您可以在src&#x2F;mem&#x2F;ruby&#x2F;structures&#x2F;TBETable.hh中找到TBETable的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">structure(TBETable, external=&quot;yes&quot;) &#123;</span><br><span class="line">  TBE lookup(Addr);</span><br><span class="line">  void allocate(Addr);</span><br><span class="line">  void deallocate(Addr);</span><br><span class="line">  bool isPresent(Addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="外部函数声明"><a href="#外部函数声明" class="headerlink" title="外部函数声明"></a>外部函数声明</h4><p>如果我们要在文件的其余部分中使用AbstractController中的任何函数，都需要声明它们。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tick clockEdge();</span><br><span class="line">void set_cache_entry(AbstractCacheEntry a);</span><br><span class="line">void unset_cache_entry();</span><br><span class="line">void set_tbe(TBE b);</span><br><span class="line">void unset_tbe();</span><br></pre></td></tr></table></figure><h4 id="样板代码"><a href="#样板代码" class="headerlink" title="样板代码"></a>样板代码</h4><p>下面这一组样板工具代码很少在不同的协议之间发生变化。在AbstractController中，我们必须实现一组纯虚拟的函数。</p><ul><li>getState</li></ul><p>Given a TBE, cache entry, and address return the state of the block. This is called on the block to decide which transition to execute when an event is triggered. Usually, you return the state in the TBE or cache entry, whichever is valid.</p><p>给定IBE，entry和地址，返回地址所在缓存块的状态</p><ul><li>setState</li></ul><p>Given a TBE, cache entry, and address make sure the state is set correctly on the block. This is called at the end of the transition to set the final state on the block.</p><ul><li>getAccessPermission</li></ul><p>Get the access permission of a block. This is used during functional access to decide whether or not to functionally access the block. It is similar to <code>getState</code>, get the information from the TBE if valid, cache entry, if valid, or the block is not present.</p><ul><li>setAccessPermission</li></ul><p>Like <code>getAccessPermission</code>, but sets the permission.</p><ul><li>functionalRead</li></ul><p>Functionally read the data. It is possible the TBE has more up-to-date information, so check that first. Note: testAndRead&#x2F;Write defined in src&#x2F;mem&#x2F;ruby&#x2F;slicc_interface&#x2F;Util.hh</p><ul><li>functionalWrite</li></ul><p>Functionally write the data. Similarly, you may need to update the data in both the TBE and the cache entry.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">State getState(TBE tbe, Entry cache_entry, Addr addr) &#123;</span><br><span class="line">    // The TBE state will override the state in cache memory, if valid</span><br><span class="line">    if (is_valid(tbe)) &#123; return tbe.TBEState; &#125;</span><br><span class="line">    // Next, if the cache entry is valid, it holds the state</span><br><span class="line">    else if (is_valid(cache_entry)) &#123; return cache_entry.CacheState; &#125;</span><br><span class="line">    // If the block isn&#x27;t present, then it&#x27;s state must be I.</span><br><span class="line">    else &#123; return State:I; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void setState(TBE tbe, Entry cache_entry, Addr addr, State state) &#123;</span><br><span class="line">  if (is_valid(tbe)) &#123; tbe.TBEState := state; &#125;</span><br><span class="line">  if (is_valid(cache_entry)) &#123; cache_entry.CacheState := state; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AccessPermission getAccessPermission(Addr addr) &#123;</span><br><span class="line">    TBE tbe := TBEs[addr];</span><br><span class="line">    if(is_valid(tbe)) &#123;</span><br><span class="line">        return L1Cache_State_to_permission(tbe.TBEState);</span><br><span class="line">    &#125;</span><br><span class="line">    Entry cache_entry := getCacheEntry(addr);</span><br><span class="line">    if(is_valid(cache_entry)) &#123;</span><br><span class="line">        return L1Cache_State_to_permission(cache_entry.CacheState);</span><br><span class="line">    &#125;</span><br><span class="line">    return AccessPermission:NotPresent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void setAccessPermission(Entry cache_entry, Addr addr, State state) &#123;</span><br><span class="line">    if (is_valid(cache_entry)) &#123;</span><br><span class="line">        cache_entry.changePermission(L1Cache_State_to_permission(state));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void functionalRead(Addr addr, Packet *pkt) &#123;</span><br><span class="line">    TBE tbe := TBEs[addr];</span><br><span class="line">    if(is_valid(tbe)) &#123;</span><br><span class="line">        testAndRead(addr, tbe.DataBlk, pkt);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        testAndRead(addr, getCacheEntry(addr).DataBlk, pkt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int functionalWrite(Addr addr, Packet *pkt) &#123;</span><br><span class="line">    int num_functional_writes := 0;</span><br><span class="line">    TBE tbe := TBEs[addr];</span><br><span class="line">    if(is_valid(tbe)) &#123;</span><br><span class="line">        num_functional_writes := num_functional_writes +</span><br><span class="line">            testAndWrite(addr, tbe.DataBlk, pkt);</span><br><span class="line">        return num_functional_writes;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以下是对这些状态和转换的高层次描述：</p><p><img src="/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89/v2-c033b43df7af58f9468432e564c4266f_720w.png" alt="img"></p><h3 id="2-6-输入输出端口"><a href="#2-6-输入输出端口" class="headerlink" title="2.6 输入输出端口"></a>2.6 输入输出端口</h3><p>参考链接🔗</p><p><a href="https://zhuanlan.zhihu.com/p/539342291">gem5模拟器入门（四） - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/qq_34898487/article/details/134252221">EM5官方教程全流程： part 3 RUBY-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/11/25/Cache%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/25/Cache%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>对称式共享存储器系统支持共享数据和私有数据的缓存。</p><ul><li><p><strong>私有数据被单个处理器使用。</strong></p><p>好处：把一个私有数据从存储器缓存到Cache之后，对该数据的访问就可以在Cache中进行，因此减少了平均访存时间和对存储器带宽的要求。</p><p>同时因为没有其他处理器使用这些数据，程序的行为与单处理器系统相同。</p></li><li><p><strong>共享数据被多个处理器所使用。</strong></p><p>通过读写共享数据完成处理器之间的通信。</p><p>好处：共享数据装载到Cache中时，会在多个Cache中形成副本，这样1. 一方面会减少访问时间并降低对存储器带宽的要求，2. 还可以减少多个处理器同时读共享数据时所产生的冲突。</p><p>但是，共享数据进入Cache也产生了一个新问题——Cache的一致性问题。</p></li></ul><h1 id="一、什么是多处理器的Cache一致性？"><a href="#一、什么是多处理器的Cache一致性？" class="headerlink" title="一、什么是多处理器的Cache一致性？"></a>一、什么是多处理器的Cache一致性？</h1><h2 id="存储器一致性定义一"><a href="#存储器一致性定义一" class="headerlink" title="存储器一致性定义一"></a>存储器一致性定义一</h2><p>一个模糊且简单的定义：如果在一个存储器系统中读取任何一个数据项的返回结果总是最近写入的数值，那么就可以认为该存储器具有一致性。（定义一）</p><p>这个定义包含了两个方面：一方面是<strong>一致</strong>（coherence），它定义了读操作可以返回什么样的数值【what】；另一方面是<strong>连贯</strong>（consistency），它定义了写入的数值什么时候才能被读操作返回【when】。</p><p>一致定义了对同一个存储器地址进行的读写操作行为；连贯定义了关于访问其他存储器地址的读写操作。</p><h2 id="存储器一致性定义二"><a href="#存储器一致性定义二" class="headerlink" title="存储器一致性定义二"></a>存储器一致性定义二</h2><p>如果一个存储器系统满足以下条件，那么认为该存储器系统是一致的：（定义二）</p><ol><li><p>处理器P对地址X的写操作后面紧跟着处理器P对X的读操作，而且在这次读操作和写操作之间没有其他处理器对X进行写操作，这时读操作总是返回P写入的数值。</p><blockquote><p>这个性质保证了程序的顺序，即使在单处理器中也要保证这个性质。</p></blockquote></li><li><p>在其他处理器对X的写操作后，处理器P对X执行读操作，这两个操作之间有<u>足够的间隔</u>并且没有其他处理器对X进行写操作，这是，读操作返回的是写入的数值。</p><blockquote><p>这个性质给出了一致性的概念，如果一个处理器对某个数据执行读操作时，总是的读入旧的数据，那么该存储器是非一致的。</p></blockquote></li><li><p>对同一地址的写操作是串行执行的；也就是说，任何两个处理器对同一地址的两个写操作在所有处理器看来都有相同的顺序。例如，对同一地址先后写入数值1和数值2，处理器绝不会从该地址中先读出2再读出1。</p></li></ol><blockquote><p>这个性质称为<strong>写串行化</strong>，保证同一地址所写的顺序对任何处理器来说都是相同的。</p></blockquote><p>在三个条件之外，还又两个假设：</p><p>假设：</p><ol><li>直到所有处理器都看到了写操作之后一个写操作才算完成，并且后续的写操作才能开始。</li><li>处理器不会因为其他存储操作而改变写操作的顺序。</li></ol><p>这两个假设意味着如果处理器向地址A写入后又向地址B写入，所有能看到B中新值的处理器必须也能看到A的新值。</p><h2 id="定义一和定义二的联系"><a href="#定义一和定义二的联系" class="headerlink" title="定义一和定义二的联系"></a>定义一和定义二的联系</h2><p>定义二的三个条件已经体现了定义一的一致方面【what】，定义一的连贯方面，即什么时候才能获得写进去的值【when】，则体现在条件2的<u>读写操作之间有足够的时间间隔</u>上面。</p><p>通常不可能要求在一个处理器写入X的数值后，其他处理器就能即刻在X上读出这一值。因此，如果一个处理器对X进行写后，很短时间内另一处理器对X进行读，那么无法保证该读操作能返回写入的数值，因为这一刻写入的数据是怎知可能还没被处理器发送出去。</p><p>总的来说，缓存一致性机制需要解决的问题就是 2 点：</p><ul><li><strong>特性 1 - 写传播（Write Propagation）：</strong> 每个 CPU 核心的写入操作，需要传播到其他 CPU 核心；</li><li><strong>特性 2 - 写事务串行化（Transaction Serialization）：</strong> 各个 CPU 核心所有写入操作的顺序，在所有 CPU 核心看起来是一致。</li></ul><p>如果没有写串行化，举个例子：假如 CPU 有 4 个核心，Core 1 将共享数据修改为 1000，随后 Core 2 将共享数据修改为 2000。在写传播下，“修改为 1000” 和 “修改为 2000” 两个事务会同步到 Core 3 和 Core 4。但是，如果没有事务串行化，不同核心收到的事务顺序可能是不同的，最终数据还是不一致。</p><h1 id="二、实现一致性的方案"><a href="#二、实现一致性的方案" class="headerlink" title="二、实现一致性的方案"></a>二、实现一致性的方案</h1><p>在一致的多处理机中，Cache提供了共享数据的迁移和复制功能。</p><p>共享数据的<strong>迁移</strong>是把远程的共享数据项备份放在本处理器局部的Cache中使用，从而降低了对远程共享数据的访问延迟。</p><p>共享数据的<strong>复制</strong>是把多个处理器需要同时读取的共享数据项的备份放在各自的局部Cache中使用。</p><p>对多个处理器维护一致性的协议称为Cache一致性协议（Cache-coherent Protocal）</p><h2 id="目录协议与监听协议"><a href="#目录协议与监听协议" class="headerlink" title="目录协议与监听协议"></a>目录协议与监听协议</h2><p>（1）监听（Snooping）——每个Cache除了包含物理存储器中块的数据备份之外，也保存着每个块的共享状态信息。Cache通常连在共享存储器的总线上，各个Cache控制器通过监听总线来判断他们是否有总线上请求的数据块。【每个数据块状态是分散在各个Cache中的】</p><p>对于监听协议，常用于集中式共享存储器体系结构，因为可以利用已有的物理连接（总线）来进行广播，但因为广播带来的带宽压力大，所以监听协议的可扩展性较差。</p><p>（2）目录（Directory）——物理存储器中共享数据块的状态及相关信息均被保存集中地在一个称为目录的地方。【每个数据块状态是集中在目录中的】</p><p>对于目录协议，常用于分布式共享存储器体系结构，通过目录避免了广播操作，减小了带宽负担，可扩展性好。</p><p>实现Cache一致性协议的关键是跟踪共享数据块的状态。目前有两类协议，采用了不同的共享数据状态跟踪技术：</p><h2 id="写作废协议与写更新协议"><a href="#写作废协议与写更新协议" class="headerlink" title="写作废协议与写更新协议"></a>写作废协议与写更新协议</h2><p>可通过两种方法来维持一致性要求：</p><p>（1）写作废协议（Write Invalidate）——在一个处理器写某个数据项之前保证它对该数据项有唯一的访问权，唯一的访问权保证了在进行写后不存在其他可读或可写的备份，因为别的备份都作废了。又叫写无效。</p><p>（2）写更新协议（Write Update）——当一个处理器写某数据项时。通过广播使其他Cache中所有对应的该数据项备份进行更新。又叫写广播。</p><p>由于写更新协议必须将所有写操作广播给共享Cache，需要更大的带宽，所以大多处理器都选择写作废协议。</p><h1 id="三、监听协议"><a href="#三、监听协议" class="headerlink" title="三、监听协议"></a>三、监听协议</h1><p>由于监听协议需要广播，对总线带宽的需求大，因此仅适用于<strong>小规模的多处理机</strong>，即集中式共享存储器系统。</p><p>监听协议的关键是利用总线或其他广播媒介进行作废操作。当某个处理器进行写数据时，必须先获得总线的控制权，然后将要作废的数据块的地址放在总线上。其他处理器一致监听总线，他们检测地址所对应的数据是否在它们的Cache中，若在，则作废相应数据块。</p><p>当写Cache未命中时，除了作废其他处理器上相应的Cache数据块以外，还要从存储器取出该数据块。</p><ul><li><p>对于<strong>写直达Cache</strong>，因为所有写的数据同时被写回主存，则从主存中总可以取到最新的数据值。</p></li><li><p>对于<strong>写回Cache</strong>，因为最新之可能在某个处理器的Cache中，也可能在主存中，所以得到数据的最新值会困难一些。在写回Cache失效时可使用相同的监听机制：1. 当请求处理器的Cache发生写失效后，广播该数据块的地址。2. 其他处理器都监听放在总线上的地址，如果某个处理器发现它含有被请求数据块的一个已经修改过的备份（即修改过了该数据块但还未写回内存），它九江这个数据块送给发出读请求的处理器，并停止其对主存的访问请求。</p></li></ul><p>相比于写直达Cache，写回Cache实现一致性有两个缺点：</p><blockquote><ol><li>实现复杂度显然更高</li><li>写回Cache从处理器Cache中重新找回数据块的时间通常比写直达Cache从共享存储器中找回数据块的时间长</li></ol></blockquote><p>但写回Cache所需的<strong>存储器带宽较低</strong>的特点使得其在多处理机实现上很受欢迎。</p><h2 id="写回Cache条件下的监听协议实现"><a href="#写回Cache条件下的监听协议实现" class="headerlink" title="写回Cache条件下的监听协议实现"></a>写回Cache条件下的监听协议实现</h2><p>利用总线实现写传播和写事务串行化：</p><ul><li><strong>写传播 - 总线嗅探：</strong> 总线除了能在一个主模块和一个从模块之间传输数据，还支持一个主模块对多个从模块写入数据，这种操作就是广播。要实现写传播，其实就是将所有的读写操作广播到所有 CPU 核心，而其它 CPU 核心时刻监听总线上的广播，再修改本地的数据；</li><li><strong>事务串行化 - 总线仲裁：</strong> 总线的独占性要求同一时刻最多只有一个主模块占用总线，天然地会将所有核心对内存的读写操作串行化。如果多个核心同时发起总线事务，此时总线仲裁单元会对竞争做出仲裁，未获胜的事务只能等待获胜的事务处理完成后才能执行。</li></ul><p>使用的辅助结构</p><ul><li><p>有效位</p><p>在写回Cache的数据块中，有效位被用于指示该块是否有效。利用有效位，可以使作废的处理很简单，只需要将该位置为无效即可。</p></li><li><p>状态位</p><p>为了分辨某个数据块所处的状态，还要给每个块增加一个特殊的状态位。</p></li><li><p>降低冲突</p><p>因为每次总线任务均要检查Cache的地址位，这可能与CPU对Cache的访问冲突，可通过以下两种技术之一降低冲突：</p><ol><li>复制标志位：将Cache的标志位复制一份，一份正常用于Cache访问，另一份用于监听，两个任务可以并行对标志位进行读。但代价就是修改标志位的时候也必须同时修改两份，同时如果两个任务修改标志位冲突，则非抢先者将被挂起。</li><li>多级包含Cache：采用多级Cache，通常为两级，靠近CPU的第一级Cache是较远的第二级Cache的一个子集。于是，监听可针对第二级Cache进行，而处理器的大多数访问针对第一季Cache，极大地避免了冲突。但是，如果监听命中第二级Cache，它必须垄断对各级Cache的访问，更新块状态并可能写回数据，这通常要挂起处理器对Cache的访问。</li></ol><p>可采用将第二级Cache中的标志位复制，会更有效地减少CPU和监听之间的冲突。</p><p>判断数据块是否共享，可以帮助写操作判断是否需要发送作废操作——当对<u>共享数据块</u>进行写操作时，Cache会在总线上发送一个作废操作，并把该块标记为专有（非共享）；当对<u>专有数据块</u>进行写操作时，由于只有该Cache有数据块的唯一副本，所以不用发送作废操作到总线上了。这样避免了发送作废操作，可以节省时间和带宽。</p></li></ul><p>一致性协议本质上是一个状态机，具有若干状态。不同的协议具有不同的状态组合和转换策略。</p><p>对于数据块状态的描述，可以用以下四个特征来编码：</p><ul><li><strong>有效性（Validity）</strong>：有效的块含有数据的最新值，可以被读。</li><li><strong>肮脏性（Dirtiness）</strong>：如果一个Cache中的块与在内存中对应的块是不同的，那么意味着Cache中的块是被修改过的、最新的、有效的，还未被写入内存，而内存中的对应块是旧的、无效的。因为Cache中的块被修改了，所以称其为“脏”的。</li><li><strong>独占性（Exclusivity）</strong>：如果缓存块是系统中该块的唯一私有缓存副本，则该缓存块是独占的。（它也可能出现在内存中，但不可能出现在其他Cache中）。</li><li><strong>所有权（Ownership）</strong>：如果缓存控制器（或内存控制器）负责响应对该块的一致性请求，那么它就是该块的所有者。</li></ul><p><strong>稳态</strong></p><p>一致性协议常见稳定状态：</p><ul><li>共享状态（S）是指块是同于主存的，该块可能还在其他Cache中，也可能仅在该Cache中</li><li>独占状态（E）是指块是同于主存的，仅在该Cache中</li><li>修改状态（M）是指块是不同与主存的，即在Cache中已经被更新；修改状态暗示了此时的块已经被独占，即仅在该Cache中</li><li>无效状态（I）是指块里的数据是旧的，已经失效了</li></ul><blockquote><p>NB：</p><p>“同于主存”是指在Cache中的块与在内存中对应的块是相同的。有时也称是“干净”的</p><p>“不同于主存”是指在Cache中的块与在内存中对应的块是不同的，内存中的块是旧的、无效的。有时也称是“脏”的</p></blockquote><p><strong>M (Modified)：</strong>该块是有效的、排他的、拥有的，并且可能是脏的。 该块可以被读取或写入。 缓存具有块的唯一有效副本，缓存必须响应对块的请求，并且 LLC&#x2F;内存中的块副本可能是陈旧的。</p><p><strong>S (Shared)：</strong>该块有效但不排他，不脏，不拥有。缓存具有块的只读副本。其他缓存可能具有该块的有效只读副本。</p><p><strong>I (Invalid)：</strong>块无效。缓存要么不包含块，要么包含可能无法读取或写入的陈旧副本。在本入门书中，我们不区分这两种情况，尽管有时前一种情况可以表示为“不存在”状态。</p><p><strong>O (Owned)：</strong>该块是有效的，拥有的，并且可能是脏的，但不是独占的。 缓存具有块的只读副本，并且必须响应对该块的请求。 其他缓存可能具有该块的只读副本，但它们不是所有者。LLC&#x2F;内存中的块副本可能已过时。</p><p><strong>E (Exclusive)：</strong>该块是有效的、排他的和干净的。缓存具有块的只读副本。没有其他缓存拥有该块的有效副本，并且 LLC&#x2F;内存中的块副本是最新的。在本入门书中，我们认为当区块处于独占状态时，它是拥有的，尽管在某些协议中独占状态不被视为所有权状态。当我们在后面的章节中介绍 MESI 监听和目录协议时，我们将讨论是否把独占块视为所有者的问题。</p><p>监听一致性协议一般通过每个节点的有效状态控制器来实现，控制器对每个来自<strong>处理器</strong>和<strong>总线</strong>的请求做出响应，然后改变响应Cache块的状态</p><h3 id="MSI协议"><a href="#MSI协议" class="headerlink" title="MSI协议"></a>MSI协议</h3><p>MSI协议是最基础的监听协议实现。有<strong>无效</strong>、<strong>共享</strong>和<strong>修改</strong>三种状态</p><h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><p>MESI是最经典的监听协议。有<strong>无效</strong>、<strong>共享</strong>、<strong>独占</strong>和<strong>修改</strong>三种状态</p><p>相比于MSI协议，MESI协议增加了独占（E）状态，是一种投机性优化：如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成invalid状态，而修改E状态的缓存不需要使用总线事务。</p><p>演示MESI协议网页<a href="https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESI.htm">VivioJS MESI (tcd.ie)</a></p><h2 id="监听协议和集中式共享存储器体系结构的局限性"><a href="#监听协议和集中式共享存储器体系结构的局限性" class="headerlink" title="监听协议和集中式共享存储器体系结构的局限性"></a>监听协议和集中式共享存储器体系结构的局限性</h2><blockquote><p>随着多处理器中处理器数目的增加，或者处理器对存储器带宽的增加，系统的任何集中式资源都会成为“瓶颈”</p></blockquote><p>例如在基于总线的多处理器中，总线必须同时支持由于Cache导致的存储器通信和一致性通信。如果是只有一个物理存储器的集中式共享存储器体系结构，总线的带宽（bandwidth）负担会极大。</p><p>为了增加处理器和存储器之间的通信带宽，设计者使用多种总线以及各种互联网络，如交叉开关和小型点对点网络。在该设计中，存储器系统可以被配置称多个物理组，有效增加带宽。这正是<u>集中式共享存储器和分布式共享存储器的结合</u>。</p><p>图</p><p>由上例可知，使用监听Cache一致性协议可以不要求使用集中式总线这样的很容易造成带宽瓶颈的通信方式，但仍然要求完成广播。由于一致性通信量与处理器速度没有关系，这种一致性通信<u>限制了处理器的扩展与速度</u>。</p><h1 id="四、目录协议"><a href="#四、目录协议" class="headerlink" title="四、目录协议"></a>四、目录协议</h1><p>对于监听协议，在处理每个Cache缺失时，都需要和所有的Cache进行通信，造成带宽瓶颈，限制了处理器的扩展。</p><p>每个目录负责跟踪共享本地存储器的Cache，存储器的每一块在目录中对应有一项</p><p>每个目录项主要有“状态”和“位向量”两种成分。状态描述该目录所对应的存储块的当前情况；位向量有处理器数量的位数，其每一位对应于一个处理器的局部Cache，用于指出该Cache中有无该存储块的备份。</p><hr><p>本文是对《计算机体系结构——量化研究方法（第四版）》和《计算机体系结构（第二版）》的相关章节的整理</p><p>参考链接🔗</p><p><a href="https://zhuanlan.zhihu.com/p/94811032">cache之多核一致性(一) - 总线上没有秘密 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Cache一致性协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并行体系结构</title>
      <link href="/2023/11/24/%E5%B9%B6%E8%A1%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2023/11/24/%E5%B9%B6%E8%A1%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="一、并行体系结构的Flynn分类法"><a href="#一、并行体系结构的Flynn分类法" class="headerlink" title="一、并行体系结构的Flynn分类法"></a>一、并行体系结构的Flynn分类法</h1><h2 id="1-单指令流，单数据流（SISD）"><a href="#1-单指令流，单数据流（SISD）" class="headerlink" title="1. 单指令流，单数据流（SISD）"></a>1. 单指令流，单数据流（SISD）</h2><p>单处理器，即传统的、串行的冯·诺伊曼计算机</p><h2 id="2-单指令流，多数据流（SIMD）"><a href="#2-单指令流，多数据流（SIMD）" class="headerlink" title="2. 单指令流，多数据流（SIMD）"></a>2. 单指令流，多数据流（SIMD）</h2><p>同一条指令被多个使用不同数据流的多处理器执行，实现<strong>数据级并行</strong></p><p>例如：向量计算机、阵列计算机</p><h2 id="3-多指令流，单数据流（MISD）"><a href="#3-多指令流，单数据流（MISD）" class="headerlink" title="3. 多指令流，单数据流（MISD）"></a>3. 多指令流，单数据流（MISD）</h2><p>奇葩没有研究价值</p><h2 id="4-多指令流，多数据流（MIMD）"><a href="#4-多指令流，多数据流（MIMD）" class="headerlink" title="4. 多指令流，多数据流（MIMD）"></a>4. 多指令流，多数据流（MIMD）</h2><p>每个处理器取自己的指令并对自己的数据进行操作，实现<strong>线程级并行</strong></p><p>例如：集群、片内多处理器（多核）</p><ul><li><p>其中，MIMD计算机更加受到学术和商业上的关注，这是因为以下两点：</p><ul><li><p><strong>灵活性强：</strong>MIMD可以实现线程级并行机制，因此</p><p>（1）支持数据级并行：既可以作为单用户多处理器为单一应用程序提供高性能（为一个高负载程序提供高性能）</p><p>（2）支持任务级并行：也可以作为同时运行多个任务的多道程序多处理器系统使用（同时运行多个程序）</p><p>（3）甚至可以支持数据级和任务级两种并行的应用。</p></li><li><p><strong>性价比高：</strong>能充分利用现有微处理器的性价比优势，多核芯片可以通过复制的方式，有效降低单处理器内核的设计成本。</p></li></ul></li></ul><h1 id="二、MIMD分类"><a href="#二、MIMD分类" class="headerlink" title="二、MIMD分类"></a>二、MIMD分类</h1><p>根据处理器间通信机制（传递数据所用的方法），MIMD还可以分为<strong>多处理器系统</strong>和<strong>多计算机系统</strong></p><h2 id="多处理器系统"><a href="#多处理器系统" class="headerlink" title="多处理器系统"></a>多处理器系统</h2><p>多处理器系统是<strong>共享内存</strong>的计算机。多个处理器通过逻辑上共享的地址空间进行通信，换言之，CPU上运行的操作系统可以直接通过LOAD指令或者STORE指令访问其他远程CPU的内存字。</p><h2 id="多计算机系统"><a href="#多计算机系统" class="headerlink" title="多计算机系统"></a>多计算机系统</h2><p>多计算机系统是<strong>消息传递</strong>的计算机，多个处理器在逻辑上没有共享的地址空间，而是有多个私有的地址空间组成，这些地址空间在逻辑上是独立分散的，换言之，CPU只能通过显示发送消息并等待响应的方式与其他远程CPU进行通信。</p><p>多处理器和多计算机两种体系结构的差别</p><table><thead><tr><th></th><th>多处理器</th><th>多计算机</th></tr></thead><tbody><tr><td>CPU间通信方式</td><td>共享内存（隐式地，通过load、store指令）</td><td>消息传递（显式地，通过发送、接收消息的函数）</td></tr><tr><td>地址空间</td><td>所有CPU共享一个单一的物理地址空间</td><td>每个CPU都有自己独立的物理地址空间</td></tr><tr><td>常见编程模型</td><td>OpenMP编程模型</td><td>MPI编程模型</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="三、多处理器系统"><a href="#三、多处理器系统" class="headerlink" title="三、多处理器系统"></a>三、多处理器系统</h1><p>根据<strong>存储器组织方式</strong>或者说<strong>共享内存的实现方式</strong>，可以进一步把多处理器系统分为两类：集中式共享存储器系统结构和分布式存储器系统结构。</p><h2 id="集中式共享存储器系统（Centralized-Shared-Memory-CSM）"><a href="#集中式共享存储器系统（Centralized-Shared-Memory-CSM）" class="headerlink" title="集中式共享存储器系统（Centralized Shared-Memory, CSM）"></a>集中式共享存储器系统（Centralized Shared-Memory, CSM）</h2><p>对于处理机数目较少的多处理机，各个处理机可以共享单个集中式存储器。当处理机数量很大时，由于访问冲突以及总线带宽的限制，访问延迟就会很大。</p><ul><li><p><strong>结构</strong>：多个处理器-Cache子系统共享同一个较大的物理存储器。</p></li><li><p><strong>如何实现共享内存？</strong>因为多处理机物理上共享单个存储器，因此逻辑上的共享是自然而然的。</p></li></ul><p>别称：因为只用一个单独的主存，而且这个主存对于各处理器的关系是对称的，所以各处理器访问这个主存的时间相同，所以这种结构有时被称为<u>对称式共享存储器结构</u>（Symmetric shared-memory MultiProcessor, SMP），或者<u>一致性内存访问计算</u>机（Uniform Memory Access, UMA）</p><blockquote><p>ps：使用大容量Cache</p><p>对于共享存储器结构，存储器和总线的带宽往往是瓶颈，而大容量、多级Cache可以很大程度地降低对存储器和总线的带宽要求。所以共享存储器结构往往采用大容量Cache。</p></blockquote><h2 id="分布式共享存储器系统（Distributed-Shared-Memory-DSM）"><a href="#分布式共享存储器系统（Distributed-Shared-Memory-DSM）" class="headerlink" title="分布式共享存储器系统（Distributed Shared-Memory, DSM）"></a>分布式共享存储器系统（Distributed Shared-Memory, DSM）</h2><p>为了支持更多的处理机，存储器不能按照集中共享方式组织，而必须分布于各个处理机。</p><ul><li><p><strong>结构</strong>：由多个独立结构构成（称为<code>节点</code>），每个节点包含处理器、存储器、IO系统，各个节点通过互联网络连接。</p></li><li><p><strong>如何实现共享内存？</strong>物理上分开的多个存储器的地址空间组织成逻辑上共享的地址空间，即在这种机器中，两个不同处理器中相同的物理地址指向一个存储器中的相同位置。实现这一效果需要硬件支持复杂的处理器间数据通信，同时时延也更大。</p></li></ul><p>别称：由于CPU对内存字的访问时间依赖于该内存字在存储器中的存放位置，所以也被称为<u>非一致性内存访问计算机</u>（NonUniform Memory Access, NUMA）</p><blockquote><p>Aside：超节点</p><p>每个节点还可能包含较少数目（2~8）的处理器，这些处理器之间可采用另一种技术（如总线）互联形成簇，这样的节点叫做超节点。这可以视为分布式共享存储和集中式共享存储的混合。</p></blockquote><p>这种将存储器分散到各个节点的结构有两个好处：</p><ol><li>如果大多数的访问是针对本节点的局部存储器，可降低对存储器和互联网络的带宽要求。</li><li>对局部存储器的访问延迟低</li></ol><p>但也有缺点：</p><ol><li>处理器之间的通信较复杂</li><li>各处理器之间访问延迟较大</li></ol><h1 id="四、多计算机系统"><a href="#四、多计算机系统" class="headerlink" title="四、多计算机系统"></a>四、多计算机系统</h1><p>多计算机系统类似于多处理器系统中的分布式共享存储器系统，只不过多处理器的地址空间并没有组织成逻辑上共享的地址空间，或许可以称为<u>分布式非共享存储器系统</u>，这些私有地址空间在逻辑上是分散的。即在这种机器中，两个不同处理器中相同的物理地址分别指向两个不同存储器中的不同位置。</p><p>每个节点本质上是一台独立的计算机</p><h1 id="五、两种通信机制"><a href="#五、两种通信机制" class="headerlink" title="五、两种通信机制"></a>五、两种通信机制</h1><p>前面提到，多处理器和多计算机的最主要区别就是通信机制的不同，多处理器采用共享内存通信机制，多计算机采用消息传递通信机制。</p><h2 id="共享内存通信机制"><a href="#共享内存通信机制" class="headerlink" title="共享内存通信机制"></a>共享内存通信机制</h2><p>由于共享地址空间，可利用Load和Store指令中的地址隐含地进行数据通信。</p><h2 id="消息传递通信机制"><a href="#消息传递通信机制" class="headerlink" title="消息传递通信机制"></a>消息传递通信机制</h2><p>由于有多个地址空间，数据通信要通处理器间显式地传递消息完成。</p><p>同步</p><p>异步</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并行体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（七）</title>
      <link href="/2023/11/23/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2023/11/23/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="gem5附带的默认配置脚本"><a href="#gem5附带的默认配置脚本" class="headerlink" title="gem5附带的默认配置脚本"></a>gem5附带的默认配置脚本</h1><p>本文是对官网教程<a href="https://www.gem5.org/documentation/learning_gem5/part1/example_configs/">gem5: Using the default configuration scripts</a>的整理，主要介绍了</p><p>gem5附带了许多配置脚本，允许用户非常快速地使用gem5。</p><h2 id="1-configs文件夹"><a href="#1-configs文件夹" class="headerlink" title="1. configs文件夹"></a>1. configs文件夹</h2><p>gem5中的全部配置脚本都在<code>configs</code>文件夹中，该文件夹的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">configs/boot:</span><br><span class="line">bbench-gb.rcS  bbench-ics.rcS  hack_back_ckpt.rcS  halt.sh</span><br><span class="line"></span><br><span class="line">configs/common:</span><br><span class="line">Benchmarks.py   Caches.py  cpu2000.py    FileSystemConfig.py  GPUTLBConfig.py   HMC.py       MemConfig.py   Options.py     Simulation.py</span><br><span class="line">CacheConfig.py  cores      CpuConfig.py  FSConfig.py          GPUTLBOptions.py  __init__.py  ObjectList.py  SimpleOpts.py  SysPaths.py</span><br><span class="line"></span><br><span class="line">configs/dist:</span><br><span class="line">sw.py</span><br><span class="line"></span><br><span class="line">configs/dram:</span><br><span class="line">lat_mem_rd.py  low_power_sweep.py  sweep.py</span><br><span class="line"></span><br><span class="line">configs/example:</span><br><span class="line">apu_se.py  etrace_replay.py  garnet_synth_traffic.py  hmctest.py    hsaTopology.py  memtest.py  read_config.py  ruby_direct_test.py      ruby_mem_test.py     sc_main.py</span><br><span class="line">arm        fs.py             hmc_hello.py             hmc_tgen.cfg  memcheck.py     noc_config  riscv           ruby_gpu_random_test.py  ruby_random_test.py  se.py</span><br><span class="line"></span><br><span class="line">configs/learning_gem5:</span><br><span class="line">part1  part2  part3  README</span><br><span class="line"></span><br><span class="line">configs/network:</span><br><span class="line">__init__.py  Network.py</span><br><span class="line"></span><br><span class="line">configs/nvm:</span><br><span class="line">sweep_hybrid.py  sweep.py</span><br><span class="line"></span><br><span class="line">configs/ruby:</span><br><span class="line">AMD_Base_Constructor.py  CHI.py        Garnet_standalone.py  __init__.py              MESI_Three_Level.py  MI_example.py      MOESI_CMP_directory.py  MOESI_hammer.py</span><br><span class="line">CHI_config.py            CntrlBase.py  GPU_VIPER.py          MESI_Three_Level_HTM.py  MESI_Two_Level.py    MOESI_AMD_Base.py  MOESI_CMP_token.py      Ruby.py</span><br><span class="line"></span><br><span class="line">configs/splash2:</span><br><span class="line">cluster.py  run.py</span><br><span class="line"></span><br><span class="line">configs/topologies:</span><br><span class="line">BaseTopology.py  Cluster.py  CrossbarGarnet.py  Crossbar.py  CustomMesh.py  __init__.py  MeshDirCorners_XY.py  Mesh_westfirst.py  Mesh_XY.py  Pt2Pt.py</span><br></pre></td></tr></table></figure><h3 id="boot"><a href="#boot" class="headerlink" title="boot&#x2F;"></a>boot&#x2F;</h3><p>这些是在全系统模式下使用的rcS文件。这些文件在Linux引导后由模拟器加载，并由shell执行。其中大多数用于在全系统模式下运行时控制基准测试。有些是实用函数，如hack_back_ckpt.rcS。在全系统模拟一章中，将更深入地介绍这些文件。</p><h3 id="common"><a href="#common" class="headerlink" title="common&#x2F;"></a>common&#x2F;</h3><p>common目录包含许多用于创建模拟系统的辅助脚本和函数。例如，</p><p><code>Caches.py</code>类似于前几章中创建的Caches.py和Caches_opts.py文件。</p><p><code>Options.py</code>包含可以在命令行上设置的各种选项。比如CPU的数量、系统时钟等等。这是查看要更改的选项是否已经有命令行参数的好地方。</p><p><code>CacheConfig.py</code>包含用于为经典内存系统设置缓存参数的选项和函数。</p><p><code>MemConfig.py</code>提供了一些帮助函数，用于设置内存系统。</p><p><code>FSConfig.py</code>包含为许多不同类型的系统设置全系统仿真所需的功能。全系统仿真将在本章中进一步讨论。</p><p><code>Simulation.py</code>包含许多用于设置和运行gem5的辅助函数。该文件中包含的许多代码管理保存和恢复检查点。下面示例中的示例配置文件使用该文件中的函数来执行gem5模拟。该文件相当复杂，但它也允许在模拟运行方式上有很大的灵活性。</p><h3 id="dram"><a href="#dram" class="headerlink" title="dram&#x2F;"></a>dram&#x2F;</h3><p>包含测试DRAM的脚本。</p><h3 id="example"><a href="#example" class="headerlink" title="example&#x2F;"></a>example&#x2F;</h3><p>此目录包含一些示例 gem5配置脚本，可以使用这些脚本即开即用地运行 gem5。具体来说，se.py 和 fs.py 非常有用。有关这些文件的更多信息可以在下一节中找到。此目录中还有一些其他实用程序配置脚本。</p><h3 id="learning-gem5"><a href="#learning-gem5" class="headerlink" title="learning_gem5&#x2F;"></a>learning_gem5&#x2F;</h3><p>该目录包含learning_gem5书中的所有gem5配置脚本。</p><h3 id="network"><a href="#network" class="headerlink" title="network&#x2F;"></a>network&#x2F;</h3><p>此目录包含HeteroGarnet网络的配置脚本。</p><h3 id="nvm"><a href="#nvm" class="headerlink" title="nvm&#x2F;"></a>nvm&#x2F;</h3><p>此目录包含使用NVM接口的示例脚本。</p><h3 id="ruby"><a href="#ruby" class="headerlink" title="ruby&#x2F;"></a>ruby&#x2F;</h3><p>该目录包含Ruby的配置脚本及其包含的缓存一致性协议。</p><h3 id="splash2"><a href="#splash2" class="headerlink" title="splash2&#x2F;"></a>splash2&#x2F;</h3><p>该目录包含用于运行splash2基准测试套件的脚本，以及用于配置模拟系统的一些选项。</p><h3 id="topologies"><a href="#topologies" class="headerlink" title="topologies&#x2F;"></a>topologies&#x2F;</h3><p>该目录包含在创建Ruby缓存层次结构时可以使用的拓扑的实现。</p><h2 id="2-se-py-fs-py"><a href="#2-se-py-fs-py" class="headerlink" title="2. se.py&amp;fs.py"></a>2. se.py&amp;fs.py</h2><p>SE模式默认配置脚本se.py和FS模式默认配置脚本fs.py均位于目录configs&#x2F;example&#x2F;，下面以se.py为例介绍它们通用的命令行选项：</p><ul><li><p>通过<code>--cmd=</code>选项指定二进制文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/X86/gem5.opt configs/example/se.py --cmd=tests/test-progs/hello/bin/x86/linux/hello</span><br></pre></td></tr></table></figure></li><li><p>默认情况下，两个配置脚本均使用 atomic CPU和 atomic memory accesses，因此没有时间统计数据产生</p><p>可通过<code>--cpu-type=CPU_TYPE</code>指定CPU类型，通过<code>--mem-type=MEM_TYPE</code>指定内存类型。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 默认配置脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pthread学习</title>
      <link href="/2023/11/20/pthread%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/11/20/pthread%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-pthread-exit-函数：终止线程"><a href="#1-pthread-exit-函数：终止线程" class="headerlink" title="1. pthread_exit()函数：终止线程"></a>1. pthread_exit()函数：终止线程</h1><p><a href="https://c.biancheng.net/view/8608.html">pthread_exit()函数：终止线程 (biancheng.net)</a></p><p>线程函数通过pthread_exit函数或return语句返回值。</p><h1 id="2-pthread-join-函数：等待线程执行结束"><a href="#2-pthread-join-函数：等待线程执行结束" class="headerlink" title="2. pthread_join()函数：等待线程执行结束"></a>2. pthread_join()函数：等待线程执行结束</h1><p><a href="https://c.biancheng.net/view/8628.html">pthread_join()函数：等待线程执行结束 (biancheng.net)</a></p><p>主函数通过pthread_join函数获得返回值。无论是采用 return 语句还是调用 pthread_exit() 函数，主线程中的 pthread_join() 函数都可以接收到线程的返回值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pthread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习——鸟哥私房菜</title>
      <link href="/2023/11/13/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E9%B8%9F%E5%93%A5%E7%A7%81%E6%88%BF%E8%8F%9C/"/>
      <url>/2023/11/13/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E9%B8%9F%E5%93%A5%E7%A7%81%E6%88%BF%E8%8F%9C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/1.html">目录及概述 | 鸟哥的 Linux 私房菜：基础学习篇 第四版 (gitbooks.io)</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python import</title>
      <link href="/2023/11/10/Python-import/"/>
      <url>/2023/11/10/Python-import/</url>
      
        <content type="html"><![CDATA[<p>总结下python import的零碎知识</p><h1 id="import的作用"><a href="#import的作用" class="headerlink" title="import的作用"></a>import的作用</h1><p>import语句用来导入其他python文件（称为模块module），使用该模块里定义的类、方法或者变量，从而达到代码复用的目的。</p><h1 id="import-的基本用法："><a href="#import-的基本用法：" class="headerlink" title="import 的基本用法："></a>import 的基本用法：</h1><p><strong>基本概念：</strong></p><ul><li>模块（module）：一般是以.py结尾的python文件，也可以是”.pyo”、”.pyc”、”.pyd”、”.so”、”.dll”结尾的文件。</li></ul><p>模块可以定义函数、类、变量，也能包含可执行的代码。module来源有3种：<br>①Python内置的模块（标准库）；<br>②第三方模块；<br>③自定义模块。</p><ul><li>包（package）：含有Python模块的文件夹</li></ul><h3 id="用法一：import"><a href="#用法一：import" class="headerlink" title="用法一：import []"></a>用法一：import []</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import [module_name\package_name]</span><br></pre></td></tr></table></figure><p>Python会在两个地方寻找这个模块，</p><p>第一是<strong>sys.path</strong>（通过运行代码<code>import sys; print(sys.path)</code>查看），os这个模块所在的目录就在列表sys.path中，一般安装的Python库的目录都可以在sys.path中找到，所以对于安装好的库，我们直接import即可。</p><p>第二个地方就是<strong>运行文件所在的目录</strong>。</p><h3 id="用法二：from-import"><a href="#用法二：from-import" class="headerlink" title="用法二：from [] import []"></a>用法二：from [] import []</h3><p>从包中引入模块的import语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from [module_name\package_name] import [module_name\package_name\method]</span><br></pre></td></tr></table></figure><p>导入一个包的时候，实际上就是导入包里面的<code>__init__.py</code>作为模块</p><h1 id="import的工作原理"><a href="#import的工作原理" class="headerlink" title="import的工作原理"></a>import的工作原理</h1><p>下面解析一下python的导入是如何工作的。假设你导入了一个abc模块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import abc</span><br></pre></td></tr></table></figure><p>python 是如何找到这个模块的呢？</p><ol><li><p>首先，python会在<code>sys.modules</code>中查找这个模块名，<code>sys.modules</code>是先前曾被导入过的所有模块的缓存。简单来说，就是之前被导入过的模块，都被暂时保存在里面。</p></li><li><p>如果在缓存中找不到这个模块，python接下来会在<strong>内置的模块（标准库）</strong>中寻找</p></li><li><p>如果内置模块也找不到，Python将会去<code>sys.path</code> 定义的文件夹列表中搜索，sys.path 中默认的路径为：</p><ul><li>当前目录的路径，自定义的模块就是在这里被找到的。</li><li>环境变量 PYTHONPATH 中指定的路径列表</li><li>Python 安装路径的 lib 目录所在路径</li></ul></li></ol><p>如果以上步骤都找不到这个模块，python会报错ModuleNotFoundError</p><p><a href="https://zhuanlan.zhihu.com/p/87238735">详解 Python import 机制 (一):import 中的基本概念 - 知乎 (zhihu.com)</a></p><h1 id="all-变量暴漏接口"><a href="#all-变量暴漏接口" class="headerlink" title="__all__变量暴漏接口"></a>__all__变量暴漏接口</h1><p><a href="https://blog.csdn.net/zylooooooooong/article/details/115564782">python _<em>all__用法</em>-徐徐图之-的博客-CSDN博客</a></p><h1 id="init-文件"><a href="#init-文件" class="headerlink" title="__init__文件"></a>__init__文件</h1>]]></content>
      
      
      
        <tags>
            
            <tag> python import </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像拼接和全景构造</title>
      <link href="/2023/11/08/%E5%9B%BE%E5%83%8F%E6%8B%BC%E6%8E%A5%E5%92%8C%E5%85%A8%E6%99%AF%E6%9E%84%E9%80%A0/"/>
      <url>/2023/11/08/%E5%9B%BE%E5%83%8F%E6%8B%BC%E6%8E%A5%E5%92%8C%E5%85%A8%E6%99%AF%E6%9E%84%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/learning_tortosie/article/details/85083825">使用OpenCV和Python拼接图像_opencv python 合并图片-CSDN博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RISC-V GNU Toolchain工具链</title>
      <link href="/2023/11/08/RISCV%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
      <url>/2023/11/08/RISCV%E5%B7%A5%E5%85%B7%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、GNU-工具链内容"><a href="#一、GNU-工具链内容" class="headerlink" title="一、GNU 工具链内容"></a>一、GNU 工具链内容</h1><p>工具链包含以下内容：</p><ul><li><strong>gcc（GNU C Compiler）</strong>：编译器</li><li><strong>C运行库</strong>：包括glibc、newlib、musl三种运行库，为C标准库提供函数实现支持，可以根据需求进行自定义修改。</li><li><strong>Binutils</strong>：二进制程序处理工具，包括ar（静态库处理）、as（汇编器）、ld（链接器）等。</li><li><strong>GDB</strong>：用于项目调试。</li><li><strong>DeJaGNU</strong>：程序测试框架，为所有测试提供一个前端支持。</li></ul><h1 id="二、运行时库"><a href="#二、运行时库" class="headerlink" title="二、运行时库"></a>二、运行时库</h1><p>riscv-gnu-toolchain 工具链分为<strong>elf-gcc</strong>和<strong>linux-gnu-gcc</strong>两个版本，以及他们对应的32位和64位版本。两个的主要区别在于：</p><ul><li><strong>elf-gcc</strong>：（riscv32-unknown-elf-*，riscv64-unknown-elf-*）使用的<strong>newlib库(面向嵌入式的C库)<strong>，而且</strong>只支持静态链接</strong>，不支持动态链接。</li><li><strong>linux-gnu-gcc</strong>：（riscv32-unknown-linux-gnu-*，riscv64-unknown-linux-gnu-*）使用的是<strong>glibc标准库</strong>，<strong>支持动态链接</strong>。</li></ul><p>从名字上便可以区分两者的使用场景，如果是编译简单，较小的elf程序，使用elf-gcc版本即可，如果编译比较大的程序或者需要动态库（比如编译linux，或opencv库等），推荐使用linux-gnu-gcc版本。</p><h2 id="newlib"><a href="#newlib" class="headerlink" title="newlib"></a>newlib</h2><p>newlib是redhat社区维护的一个C运行时库，与glibc相比，其最大的特点是代码体积小、可移植性强，特别<strong>适合嵌入式开发环境</strong>。</p><p>例如，newlib重写了printf、scanf、malloc函数，减少调用开销；并默认开启-Os编译开关，对代码体积进行压缩。</p><h2 id="glibc"><a href="#glibc" class="headerlink" title="glibc"></a>glibc</h2><h2 id="musl"><a href="#musl" class="headerlink" title="musl"></a>musl</h2><h1 id="三、Binutils工具介绍"><a href="#三、Binutils工具介绍" class="headerlink" title="三、Binutils工具介绍"></a>三、Binutils工具介绍</h1><ul><li>as：汇编器</li><li>ld：链接器</li><li>ar：生成静态链接库</li><li>ldd：查看一个可执行程序所需要的依赖库</li><li>size：查看一个可执行程序各部分的大小（数据段、代码段等）</li></ul><h1 id="四、构建方式"><a href="#四、构建方式" class="headerlink" title="四、构建方式"></a>四、构建方式</h1><h2 id="Step-1：使用-configure进行配置"><a href="#Step-1：使用-configure进行配置" class="headerlink" title="Step 1：使用.&#x2F;configure进行配置"></a>Step 1：使用.&#x2F;configure进行配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=xxx --with-arch=xxx --with-abi=xxx</span><br></pre></td></tr></table></figure><h3 id="（–march-）选项"><a href="#（–march-）选项" class="headerlink" title="（–march&#x3D;）选项"></a>（–march&#x3D;）选项</h3><p>由于RISC-V的指令集是模块化的指令集，因此在为目标RISC-V平台进行交叉编译之时，需要通过选项指定目标RISC-V平台所支持的模块化指令集组合，该选项为（-march&#x3D;），有效的选项值如下：</p><ul><li>rv32i[m][a][f[d]][c]</li><li>rv32g[c]</li><li>rv64i[m][a][f[d]][c]</li><li>rv64g[c]</li></ul><p>注意：在上述选项中rv32表示目标平台是32位架构，rv64表示目标平台是64位架构，其他i&#x2F;m&#x2F;a&#x2F;f&#x2F;d&#x2F;c&#x2F;g分别代表了RISC-V模块化指令子集的字母简称。</p><h3 id="（–mabi-）选项"><a href="#（–mabi-）选项" class="headerlink" title="（–mabi&#x3D;）选项"></a>（–mabi&#x3D;）选项</h3><p>由于RISC-V的指令集是模块化的指令集，因此在为目标RISC-V平台进行交叉编译之时，需要通过选项指定嵌入式RISC-V目标平台所支持的ABI函数调用规则</p><p>RISC-V定义了两种整数的ABI调用规则和三种浮点ABI调用规则，通过选项（-abi&#x3D;）指明，有效的选项值如下：</p><ul><li>ilp32</li><li>ilp32f</li><li>ilp32d</li><li>lp64</li><li>lp64f</li><li>lp64d</li></ul><p>在上述选项中<strong>两种前缀（ilp32和lp64）</strong>表示的含义如下：</p><ul><li>前缀ilp32表示目标平台是32位架构，在此架构下，C语言的“int”和“long”变量长度为32比特，“long long”变量为64位；</li><li>前缀lp64表示目标平台是64位架构，C语言的“int”变量长度为32比特，而“long”变量长度为64比特。</li></ul><p>上述选项中的<strong>三种后缀类型（无后缀、后缀f、后缀d）</strong>表示的含义如下：</p><ul><li>无后缀：在此架构下，如果使用了浮点类型的操作，直接使用RISC-V浮点指令进行支持。但是当浮点数作为函数参数进行传递之时，无论单精度浮点数还是双精度浮点数均需要通过存储器中的堆栈进行传递。</li><li>f：表示目标平台支持硬件单精度浮点指令。在此架构下，如果使用了浮点类型的操作，直接使用RISC-V浮点指令进行支持。但是当浮点数作为函数参数进行传递之时，单精度浮点数可以直接通过寄存器传递，而双精度浮点数需要通过存储器中的堆栈进行传递。</li><li>d：表示目标平台支持硬件双精度浮点指令。在此架构下，如果使用了浮点类型的操作，直接使用RISC-V浮点指令进行支持。当浮点数作为函数参数进行传递之时，无论单精度还是双精度浮点数都可以直接通过寄存器传递。</li></ul><h2 id="Step-2：使用make命令进行构建"><a href="#Step-2：使用make命令进行构建" class="headerlink" title="Step 2：使用make命令进行构建"></a>Step 2：使用make命令进行构建</h2><p><code>make</code>、<code>make all</code>、<code>make newlib</code> 命令构建使用newlib的elf-gcc</p><p><code>make linux</code> 命令构建使用glibc的linux-gnu-gcc</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h2 id="检查配置"><a href="#检查配置" class="headerlink" title="检查配置"></a>检查配置</h2><p>通过相应gcc的-v命令，可以得到该工具链的配置信息，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ riscv32-unknown-elf-gcc -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=./riscv32-unknown-elf-gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/opt/riscv/libexec/gcc/riscv32-unknown-elf/8.2.0/lto-wrapper</span><br><span class="line">Target: riscv32-unknown-elf</span><br><span class="line">Configured with: /tools/riscv-gnu-toolchain-1/build/../riscv-gcc/configure --target=riscv32-unknown-elf --prefix=/opt/riscv --disable-shared --disable-threads --enable-languages=c,c++ --with-system-zlib --enable-tls --with-newlib --with-sysroot=/opt/riscv/riscv32-unknown-elf --with-native-system-header-dir=/include --disable-libmudflap --disable-libssp --disable-libquadmath --disable-libgomp --disable-nls --src=../../riscv-gcc --enable-checking=yes --disable-multilib --with-abi=ilp32 --with-arch=rv32imc &#x27;CFLAGS_FOR_TARGET=-Os  -mcmodel=medlow&#x27; &#x27;CXXFLAGS_FOR_TARGET=-Os  -mcmodel=medlow&#x27;</span><br><span class="line">Thread model: single</span><br><span class="line">gcc version 8.2.0 (GCC)</span><br></pre></td></tr></table></figure><p>可以看出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--target=riscv32-unknown-elf： 指定工具为riscv32-unknow-elf</span><br><span class="line">--prefix=/opt/riscv32:  指定工具生成的目录</span><br><span class="line">--enable-languages=c,c++：  支持c，c++语言</span><br><span class="line">--with-newlib:  c运行库使用newlib</span><br><span class="line">--with-abi=ilp32： 工具链支持的abi方式是ilp64</span><br><span class="line">--with-arch=rv32imc:  工具链支持的riscv架构是 rv64imc</span><br></pre></td></tr></table></figure><h2 id="常用配置下RISCV工具链配置与编译"><a href="#常用配置下RISCV工具链配置与编译" class="headerlink" title="常用配置下RISCV工具链配置与编译"></a>常用配置下RISCV工具链配置与编译</h2><ol><li><p><strong>riscv32-unknown-elf-gcc</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/opt/riscv32 --with-arch=rv32imc --with-abi=lp32</span><br><span class="line">make </span><br></pre></td></tr></table></figure><p>编译完成后，在&#x2F;opt&#x2F;riscv32&#x2F;bin目录下，有riscv32-unknown-elf-gcc的所有工具。</p></li><li><p><strong>riscv64-unknown-elf-gcc</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/opt/riscv64 --with-arch=rv64imc --with-abi=lp64</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译完成后，在&#x2F;opt&#x2F;riscv64&#x2F;bin目录下，有riscv64-unknown-elf-gcc的所有工具。</p></li><li><p><strong>riscv32-unknown-linux-gnu-gcc</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/opt/riscv32-linux --with-arch=rv32imc --with-abi=lp32 --enable-linux</span><br><span class="line">make linux</span><br></pre></td></tr></table></figure><p>编译完成后，在&#x2F;opt&#x2F;riscv32-linux&#x2F;bin目录下，有riscv32-unknown-linux-gnu-gcc的所有工具。</p></li><li><p><strong>riscv64-unknown-linux-gnu-gcc</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/opt/riscv64-linux --with-arch=rv64imafdc --with-abi=lp64 --enable-linux</span><br><span class="line">make linux</span><br></pre></td></tr></table></figure><p>编译完成后，在&#x2F;opt&#x2F;riscv64-linux&#x2F;bin目录下，有riscv64-unknown-linux-gnu-*的所有工具。</p></li></ol><p><strong>github项目：</strong><a href="https://github.com/riscv-collab/riscv-gnu-toolchain">riscv-collab&#x2F;riscv-gnu-toolchain: GNU toolchain for RISC-V, including GCC (github.com)</a></p><p>**gitee项目:**git clone <a href="https://gitee.com/mirrors/riscv-dejagnu">https://gitee.com/mirrors/riscv-dejagnu</a></p><p>ps：最好用github，它是最新的</p><p>参考博客</p><p><a href="https://blog.csdn.net/weiqi7777/article/details/88045720">riscv各种版本gcc工具链编译与安装_riscv gcc最新版本-CSDN博客</a></p><p><a href="https://huaweicloud.csdn.net/635640d0d3efff3090b5c4b6.html">RISC-V GCC工具链介绍_linux_耐心的小黑-华为云开发者联盟 (csdn.net)</a></p><p>参考视频</p><p><a href="https://www.bilibili.com/video/BV1Vr4y1w7km/?spm_id_from=333.337.search-card.all.click&vd_source=9ac9d125229be9965209fc1d4b24ba46">20201019_RISCV-GNU-Toolchain_陈嘉炜_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> RISCV 工具链sh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chiplet论文阅读—— Methodology for Simulating Multi-chiplet Systems UsingOpen-source Simulators</title>
      <link href="/2023/11/07/A-Methodology-for-Simulating-Multi-chiplet-Systems-Using-Open-source-Simulators/"/>
      <url>/2023/11/07/A-Methodology-for-Simulating-Multi-chiplet-Systems-Using-Open-source-Simulators/</url>
      
        <content type="html"><![CDATA[<h1 id="一、论文总结"><a href="#一、论文总结" class="headerlink" title="一、论文总结"></a>一、论文总结</h1><h1 id="二、摘要"><a href="#二、摘要" class="headerlink" title="二、摘要"></a>二、摘要</h1><p>为了支持早期的Chiplets系统的设计空间探索，提出了一种基于gem5、snipe、gpgpu-sim等开源模拟器的Chiplets架构模拟方法。</p><p>并开源在Github上 <a href="https://github.com/FCAS-SCUT/chiplet_simulators">https://github.com/FCAS-SCUT/chiplet_simulators</a></p><h1 id="三、背景-目前待解决的问题"><a href="#三、背景-目前待解决的问题" class="headerlink" title="三、背景&amp;目前待解决的问题"></a>三、背景&amp;目前待解决的问题</h1><p>Chiplet是后摩尔时代一种很有前途的设计模式，但针对Chiplet的体系结构研究缺乏可靠的模拟器。</p><h2 id="1-Chiplets微架构的设计空间比SoC要大得多，因此需要探索的设计更多"><a href="#1-Chiplets微架构的设计空间比SoC要大得多，因此需要探索的设计更多" class="headerlink" title="1. Chiplets微架构的设计空间比SoC要大得多，因此需要探索的设计更多"></a>1. Chiplets微架构的设计空间比SoC要大得多，因此需要探索的设计更多</h2><p>主要包括<strong>核的组织方式</strong>（128核系统可以分为32cores * 4 chiplets、16cores * 8 chiplets等）、<strong>互联的拓扑结构</strong>、<strong>内存模型</strong></p><h2 id="2-现有开源的模拟器无法直接用于chiplets系统的模拟，因为以下两个原因："><a href="#2-现有开源的模拟器无法直接用于chiplets系统的模拟，因为以下两个原因：" class="headerlink" title="2. 现有开源的模拟器无法直接用于chiplets系统的模拟，因为以下两个原因："></a>2. 现有开源的模拟器无法直接用于chiplets系统的模拟，因为以下两个原因：</h2><ul><li><p>没有精确的Chiplet间互联模型。现有开源模拟器（如gem5、sniper、Graphite、gpgpu-sim）都是纯网络模拟器（network-only simulator），缺乏详细准确的中介层互连延迟和功率模型{❓意思是仅能够精确模拟chiplet内部多核的互联，对chiplet间的互联模拟不精确吗❓}。</p></li><li><p>无法进行大规模并行模拟。Multi-Chiplets系统一般具有大量的核，这样的系统模拟起来会很耗时，因此需要通过大规模的并行来加速模拟。虽然Graphite和sniper支持并行模拟，但并不支持精确的互联建模。</p></li></ul><span id="more"></span><h1 id="四、文章贡献"><a href="#四、文章贡献" class="headerlink" title="四、文章贡献"></a>四、文章贡献</h1><p>文章通过集成和修改开源模拟器，提出了一种模拟Multi-Chiplets系统的方法。</p><ol><li>现有开源模拟器用来模拟单个chiplet，通过多开[reuse]模拟器并行运行实现Multi-Chiplets。并提出模拟器间进程通信和同步协议[a full set of inter-simulator-process communication and synchronization protocol]来模拟chiplets之间的通信。</li><li>基于插入器的互连[Interposer-based interconnection]是使用特定参数精确建模的。互联可以通过<u>仅网络方式[Network Only]</u>、<u>系统调用仿真[SE]</u>、<u>全系统仿真[FS]</u>来模拟。可以容易的实现各种chiplet间和chiplet内的网络拓扑。</li><li>支持两种典型的内存模型：消息传递和共享内存</li><li>提出了一种基于文件的模拟器间进程通信和同步协议，使得多个模拟器进程同步运行，同理可集成其他模拟器。通过时序模型文件[Timing models files]和功能模型文件[Functional models files]支持远程存储器读写。这种通过进程的多开模拟器方法可以很好地实现并行模拟。</li></ol><h1 id="五、Multi-Chiplets系统仿真框架"><a href="#五、Multi-Chiplets系统仿真框架" class="headerlink" title="五、Multi-Chiplets系统仿真框架"></a>五、Multi-Chiplets系统仿真框架</h1><p>此部分对应文章第三章</p><h2 id="3-1-框架总览"><a href="#3-1-框架总览" class="headerlink" title="3.1 框架总览"></a>3.1 框架总览</h2><img src="/2023/11/07/A-Methodology-for-Simulating-Multi-chiplet-Systems-Using-Open-source-Simulators/image-20231107214349591.png" class="" title="image-20231107214349591"><ul><li><strong>电路和物理层[Circuit and physical layer]：</strong></li><li><strong>微体系结构和chiplet内部层 [micro-architectural and intra-chiplet layer]：</strong>每个单独的chiplet由一个模拟器进行模拟，模拟器还用于模拟路由器间的通道</li><li><strong>chiplet间网络层[ inter-chiplet network layer]：</strong>该框架利用集中式网络管理器读取配置文件，以配置chiplet间的网络拓扑</li><li><strong>系统层[system layer]：</strong>通过功能模型文件和时序模型文件来实现共享内存模型和分布式内存模型。<ul><li>功能模型文件：远程读写请求写入每对模拟器进程的功能模型文件。</li><li>时序模型文件：积累远程读写请求的延迟❓用来统计吗❓。</li></ul></li><li><strong>应用层[Application layer]：</strong>该框架在应用层为程序员提供了用于远程读写的API，程序员可以借助此API开发测试程序。在gem5中的FS模式下，这个API使用m5 opt向主机生成时序模型文件和功能模型文件，用于模拟器之间的进程通信。在gem5的SE模式下，这个API系统调用处理程序向主机生成时序和功能模型文件，用于模拟器之间的进程通信。</li></ul><h2 id="3-2-远程读写协议"><a href="#3-2-远程读写协议" class="headerlink" title="3.2 远程读写协议"></a>3.2 远程读写协议</h2><h3 id="（1）远程读-Remote-Read"><a href="#（1）远程读-Remote-Read" class="headerlink" title="（1）远程读 Remote Read"></a>（1）远程读 Remote Read</h3><p>远程读遵从握手协议，即Source Chiplet发送读取请求，Destination Chiplet回复</p><img src="/2023/11/07/A-Methodology-for-Simulating-Multi-chiplet-Systems-Using-Open-source-Simulators/image-20231107220406161.png" class="" title="image-20231107220406161"><p>Source Chiplet有一个计时器，如果收到NACK或计时器超时未收到回复，则重新发送请求。其中，NACK用于模拟传输发生错误。</p><ul><li><p>在Destination Chiplet上，如果根据请求读取数据成功，则其接口节点，用ACK进行回复，它还可以通过回复NACK模拟传输错误</p></li><li><p>其中，接口节点[Interface node]是每个Chiplet中负责Chiplet间通信的一个或多个节点</p></li></ul><h3 id="（2）远程写-Remote-Write"><a href="#（2）远程写-Remote-Write" class="headerlink" title="（2）远程写 Remote Write"></a>（2）远程写 Remote Write</h3><p>远程写是非阻塞的。如果写入成功，则源Chiplet不受影响；若写入失败，则重新发送写请求。</p><p>存在一个缓冲区，用来保存未被确认的写入数据。</p><h3 id="计算远程读请求的传输时间"><a href="#计算远程读请求的传输时间" class="headerlink" title="计算远程读请求的传输时间"></a>计算远程读请求的传输时间</h3><p>为了计算远程读请求的传输时间[transmission time]，Destination Chiplet的接口节点应该添加请求包从Source Chiplet发送过来的传输延迟；Source Chiplet一旦接收到回复，就计算此次请求的往返延迟（请求包和相应包的传输延迟）</p><p>全局内存一致性由软件管理。</p><p>尚未实现多芯片系统实现高速缓存&#x2F;内存一致性协议。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在该系统中存在两种类型的死锁：</p><p>第一种是**路由级死锁[routing level deadlock]<strong>，由数据包的循环依赖性引起。必须使用无死锁路由算法。第二种是</strong>协议级死锁[protocol level deadlock]**，由请求和应答数据包之间的依赖关系引起。</p><h2 id="3-3-模拟器间进程通信和同步协议"><a href="#3-3-模拟器间进程通信和同步协议" class="headerlink" title="3.3 模拟器间进程通信和同步协议"></a>3.3 模拟器间进程通信和同步协议</h2><p>模拟器间进程通信[inter-simulator-process communi-cation]使用两种类型的文件，即<u>功能模型文件</u>和<u>时序模型文件</u>。每个模拟器为其他模拟器产生这两种类型的文件，并读取其他模拟器的这两种文件。</p><p>系统支持两种互联架构：**平铺式网络拓扑[tiled inter-chiplet network topologies]<strong>和</strong>集中式网络拓扑[centralized inter-chiplet network topologies]**，在平铺式网络拓扑中，每个Chiplet有一个用于连接其他Cihplet的互连单元（AMD EPYC采用这样的网络架构）。在集中式网络拓扑中，有一个中心Chiplet，它连接这其他负责计算的Chiplet（AMD Ryzen采用了这样的架构）。</p><p>为了支持互联架构，提出了一种用来模拟中介层网络[ interposer-level network ]的网络管理器[ network manager ]</p><h3 id="使用功能模型文件和时序模型文件进行远程读取的过程："><a href="#使用功能模型文件和时序模型文件进行远程读取的过程：" class="headerlink" title="使用功能模型文件和时序模型文件进行远程读取的过程："></a>使用功能模型文件和时序模型文件进行远程读取的过程：</h3><p><strong>读请求</strong></p><p>Chiplet i 通过API初始化了一个远程读Chiplet j 某个存储地址的请求。</p><ul><li>Step 1：请求线程被stalled</li><li>Step 2：请求包首先被发送到接口节点</li><li>Step 3：接口节点分别生成功能模型文件$$F_{ik}$$和时序模型文件$$T_{iN}$$。其中，$$T_{iN}$$被发送到网络管理器；$$F_{ik}$$执行chiplet间路由。</li><li>Step 4：在到达模拟器k前把该请求包发送给模拟器j</li></ul><img src="/2023/11/07/A-Methodology-for-Simulating-Multi-chiplet-Systems-Using-Open-source-Simulators/image-20231111131252278.png" class="" title="image-20231111131252278"><h1 id="开源仿真器说明书"><a href="#开源仿真器说明书" class="headerlink" title="开源仿真器说明书"></a>开源仿真器说明书</h1><p>摘自<em>基于多芯粒集成的 X86 指令集共享式储存仿真器说明书</em></p><h2 id="一、-简介"><a href="#一、-简介" class="headerlink" title="一、 简介"></a>一、 简介</h2><p>基于多芯粒集成 CPU 共享式储存仿真器是一款用于模拟多芯粒系统中 CPU 芯粒的仿真软件。它的主要功能是：模拟在 CPU 组成的多芯粒系统中，一个操作系统中某个或多个应用程序运行的过程，并给出运行结果以及各项性能指标，如程序的运行时间等。</p><h2 id="二、gem5底层架构"><a href="#二、gem5底层架构" class="headerlink" title="二、gem5底层架构"></a>二、gem5底层架构</h2><h2 id="三、仿真原理"><a href="#三、仿真原理" class="headerlink" title="三、仿真原理"></a>三、仿真原理</h2><p>每个chiplet 拥有自己独一无二的编号和自己的独特的共享储存区域，但是该储存区域可以被任何Chiplet读写。每个共享储存区域以 communication 开头表征，被所有 chiplet 共享。</p><p>当chiplet 需要从其他 chiplet 接收数据时，它会以自身 chiplet 编号对共享储存对应的区域进行检索，当检索到储存中有之前未读且停留在共享储存最久的数据时，它会将其读入自己的储存中，并标记该数据为已读。</p><p><strong>1. 共享储存读操作</strong></p><p>在功能模型上，读操作包括根据 chiplet 编号搜索储存，查找最久的未读数据以及标记本次读入的数据（若没有读入数据则跳过）。在 gem5 中，gadia_receive(a)函数执行读操作，a 表示本次要搜索的 chiplet 编号对应的储存。每次执行该函数时，gem5 将访问communicationa 文件，并读取该文件中最久没有被读取过内容读取完成之后将标记该数据已读并返回该数据，否则返回特定的数字(uint64_t)-1 的值。在时序模型上，读操作的时序由写操作的时序模型一起计算。</p><p><strong>2. 共享储存写操作</strong></p><p>在功能模型上，写操作包括根据 chiplet 的编号查找对应储存地址，写入数据。在gem5 中，gadia_call(a, b, c, d)函数执行写操作，其中 a 为当前 chiplet 编号，b 为数据将要传送的目标 chiplet 编号，c 为数据本身，d 为是否初始化共享储存。当 d 参数不要求初始化共享储存空间时，gem5 将访问文件 communicationb ，并在其内容追加内容 “gem5 当前 cycle a b c \n”。在时序模型上，每次写操作执行时，每个 chiplet 会自动检测当前的 cycle 数并将其一起写入共享储存，在仿真完成之后将交由 popnet 计算出共享储存的读写操作的延迟 cycle数。</p><h2 id="四、仿真器工作流程"><a href="#四、仿真器工作流程" class="headerlink" title="四、仿真器工作流程"></a>四、仿真器工作流程</h2><img src="/2023/11/07/A-Methodology-for-Simulating-Multi-chiplet-Systems-Using-Open-source-Simulators/image-20231111154718789.png" class="" title="image-20231111154718789"><ul><li><strong>Step1</strong> 编写多机版本的负载程序，并编译成二进制文件。</li><li><strong>Step2</strong> 挂载img镜像文件的方式将二进制负载程序放入img文件</li><li><strong>Step3</strong> 启动多个gem5和m5</li><li><strong>Step3</strong> 运行负载程序</li><li><strong>Step4</strong> 编译附录A中的辅助程序，该程序统计共享储存的通信文件并输出 popnet 的输入文件，得到以 bench 开头的 trace 文件</li><li><strong>Step5</strong> 以这些bench 开头的文件为输入，使用 popnet 计算片间通信。</li></ul><p>popnet 是一款开源的互连网络模拟器，能够根据网络节点间的通信记录信息（trace 文件）计算出网络传递数据包的平均延迟以及总能耗。</p><h2 id="五、仿真器使用具体步骤"><a href="#五、仿真器使用具体步骤" class="headerlink" title="五、仿真器使用具体步骤"></a>五、仿真器使用具体步骤</h2><h3 id="1-通过github或gitee下载仿真器源码"><a href="#1-通过github或gitee下载仿真器源码" class="headerlink" title="1. 通过github或gitee下载仿真器源码"></a>1. 通过github或gitee下载仿真器源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Github</span><br><span class="line">git clone https://github.com/FCAS-SCUT/chiplet_simulators</span><br></pre></td></tr></table></figure><h3 id="2-构建X86环境"><a href="#2-构建X86环境" class="headerlink" title="2. 构建X86环境"></a>2. 构建X86环境</h3><p>切换到gem目录下，然后构建环境，运行全系统模拟</p><p>这里使用三个线程并行地构建x86环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scons ./build/X86/gem5.opt -j3</span><br></pre></td></tr></table></figure><h3 id="3-编译测试程序"><a href="#3-编译测试程序" class="headerlink" title="3. 编译测试程序"></a>3. 编译测试程序</h3><p>首先要构建libm5.a静态库</p><p>在</p><h3 id="4-挂载测试程序"><a href="#4-挂载测试程序" class="headerlink" title="4. 挂载测试程序"></a>4. 挂载测试程序</h3><p>benchmark目录下有三个文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">benchmark</span><br><span class="line">- dependency</span><br><span class="line">- gem5</span><br><span class="line">- asm</span><br><span class="line">- generic</span><br><span class="line">- m5ops,h</span><br><span class="line">- m5ops.h</span><br><span class="line">- matrix</span><br><span class="line">- test01.cpp</span><br><span class="line">- treeSearching</span><br><span class="line">- data.csv</span><br><span class="line">- test01.cpp</span><br></pre></td></tr></table></figure><p>其中，dependency文件夹包含了编译测试文件时需要的头文件，然后提供了matrix和treeSearching两个benchmark。</p><p>将parsec.img镜像文件挂载到mnt文件夹中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o loop,offset=1048576 disks/x86-parsec.img ./mnt</span><br></pre></td></tr></table></figure><p>通过cp命令将benchmark二进制文件复制到mnt文件夹</p><p>取消挂载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount ./mnt</span><br></pre></td></tr></table></figure><h3 id="5-开启gem5"><a href="#5-开启gem5" class="headerlink" title="5.开启gem5"></a>5.开启gem5</h3><p>进入gem文件夹，开启gem5的FS模拟</p><p>启动模拟</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">通过gem5提供的fs.py配置脚本进行快速配置，只需要通过命令行参数描述系统的配置。</span><br><span class="line">如下，配置了一个八核、内存为256MB的模拟系统，且输出文件夹为checkpoint_parsec_1</span><br><span class="line">./build/X86/gem5.opt \</span><br><span class="line">-d core8/0 \</span><br><span class="line">./configs/example/fs.py \</span><br><span class="line">--kernel=x86-linux-kernel-4.19.83 \</span><br><span class="line">--disk-image=x86-parsec.img \</span><br><span class="line">--num-cpus=8 \</span><br><span class="line">--mem-size=256MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># fs.py</span><br><span class="line">./build/RISCV/gem5.opt -d RISCVout/0 ./configs/example/fs.py --kernel=$M5_PATH/binaries/riscv-lupio-linux-kernel --disk-image=$M5_PATH/disks/riscv-ubuntu-20.04.img --num-cpus=4 --mem-size=256MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 命令行参数最少只需要指定vmlinux文件，img镜像文件</span><br><span class="line">./build/X86/gem5.opt ./configs/example/fs.py --kernel=[vmlinux 二进制文件] --disk-image=[img 格式的系统镜像文件]</span><br></pre></td></tr></table></figure><p>如果按以下操作把vmlinx和img文件所在的路径添加入环境变量，则可以直接输入文件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">添加环境变量</span><br><span class="line"># 修改bashrc文件以添加环境变量</span><br><span class="line">vim ~/.bashrc</span><br><span class="line"></span><br><span class="line"># 在打开的文件的尾部加入环境变量</span><br><span class="line">export M5_PATH=gem5绝对路径/full-system-image</span><br></pre></td></tr></table></figure><h3 id="6-开启m5"><a href="#6-开启m5" class="headerlink" title="6. 开启m5"></a>6. 开启m5</h3><p>然后在gem&#x2F;util&#x2F;term文件夹中通过m5term打开m5，使其通过命令行与模拟系统连接（首先你应该已经编译并安装了m5term）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m5term localhost &lt;port&gt;</span><br></pre></td></tr></table></figure><p>然后就是漫长的等待，等待模拟系统的初始化</p><p>在模拟系统的命令行中通过<code>m5 checkpoint</code>创建检查点，然后再通过<code>m5 exit</code>退出模拟</p><p>通过检查点恢复模拟系统状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./build/X86/gem5.opt \</span><br><span class="line">-d core8/1 \</span><br><span class="line">./configs/example/fs.py \</span><br><span class="line">--kernel=x86-linux-kernel-4.19.83 \</span><br><span class="line">--disk-image=x86-parsec.img \</span><br><span class="line">--num-cpus=8 \</span><br><span class="line">--mem-size=256MB</span><br><span class="line">-r 1</span><br></pre></td></tr></table></figure><p>.&#x2F;build&#x2F;RISCV&#x2F;gem5.opt -d RISCVout&#x2F;0 .&#x2F;configs&#x2F;example&#x2F;fs.py –kernel&#x3D;$M5_PATH&#x2F;binaries&#x2F;riscv-lupio-linux-kernel –disk-image&#x3D;$M5_PATH&#x2F;disks&#x2F;riscv-lupio-busybox.img –num-cpus&#x3D;4 –mem-size&#x3D;256MB –cpu-type&#x3D;AtomicSimpleCPU</p>]]></content>
      
      
      <categories>
          
          <category> Chiplet论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chiplet </tag>
            
            <tag> 模拟器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc编译器参数</title>
      <link href="/2023/11/07/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%82%E6%95%B0/"/>
      <url>/2023/11/07/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是GCC？"><a href="#一、什么是GCC？" class="headerlink" title="一、什么是GCC？"></a>一、什么是GCC？</h1><p>GCC(GNU Compiler Collection)即GNU编译器套件，属于一种编程语言编译器。其原名也为GCC（GNU C Compiler），虽然缩写一样但是仅可编译C语言，后来经过发展才变成支持编译多语言。GCC的初衷是为GNU操作系统专门编写的一款编译器，原本的GNU是专用于编译C代码，现如今已扩展为可以编译C、C++、Java、Objective-C等多种编程语言的编译器集合了。</p><h1 id="二、GCC、gcc、g-三者有何关系？"><a href="#二、GCC、gcc、g-三者有何关系？" class="headerlink" title="二、GCC、gcc、g++三者有何关系？"></a>二、GCC、gcc、g++三者有何关系？</h1><p><strong>gcc</strong>（GUN C Compiler）是GCC中的c编译器，而**g++**（GUN C++ Compiler）是GCC中的c++编译器。<br>gcc和g++两者都可以编译c和cpp文件，但存在差异。</p><ul><li><p>gcc在编译cpp时语法按照c来编译但默认不能链接到c++的库（gcc默认链接c库，g++默认链接c++库）。</p></li><li><p>g++编译.c和.cpp文件都统一按cpp的语法规则来编译。</p><p>  一般<strong>编译c用gcc</strong>，**编译c++用g++**。</p></li></ul><h1 id="三、GCC编译步骤"><a href="#三、GCC编译步骤" class="headerlink" title="三、GCC编译步骤"></a>三、GCC编译步骤</h1><p>GCC广义上的编译流程可分为以下四个部分：</p><ul><li>预处理（Pre-Processing）</li><li>编译（Compiling）</li><li>汇编（Assembling）</li><li>链接（Linking）</li></ul><h1 id="四、文件类型"><a href="#四、文件类型" class="headerlink" title="四、文件类型"></a>四、文件类型</h1><ul><li>.c&#x2F;.cpp：源文件</li><li>.h：头文件</li><li>.o：编译以后得到的目标文件（<strong>o</strong>bject）</li><li>.a：静态链接库，可看作若干个目标文件的集合</li><li>.so：动态链接库（共享库）</li><li>.d：源文件的依赖关系的完整规则</li></ul><h1 id="五、gcc-参数"><a href="#五、gcc-参数" class="headerlink" title="五、gcc 参数"></a>五、gcc 参数</h1><img src="/2023/11/07/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%82%E6%95%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQmFsYWFhbQ==,size_20,color_FFFFFF,t_70,g_se,x_16.png" class="" title="请添加图片描述"><p><a href="https://blog.csdn.net/qq_42475711/article/details/85224010">浅显易懂的GCC使用教程——初级篇_gcc -ddebug-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_50697073/article/details/123759516?app_version=6.2.2&csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22123759516%22,%22source%22:%22m0_52631482%22%7D&utm_source=app">【精选】gcc的基本使用-CSDN博客</a></p><p><a href="https://blog.csdn.net/wohu1104/article/details/110789570">GCC 编译 C(C++)静态链接库（gcc -L、gcc -l）和动态链接库（gcc -fPIC -shared）的创建和使用_c++ 链接 -l-CSDN博客</a></p><p><a href="https://www.cnblogs.com/alan666/p/8311984.html">gcc -I -L -l区别 - 隔壁王叔叔a - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（六）</title>
      <link href="/2023/11/06/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2023/11/06/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Checkpoints"><a href="#Checkpoints" class="headerlink" title="Checkpoints"></a>Checkpoints</h1><p>官网介绍<a href="https://www.gem5.org/documentation/general_docs/checkpoints/">gem5: Checkpoints</a></p><p>检查点相当于gem5模拟系统的快照。通常来说，创建一个全系统模拟需要大量的时间，但为这个模拟系统创建了检查点之后，可以在下次启动时将模拟系统快速回复至检查点状态，从而节省系统启动时间。</p><p>一旦创建了checkpoint，gem5会在输出目录中增加一个cpt目录（cpt.TICKNUMBER，其中TICKNUMBER为创建此检查点时的Tick值），该目录存储checkpoint相关信息。</p><h2 id="1-创建检查点"><a href="#1-创建检查点" class="headerlink" title="1. 创建检查点"></a>1. 创建检查点</h2><p>有三种创建检查点的方式：</p><ul><li>启动模拟器环境后，在模拟器终端执行<strong>m5 checkpoint命令</strong>，也可以将其包含在运行脚本中。</li><li>专门有一个<strong>伪指令</strong>用于创建检查点，例如可以在应用中创建检查点（还不熟悉）</li><li>python配置脚本（fs.py、ruby_fs.py）中通过<strong>命令行参数</strong>设置检查点。–take-checkpoints选项可以定期储存检查点，–checkpoint-at-end可以在模拟结束创建检查点</li></ul><h2 id="2-恢复检查点"><a href="#2-恢复检查点" class="headerlink" title="2. 恢复检查点"></a>2. 恢复检查点</h2><p>检查点恢复需要在启动系统模拟时设置几个命令行参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">build/X86/gem5.opt -d 指定输出目录 configs/example/fs.py --num-cpus=2 -r 1 --checkpoint-dir=checkpoint目录在指定的输出目录 --restore-with-cpu=O3CPU --cpu-type=O3CPU</span><br><span class="line"></span><br><span class="line">build/X86/gem5.opt  configs/example/fs.py --num-cpus=2 -r 1 --checkpoint-dir=m5out</span><br></pre></td></tr></table></figure><ul><li><strong>–checkpoint-dir</strong>：用于指定使用的checkpoint的cpt文件夹所在路径</li><li><strong>-r</strong>：用于指定使用的checkpoint的序号</li><li><strong>–restore-with-cpu</strong>用于指定恢复时CPU的类型</li></ul><p>启动系统模拟后，再通过m5term接入模拟系统，然后很快就会进入到命令行了。</p><h1 id="m5"><a href="#m5" class="headerlink" title="m5"></a>m5</h1><p>在使用m5时首先要用Scons编译</p><h1 id="修改镜像文件"><a href="#修改镜像文件" class="headerlink" title="修改镜像文件"></a>修改镜像文件</h1><p>在全系统模拟中，运行程序一般比较慢，特别是一些比较大的benchmark，如果在全系统模拟中编译会极慢，因此需要将benchmark在宿主机编译完之后，直接放在镜像文件中，这样就可以开启模拟后直接运行benchmark了。</p><p>然而，镜像文件不可以像文件一样直接操作，必须进行磁盘挂载。在 Linux 中，挂载磁盘是将新的磁盘设备连接到文件系统的过程，使得该磁盘可用于存储和访问文件。简单来说，就是将镜像文件挂载到一个文件夹中，再像文件一样直接操作。</p><p>首先，创建一个文件夹作为挂载点。在disks文件夹中新建文件夹.&#x2F;mnt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ./mnt</span><br></pre></td></tr></table></figure><p>然后，使用mount命令挂载镜像文件到指定挂载点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o loop,offset=1048576 镜像文件 ./mnt</span><br></pre></td></tr></table></figure><p>此时，可以通过df -h命令查看磁盘设备列表，并打开.&#x2F;mnt文件夹可以看到镜像文件的内容。</p><img src="/2023/11/06/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/image-20231107111710727.png" class="" title="image-20231107111710727"><img src="/2023/11/06/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/image-20231107111521636.png" class="" title="image-20231107111521636"><p>将测试文件放入挂载点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp 测试文件 ./mnt</span><br></pre></td></tr></table></figure><p>最后，取消挂载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount ./mnt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MobaXterm通过SSH连接虚拟机</title>
      <link href="/2023/11/04/MobaXterm%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2023/11/04/MobaXterm%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="1-在Ubuntu下安装SSH服务"><a href="#1-在Ubuntu下安装SSH服务" class="headerlink" title="1. 在Ubuntu下安装SSH服务"></a>1. 在Ubuntu下安装SSH服务</h2><p>查看SSH是否启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd status</span><br></pre></td></tr></table></figure><span id="more"></span><p>如果没有安装SSH，会出现以下报错</p><img src="/2023/11/04/MobaXterm%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20231104100420401.png" class="" title="image-20231104100420401"><p>那么需要通过以下命令进行安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure><p>安装完毕后再次查看SSH是否启动，若成功，会出现以下输出</p><img src="/2023/11/04/MobaXterm%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20231104100550221.png" class="" title="image-20231104100550221"><h2 id="2-查看虚拟机ip"><a href="#2-查看虚拟机ip" class="headerlink" title="2. 查看虚拟机ip"></a>2. 查看虚拟机ip</h2><p>通过ifconfig命令查看虚拟机ip</p><img src="/2023/11/04/MobaXterm%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20231104100736596.png" class="" title="image-20231104100736596"><p>可以虚拟机ip为192.168.199.128</p><h2 id="3-通过SSH连接虚拟机"><a href="#3-通过SSH连接虚拟机" class="headerlink" title="3. 通过SSH连接虚拟机"></a>3. 通过SSH连接虚拟机</h2><p>打开MobaXterm，首先进入主页的Session，然后选择SSH，再输入虚拟机IP，最后OK即可连接虚拟机。</p><img src="/2023/11/04/MobaXterm%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20231104101010696.png" class="" title="image-20231104101010696"><p>一般通过SSH连接虚拟机是为了能够在主机和虚拟机之间互传文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> MobaXterm 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（五）</title>
      <link href="/2023/11/02/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2023/11/02/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="FS全系统模拟"><a href="#FS全系统模拟" class="headerlink" title="FS全系统模拟"></a>FS全系统模拟</h1><h2 id="一、构建X86系统"><a href="#一、构建X86系统" class="headerlink" title="一、构建X86系统"></a>一、构建X86系统</h2><p>切换到gem目录下，使用Scons进行构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scons ./build/X86/gem5.opt -j [NumberOfThread]</span><br></pre></td></tr></table></figure><h2 id="二、获取镜像文件和Linux内核文件"><a href="#二、获取镜像文件和Linux内核文件" class="headerlink" title="二、获取镜像文件和Linux内核文件"></a>二、获取镜像文件和Linux内核文件</h2><p> FS模拟会启动Linux操作系统，会模拟系统的所有组件。因此需要给系统配置相应的Linux内核以及磁盘镜像</p><p>img 文件和 vmlinux 文件是 gem5 中启动操作系统所需的两个重要文件。</p><ul><li><strong>磁盘镜像（img 文件）</strong>储存了操作系统的文件系统和应用程序，这些文件是操作系统运行所必需的。操作系统需要文件系统来存储和组织文件，需要应用程序来实现特定功能。</li><li><strong>Linux内核文件（vmlinux 文件）</strong>储存了操作系统的内核代码。内核是操作系统的核心部分，负责管理系统资源和提供基本的服务。如果没有内核，操作系统就无法正常启动和运行。</li></ul><h3 id="1-自动获取脚本"><a href="#1-自动获取脚本" class="headerlink" title="1. 自动获取脚本"></a>1. 自动获取脚本</h3><p>官方教程中使用的img和vmlinux直接来自于gem5资源库（resource repository），直接利用Resource类（<a href="https://www.gem5.org/documentation/general_docs/gem5_resources/">gem5: gem5-resources</a>）下载到本地。Gem5官网提供了通过Resource自动获取img文件和vmlinux文件，并运行全系统模拟的示例脚本，脚本代码在<code>configs/example/gem5_library/</code>目录中。以configs&#x2F;example&#x2F;gem5_library&#x2F;x86-parsec-benchmarks.py为例</p><p>gem5可以通过KVM对仿真进行加速，但有的CPU不支持KVM，查看你的处理器是否支持KVM。可以通过安装sudo apt install qemu-kvm并通过kvm-ok来查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装qemu-kvm</span><br><span class="line">sudo apt install qemu-kvm</span><br><span class="line"># 查看KVM是否安装</span><br><span class="line">kvm-ok</span><br></pre></td></tr></table></figure><p>我的处理器并不支持KVM</p><img src="/2023/11/02/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/image-20231114123822874.png" class="" title="image-20231114123822874"><p>因此只能关闭KVM</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Step1 使用requires进行检查时将kvm_required置为False</span><br><span class="line">requires(</span><br><span class="line">    isa_required=ISA.X86,</span><br><span class="line">    coherence_protocol_required=CoherenceProtocol.MESI_TWO_LEVEL,</span><br><span class="line">    # kvm_required=True,</span><br><span class="line">    kvm_required=False,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Step2 设置处理器时，均使用TIMING处理器</span><br><span class="line">processor = SimpleSwitchableProcessor(</span><br><span class="line">    # starting_core_type=CPUTypes.KVM,</span><br><span class="line">    starting_core_type=CPUTypes.TIMING,</span><br><span class="line">    switch_core_type=CPUTypes.TIMING,</span><br><span class="line">    isa=ISA.X86,</span><br><span class="line">    num_cores=2,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样就可以运行模拟了，使用的benchmark和size可以在该脚本的注释中查看</p><img src="/2023/11/02/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/image-20231114093504398.png" class="" title="image-20231114093504398"><img src="/2023/11/02/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/image-20231114093427885.png" class="" title="image-20231114093427885"><h3 id="2-自己制作img文件"><a href="#2-自己制作img文件" class="headerlink" title="2.自己制作img文件"></a>2.自己制作img文件</h3><h2 id="三、设置环境变量"><a href="#三、设置环境变量" class="headerlink" title="三、设置环境变量"></a>三、设置环境变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改bashrc文件以添加环境变量</span><br><span class="line">vim ~/.bashrc</span><br><span class="line"># 在打开的文件的尾部加入环境变量</span><br><span class="line">export M5_PATH=gem5绝对路径/full-system-image</span><br></pre></td></tr></table></figure><h2 id="四、通过配置文件启动模拟系统"><a href="#四、通过配置文件启动模拟系统" class="headerlink" title="四、通过配置文件启动模拟系统"></a>四、通过配置文件启动模拟系统</h2><p>gem5提供了许多配置文件来配置不同的系统，其中可以由fs.py与命令行参数搭配快速实现不同配置的全系统模拟</p><p>fs.py的各种命令行参数可以通过<code>fs.py -h</code>查看</p><h1 id="m5端"><a href="#m5端" class="headerlink" title="m5端"></a>m5端</h1><h3 id="1-m5介绍"><a href="#1-m5介绍" class="headerlink" title="1. m5介绍"></a>1. m5介绍</h3><h3 id="2-生成m5以及对应的libm5-a库"><a href="#2-生成m5以及对应的libm5-a库" class="headerlink" title="2. 生成m5以及对应的libm5.a库"></a>2. 生成m5以及对应的libm5.a库</h3><p>要在应用程序中使用m5提供的指令，首先需要生成m5以及对应的libm5.a库</p><p>ps: 编译之前好像要确保安装clang，并保证其版本为6-10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Step 1 切换到gem5/util/m5目录</span><br><span class="line"> cd util/m5</span><br><span class="line"># Step 2 编译</span><br><span class="line"> scons build/x86/out/m5</span><br></pre></td></tr></table></figure><p>利用libm5.a库，即可在应用程序中使用libm5.a库中的函数</p><p>编写如下测试程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">########hello_m5.cpp##########</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;gem5/m5ops.h&quot;  //引入m5ops.h库</span><br><span class="line"> </span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    m5_reset_stats(0,0);  //重置模拟统计数据，m5库中实现的函数</span><br><span class="line"> </span><br><span class="line">    printf(&quot;Hello world!\n&quot;);</span><br><span class="line">    </span><br><span class="line">    m5_dump_stats(0,0);  //将模拟统计数据保存，m5库中实现的函数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用g++和库进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">g++ -o hello_m5 hello_m5.cpp -std=c++11 \</span><br><span class="line">-Igem5绝对路径/include \</span><br><span class="line">-Lgem5绝对路径/util/m5/build/x86/out -lm5</span><br><span class="line"></span><br><span class="line">g++ -o hello_m5 hello_m5.cpp -std=c++11 \</span><br><span class="line">-I$GEM5/include \</span><br><span class="line">-L$GEM5/util/m5/build/x86/out -lm5</span><br><span class="line"></span><br><span class="line">g++ -o hello_m5 hello_m5.cpp -std=c++11 \</span><br><span class="line">-I$GEM5/include \</span><br><span class="line">-L$GEM5/include -lm5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后将编译出的可执行文件通过文件挂载的方式存储到img镜像文件中。</p><h3 id="3-启动m5端"><a href="#3-启动m5端" class="headerlink" title="3. 启动m5端"></a>3. 启动m5端</h3><p>启动m5有两种方法，一种是通过系统自带的telnet或者gem5中提供的m5term工具，推荐m5term。</p><h4 id="（1）telnet"><a href="#（1）telnet" class="headerlink" title="（1）telnet"></a>（1）telnet</h4><p>使用不需要额外安装或配置，直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telent &lt;host&gt; &lt;post&gt;</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 3456</span><br><span class="line">// 3456表示用于连接模拟系统的端口号，再gem5模拟中，默认的起始端口号为3456，</span><br><span class="line">// 当后续需要模拟多个系统，端口号需要每次增加1</span><br></pre></td></tr></table></figure><h4 id="（2）m5term"><a href="#（2）m5term" class="headerlink" title="（2）m5term"></a>（2）m5term</h4><p>使用m5前，必须先根据源码构建该工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Step 1 切换到gem5/util/term目录</span><br><span class="line"> cd util/term</span><br><span class="line"># Step 2 编译</span><br><span class="line"> gcc  -o m5term term.c</span><br><span class="line"># Step 3 安装</span><br><span class="line"> sudo install -o root -m 555 m5term /usr/local/bin</span><br></pre></td></tr></table></figure><p>之后，就可以通过与telnet类似的方式启动m5了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m5term &lt;host&gt; &lt;post&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Gem5模拟器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gem5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多级存储层次</title>
      <link href="/2023/10/31/%E5%A4%9A%E7%BA%A7%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1/"/>
      <url>/2023/10/31/%E5%A4%9A%E7%BA%A7%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、多级存储层次"><a href="#一、多级存储层次" class="headerlink" title="一、多级存储层次"></a>一、多级存储层次</h1><p>用多种存储器构成存储层次结构是提高存储系统整体性能的必要方法。</p><h2 id="1-1-为什么需要多级存储层次"><a href="#1-1-为什么需要多级存储层次" class="headerlink" title="1.1 为什么需要多级存储层次"></a>1.1 为什么需要多级存储层次</h2><p>存储器的三个主要指标是<strong>容量</strong>、<strong>速度</strong>和<strong>单位价格</strong>。我们希望设计“容量大、速度快、价格低”的存储系统，例如，大规模应用程序要求存储系统容量大、价格低；然而，存储系统又应该在CPU执行程序时以足够快的素的向CPU提供指令和数据。然而，目前还没有一种存储器技术能满足这三个要求，现有的存储器技术只能满足其中一或两个要求。</p><p>解决这些矛盾的方法，就是采用多种存储器技术，构成多级存储层次。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cache基础知识</title>
      <link href="/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Cache技术"><a href="#一、Cache技术" class="headerlink" title="一、Cache技术"></a>一、Cache技术</h1><p>现代计算机都在CPU和主存之间设置一个高速、小容量的缓冲处理器，称为Cache。Cache的存在填补了CPU和主存在速度上的巨大差距，对于提高整个计算机系统的性能有重要意义，是现代计算系统必不可少的部件，然而，<strong>Cache对程序员是透明的</strong>。</p><p>此外，Cache技术这个此被广泛用于指代利用缓冲技术来实现局部数据再利用的技术。其能够缓解两个部件之间访问数据速度差距较大的问题，在硬盘、网页中都能看见缓冲技术的身影，本文专指CPU与主存之间的Cache。</p><span id="more"></span><h1 id="二、Cache结构"><a href="#二、Cache结构" class="headerlink" title="二、Cache结构"></a>二、Cache结构</h1><h2 id="缓存块"><a href="#缓存块" class="headerlink" title="缓存块"></a>缓存块</h2><p>Cache 和主存间信息的交互<strong>按块来组织</strong>。Cache和主存均被分割为大小相同的块，块大小（blocksize）通常为2的幂次方字节。</p><p>【图一：Cache、内存被分割为块】</p><p>CPU通过访存指令中的主存地址向Cache请求主存数据，该主存地址被分割为两部分：<strong>块地址</strong>和<strong>块内位移</strong></p><img src="/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231031155331776.png" class="" title="内存地址分割为块地址和块内偏移"><p>【图二：主存地址被分割为块地址和块内偏移】</p><p>硬件会<u>根据<strong>块地址</strong>查找该块在Cache中的位置</u>，再<u>通过<strong>块内位移</strong>确定所访问的数据再该块中的位置</u>。</p><h2 id="分离Cache和混合Cache"><a href="#分离Cache和混合Cache" class="headerlink" title="分离Cache和混合Cache"></a>分离Cache和混合Cache</h2><p>混合Cache结构：指令和数据采用一个Cache缓冲。读指令和读写数据<strong>不能并行</strong></p><p>分离Cache结构：指令和数据分别采用一个Cache缓冲，即<u>指令Cache</u>和<u>数据Cache</u>。两个Cache具有独立的读写端口，读指令和读写数据<strong>可以并行</strong>。</p><h1 id="三、Cache工作原理"><a href="#三、Cache工作原理" class="headerlink" title="三、Cache工作原理"></a>三、Cache工作原理</h1><p>在每个存储层次中，都绕不开这四个关键问题：</p><ul><li>映像规则：当把一个块从主存调入Cache时，可以放到哪些位置上？</li><li>查找算法：当所要访问的块在Cache中时，如何找到该块？</li><li>替换算法：当发生失效时，应该替换Cache中的哪一个块？</li><li>写策略：当进行写访问时，应该如何操作？</li></ul><p>下面一一进行探讨：</p><h2 id="（1）映像规则"><a href="#（1）映像规则" class="headerlink" title="（1）映像规则"></a>（1）映像规则</h2><p>当要把一个块从主存调入Cache中时，首先要确定这个块可以放在Cache中的哪些位置上。一般来说，主存的容量远远大于Cache的容量，因此要确定较多的主存块与较少的Cache块之间的对应关系，这就是Cache与主存间的映像规则。主要有以下三种：</p><h3 id="1-直接映像"><a href="#1-直接映像" class="headerlink" title="1. 直接映像"></a>1. 直接映像</h3><p>直接映像（Direct Mapping）是指每个主存块只能被放置到唯一的一个Cache块位置。</p><p>通常采用直接取模的方式进行映像。对于主存的第i块（即块地址为i），设它映像到Cache的第j块（即块地址为j），Cache总共有M块，则对应关系为：<br>$$<br>j &#x3D; i mod M<br>$$</p><h3 id="2-全相联映像"><a href="#2-全相联映像" class="headerlink" title="2. 全相联映像"></a>2. 全相联映像</h3><p>全相联映像（Fully Associative Mapping）是指每个主存块可以被放置到任何一个Cache块位置。</p><h3 id="3-组相联映像"><a href="#3-组相联映像" class="headerlink" title="3. 组相联映像"></a>3. 组相联映像</h3><p>组相联映像（Set Associative Mapping）是指每个主存块可以被放置到Cache中唯一的一个组中的任何一个块位置。</p><p>这里引入了组的概念，Cache被等分为若干个组，每组由若干个块构成。具体地，假设组相联Cache一共有M个块，这M个块被分为G组，则每组有n&#x3D;M&#x2F;G个块，称该映像规则为n路组相联（n-way Set Associative）,直接映像实际上即为1路组相联，全相联即为M路组相联。</p><p>通常也通过直接取模的方法进行组的映像，对于主存的第i块（即块地址为i），设它映像到Cache的第k组，Cache总共有G组，则对应关系为：<br>$$<br>k &#x3D; i mod G<br>$$<br>相联度的高低有利有弊，在实际设计时是一个值得tradeoff的事情。</p><p>相联度越高，Cache空间的利用率越高，块冲突的概率就越低，因此Cache的失效率就越低。但高相联度的查找块过程较复杂，会使Cache的实现复杂度和代价增大，从而降低访问速度。</p><table><thead><tr><th></th><th>利</th><th>弊</th></tr></thead><tbody><tr><td>高相联度</td><td>Cache失效率低</td><td>访问Cache速度慢</td></tr><tr><td>低相联度</td><td>访问Cache速度块</td><td>Cache失效率高</td></tr></tbody></table><h2 id="（2）查找方法"><a href="#（2）查找方法" class="headerlink" title="（2）查找方法"></a>（2）查找方法</h2><p>前面提到，当CPU发送内存地址给Cache后，Cache需要查找该地址所在的主存块当前是否在Cache中，如果在，则命中（Hit），如果不在，则失效（Miss）。主存地址被分为块地址和块内位移，我们需要根据块地址来进行查找。</p><p>无论采取哪种映像规则，多个主存块都可能映像到同一个Cache块的位置，为了区分当前某Cache块位置保存的是哪一个主存块，必须记录唯一标识此主存块的信息，记录这些信息的硬件结构称为<strong>目录表</strong>。目录表共有M项，每个目录项对应于Cache中的一个块，目录项记录了其对应保存的主存块的块地址中除了索引意外的部分，称为标识（tag），每个主存块能唯一地由其标识来确定。此外，每个目录项还有一个有效位，用以指示该项是否有效。</p><p>当要在Cache中查找某一块时，首先根据索引找到块（组）的位置，然后通过查找目录表来确定该块是否在这些位置中的一个。</p><p>查找Cache块的方法基本取决于Cache的映像规则，下面分别进行讨论：</p><h3 id="1-查找直接映像Cache"><a href="#1-查找直接映像Cache" class="headerlink" title="1. 查找直接映像Cache"></a>1. 查找直接映像Cache</h3><p>对于直接映像Cache，其主存块地址被分为tag和块索引，该主存块在Cache中具有唯一位置。因此当CPU访问该主存块时，利用块索引查找到这个位置对应的唯一一个目录项，如果主存地址的tag于该目录项的tag相同，且该目录项有效位为1，则命中；否则失效。</p><img src="/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231031163658464.png" class="" title="直接映像Cache块地址划分"><h3 id="2-查找组相联Cache"><a href="#2-查找组相联Cache" class="headerlink" title="2. 查找组相联Cache"></a>2. 查找组相联Cache</h3><p>对于组相联Cache，其主存地址划分为tag和组索引，该主存块在Cache中具有唯一组别。因此当CPU访问该主存块时，首先通过组索引找到具有该组索引的若干目录项，然后比较这些目录项的tag与主存地址的tag，如果其中有一个目录项的tag与主存地址tag相同，且该目录项有效位为1，则该目录项命中；否则失效。</p><img src="/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231031163555331.png" class="" title="4路组相联"><h3 id="3-查找全相联Cache"><a href="#3-查找全相联Cache" class="headerlink" title="3. 查找全相联Cache"></a>3. 查找全相联Cache</h3><p>对于全相联Cache，其主存块地址即为tag，该主存块可能在Cache的任意位置。当CPU访问该主存块时，该tag需要与Cache中所有块对应的tag比较，若其中有一个块的tag与主存地址的tag相同，且该目录项有效位为1，则该目录项命中；否则失效。</p><img src="/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231031164639343.png" class="" title="全相联"><h2 id="（3）替换算法"><a href="#（3）替换算法" class="headerlink" title="（3）替换算法"></a>（3）替换算法</h2><p>之前说过，无论哪种映像，都会有较多主存块共享一个（或一组）Cache块的位置的情况，所以当一个块要从主存调入Cache时。可能会出现该块所映像的一个（或一组）Cache块位置已经全部被占用的情况。这是需要通过替换算法选择一个块位置来存放这个新调入的块，替换掉这个位置原来的块。</p><ul><li>对于直接映像Cache，每个内存块只映像到一个Cache块位置，因此必定是原来在该位置的块被替换，不存在替换策略。</li><li>对于组相联和全相联Cache，每个内存块映像到一组或全部Cache块，有多个Cache块可能被选择替换掉，则就需要使用合理的替换策略，以<strong>达到尽可能避免替换掉马上就要用的Cache块的目的</strong>。</li></ul><p>主要的替换算法有以下几种：</p><h4 id="1-随机法"><a href="#1-随机法" class="headerlink" title="1. 随机法"></a>1. 随机法</h4><p>顾名思义，随机法在可能被替换的Cache块中随机地选择，<u>以便均匀使用一组中的各个块</u></p><h4 id="2-先进先出法"><a href="#2-先进先出法" class="headerlink" title="2. 先进先出法"></a>2. 先进先出法</h4><p>先进先出法（First In First Out, FIFO）选择最早调入地块作为被替换的块。其很容易实现，但<u>与局部性原理相左</u>，因为最先进入的块很可能马上就要再次使用。</p><h4 id="3-最近最少使用法"><a href="#3-最近最少使用法" class="headerlink" title="3. 最近最少使用法"></a>3. 最近最少使用法</h4><p>最近最少使用法（Least Recently Used, LRU）选择近期最久没有被访问过的块作为被替换的块，它所依据的是<u>局部性原理的推论：如果最近刚使用的块很可能就是马上要再用到的块，那么最久没有被用过的块就是最不可能再被用到的块</u></p><h4 id="4-最不常使用法"><a href="#4-最不常使用法" class="headerlink" title="4. 最不常使用法"></a>4. 最不常使用法</h4><p>最不常使用法（Least Frequently Used, LFU）选择过去一个时间段内访问次数最少的数据块，是<u>最符合局部性原理的算法</u>，但这种算法需要记录一段时间内各块被访问的次数，实现起来代价很大。</p><h2 id="（4）写策略"><a href="#（4）写策略" class="headerlink" title="（4）写策略"></a>（4）写策略</h2><p>相较于读操作，写操作显然更为复杂，因为写会更新数据，改变Cache中数据的状态，而读不会。写策略需要解决以下两个问题：</p><p>如果被写的块不在Cache中（写失效），应该怎样更新？</p><p>如果被写的块在Cache中（写命中），应该只更新Cache，还是同时更新主存中的内容？</p><h3 id="1-对于写失效情况，可以选择是否将响应的块调入Cache"><a href="#1-对于写失效情况，可以选择是否将响应的块调入Cache" class="headerlink" title="1. 对于写失效情况，可以选择是否将响应的块调入Cache"></a>1. 对于写失效情况，可以选择是否将响应的块调入Cache</h3><ul><li><p><strong>按写分配（Write Allocate）</strong>：先把需要写的块从内存调入Cache，然后再进行写操作。</p></li><li><p><strong>不按写分配（No Write Allocate）</strong>：直接写入内存。也称为<strong>绕写（Write Around）</strong>。</p></li></ul><blockquote><p>Aside：理解读&#x2F;写失效</p><p>对于读失效和按写分配写失效，可以将失效分为两个过程：</p><ol><li>从内存中将数据块发送到Cache指定位置</li><li>再次尝试读&#x2F;写，这次必定有效</li></ol></blockquote><h3 id="2-对于写命中或写失效时按写分配，有两种策略来维护Cache与主存的一致性"><a href="#2-对于写命中或写失效时按写分配，有两种策略来维护Cache与主存的一致性" class="headerlink" title="2. 对于写命中或写失效时按写分配，有两种策略来维护Cache与主存的一致性"></a>2. 对于写命中或写失效时按写分配，有两种策略来维护Cache与主存的一致性</h3><ul><li><p><strong>写直达（Write Through）</strong>：把数据写入Cache中相应的块，同时也写入主存中相应的块。也称为<strong>写穿透</strong>。</p></li><li><p><strong>写回（Write Back）</strong>：只把数据写入Cache中相应的块，只有后面在该块被替换时，才会写回内存。</p></li><li><p>按写分配通常与写回搭配；不按写分配通常与写直达搭配。</p></li><li><p>在写回法中，为了减少在替换时块的写回，常采用“脏位”标志，即为每个Cache中的块设置一个脏位（dirty）。当该块第一次被改写时，该块的脏位就会置为1，表示这个Cache块曾经被修改过，如果之后再次被改写，脏位仍为1，如果该块需要被替换回内存，则需要将该块写回内存的对应块中。反之，若该块一次都没有被改写，则不需要写回内存。</p></li><li><p>写回与写直达比较</p><table><thead><tr><th></th><th>优点</th></tr></thead><tbody><tr><td>写回</td><td>1. <strong>速度快</strong>。写操作能以Cache的速度进行       2. <strong>使用存储器带宽小</strong>。多次写只需更新一次</td></tr><tr><td>写直达</td><td>1. <strong>实现简单</strong>  2. <strong>简化了数据一致性问题</strong>。内存中的数据总是最新的</td></tr></tbody></table></li><li><p>在进行写直达时，若写操作中CPU必须等待数据写入内存，则称CPU<strong>写停顿（Write Stall）</strong>，造成性能大量损失。为了缓解该问题，可采用<strong>写缓冲器（Write Buffer）</strong>来减少写停顿的时间，写访问数据一旦进入该缓冲器，CPU就可以继续执行，从而实现延迟隐藏。</p></li></ul><h1 id="四、Cache性能分析"><a href="#四、Cache性能分析" class="headerlink" title="四、Cache性能分析"></a>四、Cache性能分析</h1><h1 id="五、改进Cache性能"><a href="#五、改进Cache性能" class="headerlink" title="五、改进Cache性能"></a>五、改进Cache性能</h1><p>根据公式：<br>$$<br>平均访存时间 &#x3D; 命中时间 + 失效率 * 失效开销<br>$$<br>可以从以下三个方面改进Cache的性能</p><p>（1）降低失效率</p><p>（2）减少失效开销</p><p>（3）减少Cache命中时间</p><p>下面将按这三个方面介绍17种Cache优化技术</p><h2 id="降低失效率"><a href="#降低失效率" class="headerlink" title="降低失效率"></a>降低失效率</h2><h2 id="减少失效开销"><a href="#减少失效开销" class="headerlink" title="减少失效开销"></a>减少失效开销</h2><h2 id="减少Cache命中时间"><a href="#减少Cache命中时间" class="headerlink" title="减少Cache命中时间"></a>减少Cache命中时间</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（四）</title>
      <link href="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本文是官网教程<a href="https://www.gem5.org/documentation/learning_gem5/part2/memoryobject/">gem5: Creating SimObjects in the memory system</a>的学习笔记。</p><p>本节教程是创建一个位于CPU和内存总线之间的阻塞式简单内存对象，主要实现了基本请求的传递。在下一节教程中，会在本节创建的简单内存对象之上增加部分逻辑，使其成为一个非常简单的阻塞单处理器缓存。下图是整个系统的示意图，其中，我们创建的内存对象有两个CPU侧的从端口（slave port）和一个内存总线侧的主端口（master port）。它将实现将请求从CPU传递到内存总线，并将响应从内存总线传递到CPU。</p><span id="more"></span><img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/simple_memobj.png" class="" title="System with a simple memory object which sits between a CPU and the memory bus."><h1 id="一、主从端口"><a href="#一、主从端口" class="headerlink" title="一、主从端口"></a>一、主从端口</h1><p>主端口（master port）和从端口（slave port）是模拟器中创造的概念，用于描述计算机系统中不同组件之间的数据传输关系。在模拟器中用于连接计算机系统中的各种组件。其中，<strong>主端口负责发送请求（send req）、接收响应（recv resp）</strong>；<strong>从端口负责接受请求（recv req）、发送响应（send resp）</strong>，因此，<u>主从端口必须配对使用</u>。</p><p>以本模拟系统为例，memory object有两个CPU侧的从端口，用于接收CPU的请求，并向其返回响应；同时有一个mem bus侧的主接口，用于向mem bus发送请求，并接收其响应。</p><p>这些端口实现三种不同的存储系统模式：</p><ul><li>定时模式（timing mode）。唯一的产生正确模拟结果的模式，最常用。</li><li>原子模式（atomic mode）。</li><li>功能模式（functional mode）。</li></ul><p>其他模式暂时不懂。。。</p><p>三种访存模式介绍<a href="https://blog.csdn.net/qq_45726331/article/details/129651724">【Gem5】gem5模拟器中三种访存模式Atomic、Timing、Functional的总结对比_空空7的博客-CSDN博客</a></p><h1 id="二、数据包"><a href="#二、数据包" class="headerlink" title="二、数据包"></a>二、数据包</h1><p>在gem5中，<strong>端口通过发送数据包（packet）实现交互</strong>。数据包由MemReq组成，MemReq是内存请求对象。MemReq保存初始化包的原始请求的信息，例如请求者、地址和请求类型（读、写等）。数据包还有一个MemCmd，它是数据包的当前命令。此命令可以在数据包的整个生命周期中改变（例如，一旦满足内存命令，请求就变成响应）。最常见的MemCmd是ReadReq（读请求）、ReadResp（读响应）、WriteReq（写请求）、WriteResp（写响应）。还有缓存和许多其他命令类型的写回请求（WritebackDirty、WritebackClean）</p><h1 id="三、主从交互"><a href="#三、主从交互" class="headerlink" title="三、主从交互"></a>三、主从交互</h1><p>在定时模式下，主从端口的交互有以下三种情况，需要理清其函数调用链</p><h2 id="（1）正常情况下的主从交互"><a href="#（1）正常情况下的主从交互" class="headerlink" title="（1）正常情况下的主从交互"></a>（1）正常情况下的主从交互</h2><p>正常情况下，主机通过调用sendTimingReq函数发送请求，从机的recvTimingReq函数也随之被调用，如果从机目前可以接受此请求，则返回true，表示从机已经接受此次请求。从机接受请求后随即开始处理此请求。</p><p>从机处理完请求后，通过调用sendTimingResp函数发送此次请求的响应，类似地，主机的recvTimingResp函数随之被调用，如果主机目前可以接受此响应，则返回true，表示主机已经接受了此次响应。交互结束。</p><img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/master_slave_1.png" class="" title="Simple master-slave interaction when both can accept the request and the response."><h2 id="（2）从机忙时的主从交互"><a href="#（2）从机忙时的主从交互" class="headerlink" title="（2）从机忙时的主从交互"></a>（2）从机忙时的主从交互</h2><p>以上情况是主从都顺利接收的理想情况，但当从机接受请求或主机接受响应时，它们可能正忙。</p><p>下面就是从机忙时主从交互的过程。</p><p>从机忙时，从机无法接受主机发送的请求，因此recvTimingReq函数返回false，拒绝接受此次请求。但当从机结束忙态后，会通过调用sendReqRetry函数通知主机，“邀请”主机再次重试发送请求，主机通过recvReqRetry函数接收重试通知后，随机再次发起新的请求。当然，新请求也可能再次因为从机忙而被拒绝。</p><img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzgxMTM1,size_16,color_FFFFFF,t_70.png" class="" title="交互"><h2 id="（3）主机忙时的主从交互"><a href="#（3）主机忙时的主从交互" class="headerlink" title="（3）主机忙时的主从交互"></a>（3）主机忙时的主从交互</h2><p>类似地，在主机忙时，主机无法接收从机发送的响应，因此recvTimingResp函数返回false，拒绝接收此次响应。但当主机结束忙态后，会通过调用sendRespRetry函数通知从机，“邀请”从机再次重试发送响应，从机通过recvRespRetry函数接收重试通知后，随机再次发起新的响应。</p><img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzgxMTM1,size_16,color_FFFFFF,t_70-169863203577313.png" class="" title="交互"><h1 id="四、SimpleMemobj主从端口函数实现"><a href="#四、SimpleMemobj主从端口函数实现" class="headerlink" title="四、SimpleMemobj主从端口函数实现"></a>四、SimpleMemobj主从端口函数实现</h1><p>在本节的简单内存对象（SimpleMemobj）下定义了两个嵌套类CPUSidePort和MemSidePort，它们分别继承自ResponsePort&#x2F;SlavePort和RequstPort&#x2F;MasterPort，即从端口和主端口。</p><ul><li>SimpleMemobj类的成员变量<ul><li><strong>CPU侧从端口</strong>  CPUSidePort instPort; CPUSidePort dataPort;</li><li><strong>内存总线侧主端口</strong>  MemSidePort memPort; </li><li><strong>阻塞标志</strong> 目前是否正在阻塞等待一个响应 bool blocked;</li></ul></li><li>CPUSidePort类的成员变量<ul><li><strong>父对象指针（即SimpleMemobj对象）</strong> SimpleMemobj *owner;</li><li><strong>是否需要重发</strong> CPU试图发送请求给端口，但被拒绝的情况下，需要记录一下存在这种情况，端口在结束忙态后会通知CPU重发。bool needRetry;</li><li><strong>被阻塞的数据包指针</strong> 该端口试图给CPU发送响应，但被CPU拒绝，需要暂存这个数据包。PacketPtr blockedPacket;</li></ul></li><li>MemSidePort类的成员变量<ul><li><strong>父对象指针（即SimpleMemobj对象）</strong> SimpleMemobj *owner;</li><li><strong>被阻塞的数据包指针</strong> 该端口试图给主存发送请求，但被主存拒绝，需要暂存这个数据包。PacketPtr blockedPacket;</li></ul></li></ul><p>各类的成员函数如下图，其中，加粗函数为必须实现的函数，未加粗的函数为在父类中已经实现的函数。</p><img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/memobj_api.png" class="" title="Interaction between SimpleMemobj and its ports"><p>下面按上图顺序分别对五个函数调用链进行梳理 </p><h2 id="textcolor-RGB-250-106-106-1-获取内存模型的地址范围-CPU-–-Mem-bus"><a href="#textcolor-RGB-250-106-106-1-获取内存模型的地址范围-CPU-–-Mem-bus" class="headerlink" title="$\textcolor[RGB]{250,106,106}{(1)获取内存模型的地址范围         (CPU –&gt; Mem bus)}$"></a>$\textcolor[RGB]{250,106,106}{(1)获取内存模型的地址范围         (CPU –&gt; Mem bus)}$</h2><p>CPU 发送请求，查询内存模型的地址范围，并返回一个 AddrRangeList 类型的值。这种查询请求<strong>不存在阻塞情况</strong>。</p><h3 id="1-SimpleMemobj-CPUSidePort-getAddrRanges"><a href="#1-SimpleMemobj-CPUSidePort-getAddrRanges" class="headerlink" title="1. SimpleMemobj::CPUSidePort::getAddrRanges"></a>1. SimpleMemobj::CPUSidePort::getAddrRanges</h3><p>CPUSidePort直接将请求传递给其父对象SimpleMemobj</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AddrRangeList</span><br><span class="line">SimpleMemobj::CPUSidePort::getAddrRanges() const</span><br><span class="line">&#123;</span><br><span class="line">    return owner-&gt;getAddrRanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SimpleMemobj-getAddrRanges"><a href="#2-SimpleMemobj-getAddrRanges" class="headerlink" title="2. SimpleMemobj::getAddrRanges"></a>2. SimpleMemobj::getAddrRanges</h3><p>SimpleMemobj同样直接将请求传递给其子对象MemSidePort </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AddrRangeList</span><br><span class="line">SimpleMemobj::getAddrRanges() const</span><br><span class="line">&#123;</span><br><span class="line">    DPRINTF(SimpleMemobj, &quot;Sending new ranges\n&quot;);</span><br><span class="line">    // Just use the same ranges as whatever is on the memory side.</span><br><span class="line">    return memPort.getAddrRanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MemSidePort.getAddrRanges()函数已经在MemSidePort的父类RequestPort中被实现了，返回地址范围，可直接使用。</p><h2 id="textcolor-RGB-100-106-255-2-通知内存模型的地址范围发生更改-Mem-bus-–-CPU"><a href="#textcolor-RGB-100-106-255-2-通知内存模型的地址范围发生更改-Mem-bus-–-CPU" class="headerlink" title="$\textcolor[RGB]{100,106,255}{(2)通知内存模型的地址范围发生更改(Mem bus –&gt; CPU)} $"></a>$\textcolor[RGB]{100,106,255}{(2)通知内存模型的地址范围发生更改(Mem bus –&gt; CPU)} $</h2><p>Mem bus发送请求，向CPU通知内存模型的地址范围发生更改，同样此通知也<strong>不会阻塞</strong>。</p><h3 id="1-SimpleMemobj-MemSidePort-recvRangeChange"><a href="#1-SimpleMemobj-MemSidePort-recvRangeChange" class="headerlink" title="1. SimpleMemobj::MemSidePort::recvRangeChange"></a>1. SimpleMemobj::MemSidePort::recvRangeChange</h3><p>MemSidePort 直接将请求传递给其父对象 SimpleMemobj</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::MemSidePort::recvRangeChange()</span><br><span class="line">&#123;</span><br><span class="line">    owner-&gt;sendRangeChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SimpleMemobj-sendRangeChange"><a href="#2-SimpleMemobj-sendRangeChange" class="headerlink" title="2. SimpleMemobj::sendRangeChange"></a>2. SimpleMemobj::sendRangeChange</h3><p>SimpleMemobj同样直接将请求传递给其子对象CPUSidePort</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::sendRangeChange()</span><br><span class="line">&#123;</span><br><span class="line">    instPort.sendRangeChange();</span><br><span class="line">    dataPort.sendRangeChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CPUSidePort.sendRangeChange函数同样已经在CPUSidePort的父类ResponsePort中被实现了，可直接使用。</p><h2 id="textcolor-RGB-250-250-100-3-功能请求与响应-CPU-–-Mem-bus"><a href="#textcolor-RGB-250-250-100-3-功能请求与响应-CPU-–-Mem-bus" class="headerlink" title="$\textcolor[RGB]{250,250,100}{(3)功能请求与响应(CPU –&gt; Mem bus)} $"></a>$\textcolor[RGB]{250,250,100}{(3)功能请求与响应(CPU –&gt; Mem bus)} $</h2><p>功能请求是指不改变系统状态的请求，通常用于读取数据或检查系统状态。同样这种请求也<strong>不会发生阻塞</strong>。</p><p>这个过程的调用链与获取地址范围大致相同，只不过需要传递数据包指针。</p><h3 id="1-SimpleMemobj-CPUSidePort-recvFunctional"><a href="#1-SimpleMemobj-CPUSidePort-recvFunctional" class="headerlink" title="1. SimpleMemobj::CPUSidePort::recvFunctional"></a>1. SimpleMemobj::CPUSidePort::recvFunctional</h3><p>CPUSidePort直接将请求传递给其父对象 SimpleMemobj</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::CPUSidePort::recvFunctional(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Just forward to the memobj.</span><br><span class="line">    return owner-&gt;handleFunctional(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SimpleMemobj-handleFunctional"><a href="#2-SimpleMemobj-handleFunctional" class="headerlink" title="2. SimpleMemobj::handleFunctional"></a>2. SimpleMemobj::handleFunctional</h3><p>SimpleMemobj同样直接将请求传递给其子对象MemSidePort </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::handleFunctional(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Just pass this on to the memory side to handle for now.</span><br><span class="line">    memPort.sendFunctional(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MemSidePort.sendFunctional()函数已经在MemSidePort的父类RequestPort中被实现了，可直接使用。</p><h2 id="textcolor-RGB-250-100-250-4-发送定时请求-CPU-–-Mem-bus"><a href="#textcolor-RGB-250-100-250-4-发送定时请求-CPU-–-Mem-bus" class="headerlink" title="$\textcolor[RGB]{250,100,250}{(4)发送定时请求(CPU –&gt; Mem bus)} $"></a>$\textcolor[RGB]{250,100,250}{(4)发送定时请求(CPU –&gt; Mem bus)} $</h2><p>定时请求是指需要等待一段时间后才能完成的请求，通常用于写入数据或执行耗时操作。由于CPU发送请求时，mem bus可能尚未处理完上一次请求，处于忙态，无法接收此次请求，因此这个过程<strong>可能会发生阻塞</strong>。</p><h3 id="1-SimpleMemobj-CPUSidePort-recvTimingReq"><a href="#1-SimpleMemobj-CPUSidePort-recvTimingReq" class="headerlink" title="1. SimpleMemobj::CPUSidePort::recvTimingReq"></a>1. SimpleMemobj::CPUSidePort::recvTimingReq</h3><p>CPUSidePort尝试通过父对象 SimpleMemobj的handleRequest函数发送定时请求</p><p>如果成功，返回true；</p><p>如果失败，将needRetry置为true并返回false，该请求被阻止，CPU在将来某个时候需要发送一个重试（见SimpleMemobj::CPUSidePort::trySendRetry()函数）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">SimpleMemobj::CPUSidePort::recvTimingReq(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Just forward to the memobj.</span><br><span class="line">    if (!owner-&gt;handleRequest(pkt)) &#123;</span><br><span class="line">        needRetry = true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SimpleMemobj-handleRequest"><a href="#2-SimpleMemobj-handleRequest" class="headerlink" title="2. SimpleMemobj::handleRequest"></a>2. SimpleMemobj::handleRequest</h3><p>来到SimpleMemobj的handleRequest函数。首先检查目前没有在等待响应（被阻塞）</p><p>如果没有被阻塞，则将blocked置为true，即进入阻塞状态，并通过子对象MemSidePort的sendPacket函数发送数据包，并返回true；</p><p>反之如果被阻塞，直接返回false，拒绝此请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">SimpleMemobj::handleRequest(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    if (blocked) &#123;</span><br><span class="line">        // There is currently an outstanding request. Stall.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    DPRINTF(SimpleMemobj, &quot;Got request for addr %#x\n&quot;, pkt-&gt;getAddr());</span><br><span class="line">    </span><br><span class="line">    // This memobj is now blocked waiting for the response to this packet.</span><br><span class="line">    blocked = true;</span><br><span class="line">    </span><br><span class="line">    // Simply forward to the memory port</span><br><span class="line">    memPort.sendPacket(pkt);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-SimpleMemobj-MemSidePort-sendPacket"><a href="#3-SimpleMemobj-MemSidePort-sendPacket" class="headerlink" title="3. SimpleMemobj::MemSidePort::sendPacket"></a>3. SimpleMemobj::MemSidePort::sendPacket</h3><p>MemSidePort的sendPacket会调用sendTimingReq函数（在其父类中定义，可直接使用）发送请求数据包给内存总线。如果发送不成功，则将要发送的数据包指针保存下来，准备重发该数据包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::MemSidePort::sendPacket(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Note: This flow control is very simple since the memobj is blocking.</span><br><span class="line">    panic_if(blockedPacket != nullptr, &quot;Should never try to send if blocked!&quot;);</span><br><span class="line">    </span><br><span class="line">    // If we can&#x27;t send the packet across the port, store it for later.</span><br><span class="line">    if (!sendTimingReq(pkt)) &#123;</span><br><span class="line">        blockedPacket = pkt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-SimpleMemobj-MemSidePort-recvReqRetry"><a href="#4-SimpleMemobj-MemSidePort-recvReqRetry" class="headerlink" title="4. SimpleMemobj::MemSidePort::recvReqRetry"></a>4. SimpleMemobj::MemSidePort::recvReqRetry</h3><p>内存总线结束忙态后，会调用MemSidePort类的recvReqRetry邀请MemSidePort重发之前被阻塞的请求数据包，即重发blockedPacket数据包。注意：在重发前，应该一定会有被阻塞的数据包，否则报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::MemSidePort::recvReqRetry()</span><br><span class="line">&#123;</span><br><span class="line">    // We should have a blocked packet if this function is called.</span><br><span class="line">    assert(blockedPacket != nullptr);</span><br><span class="line"></span><br><span class="line">    // Grab the blocked packet.</span><br><span class="line">    PacketPtr pkt = blockedPacket;</span><br><span class="line">    blockedPacket = nullptr;</span><br><span class="line"></span><br><span class="line">    // Try to resend it. It&#x27;s possible that it fails again.</span><br><span class="line">    sendPacket(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="textcolor-RGB-100-250-250-5-接收定时请求的响应-Mem-bus-–-CPU"><a href="#textcolor-RGB-100-250-250-5-接收定时请求的响应-Mem-bus-–-CPU" class="headerlink" title="$\textcolor[RGB]{100,250,250}{(5)接收定时请求的响应(Mem bus –&gt; CPU)} $"></a>$\textcolor[RGB]{100,250,250}{(5)接收定时请求的响应(Mem bus –&gt; CPU)} $</h2><p>内存总线处理完定时请求后，会向CPU发送该定时请求的响应。类似地，CPU也可能会因为处于忙态而拒绝接收响应，也<strong>可能会存在阻塞</strong></p><h3 id="1-SimpleMemobj-MemSidePort-recvTimingResp"><a href="#1-SimpleMemobj-MemSidePort-recvTimingResp" class="headerlink" title="1. SimpleMemobj::MemSidePort::recvTimingResp"></a>1. SimpleMemobj::MemSidePort::recvTimingResp</h3><p>MemSidePort直接将请求传递给其父对象SimpleMemobj</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">SimpleMemobj::MemSidePort::recvTimingResp(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Just forward to the memobj.</span><br><span class="line">    return owner-&gt;handleResponse(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SimpleMemobj-handleResponse"><a href="#2-SimpleMemobj-handleResponse" class="headerlink" title="2. SimpleMemobj::handleResponse"></a>2. SimpleMemobj::handleResponse</h3><p>SimpleMemobj处理响应时，首先因为收到了响应所以消除阻塞状态，然后根据数据包的属性确定是发送给指令端口还是数据端口。</p><p>结束了阻塞状态以后，会尝试通过trySendRetry()函数让CPU重发未能成功发送的请求（如果有的话）。</p><p>注意：在接收响应时，SimpleMemobj应该一定处于阻塞状态，否则报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">SimpleMemobj::handleResponse(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    assert(blocked);</span><br><span class="line">    DPRINTF(SimpleMemobj, &quot;Got response for addr %#x\n&quot;, pkt-&gt;getAddr());</span><br><span class="line"></span><br><span class="line">    // The packet is now done. We&#x27;re about to put it in the port, no need for</span><br><span class="line">    // this object to continue to stall.</span><br><span class="line">    // We need to free the resource before sending the packet in case the CPU</span><br><span class="line">    // tries to send another request immediately (e.g., in the same callchain).</span><br><span class="line">    blocked = false;</span><br><span class="line"></span><br><span class="line">    // Simply forward to the memory port</span><br><span class="line">    if (pkt-&gt;req-&gt;isInstFetch()) &#123;</span><br><span class="line">        instPort.sendPacket(pkt);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dataPort.sendPacket(pkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // For each of the cpu ports, if it needs to send a retry, it should do it</span><br><span class="line">    // now since this memory object may be unblocked now.</span><br><span class="line">    instPort.trySendRetry();</span><br><span class="line">    dataPort.trySendRetry();</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-SimpleMemobj-CPUSidePort-sendPacket"><a href="#3-SimpleMemobj-CPUSidePort-sendPacket" class="headerlink" title="3. SimpleMemobj::CPUSidePort::sendPacket"></a>3. SimpleMemobj::CPUSidePort::sendPacket</h3><p>CPUSidePort的sendPacket会调用sendTimingReq函数（在其父类中定义，可直接使用）发送响应数据包给CPU。如果发送不成功，则将要发送的数据包指针保存下来，准备重发该数据包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::CPUSidePort::sendPacket(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Note: This flow control is very simple since the memobj is blocking.</span><br><span class="line"></span><br><span class="line">    panic_if(blockedPacket != nullptr, &quot;Should never try to send if blocked!&quot;);</span><br><span class="line"></span><br><span class="line">    // If we can&#x27;t send the packet across the port, store it for later.</span><br><span class="line">    if (!sendTimingResp(pkt)) &#123;</span><br><span class="line">        blockedPacket = pkt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-SimpleMemobj-CPUSidePort-trySendRetry"><a href="#4-SimpleMemobj-CPUSidePort-trySendRetry" class="headerlink" title="4. SimpleMemobj::CPUSidePort::trySendRetry"></a>4. SimpleMemobj::CPUSidePort::trySendRetry</h3><p>尝试让CPU重发未能发送的请求</p><p>如果needRetry为True，则说明之前CPU有未能发送的请求；如果blockedPacket指针为空，说明SimpleMemobj未处于阻塞状态，则可以通过sendRetryReq函数（父类中已经实现，可直接使用）让CPU重发请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::CPUSidePort::trySendRetry()</span><br><span class="line">&#123;</span><br><span class="line">    if (needRetry &amp;&amp; blockedPacket == nullptr) &#123;</span><br><span class="line">        // Only send a retry if the port is now completely free</span><br><span class="line">        needRetry = false;</span><br><span class="line">        DPRINTF(SimpleMemobj, &quot;Sending retry req for %d\n&quot;, id);</span><br><span class="line">        sendRetryReq();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-SimpleMemobj-CPUSidePort-recvRespRetry"><a href="#5-SimpleMemobj-CPUSidePort-recvRespRetry" class="headerlink" title="5. SimpleMemobj::CPUSidePort::recvRespRetry"></a>5. SimpleMemobj::CPUSidePort::recvRespRetry</h3><p>CPU忙态结束以后，会通过调用CPUSidePort类的recvRespRetry函数邀请CPUSidePort重新发送之前被阻塞的响应数据包，即重发blockedPacket数据包。注意：在重发前，应该一定会有被阻塞的数据包，否则报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::CPUSidePort::recvRespRetry()</span><br><span class="line">&#123;</span><br><span class="line">    // We should have a blocked packet if this function is called.</span><br><span class="line">    assert(blockedPacket != nullptr);</span><br><span class="line"></span><br><span class="line">    // Grab the blocked packet.</span><br><span class="line">    PacketPtr pkt = blockedPacket;</span><br><span class="line">    blockedPacket = nullptr;</span><br><span class="line"></span><br><span class="line">    // Try to resend it. It&#x27;s possible that it fails again.</span><br><span class="line">    sendPacket(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、配置脚本"><a href="#五、配置脚本" class="headerlink" title="五、配置脚本"></a>五、配置脚本</h1><p>实例化SimpleMemobj对象，并运行hello world负载的配置脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import m5</span><br><span class="line">from m5.objects import *</span><br><span class="line"></span><br><span class="line">system = System()</span><br><span class="line">system.clk_domain = SrcClockDomain()</span><br><span class="line">system.clk_domain.clock = &#x27;1GHz&#x27;</span><br><span class="line">system.clk_domain.voltage_domain = VoltageDomain()</span><br><span class="line">system.mem_mode = &#x27;timing&#x27;</span><br><span class="line">system.mem_ranges = [AddrRange(&#x27;512MB&#x27;)]</span><br><span class="line"></span><br><span class="line">system.cpu = TimingSimpleCPU()</span><br><span class="line"></span><br><span class="line">system.memobj = SimpleMemobj()</span><br><span class="line"></span><br><span class="line">system.cpu.icache_port = system.memobj.inst_port</span><br><span class="line">system.cpu.dcache_port = system.memobj.data_port</span><br><span class="line"></span><br><span class="line">system.membus = SystemXBar()</span><br><span class="line"></span><br><span class="line">system.memobj.mem_side = system.membus.slave</span><br><span class="line"></span><br><span class="line">system.cpu.createInterruptController()</span><br><span class="line">system.cpu.interrupts[0].pio = system.membus.master</span><br><span class="line">system.cpu.interrupts[0].int_master = system.membus.slave</span><br><span class="line">system.cpu.interrupts[0].int_slave = system.membus.master</span><br><span class="line"></span><br><span class="line">system.mem_ctrl = DDR3_1600_8x8()</span><br><span class="line">system.mem_ctrl.range = system.mem_ranges[0]</span><br><span class="line">system.mem_ctrl.port = system.membus.master</span><br><span class="line"></span><br><span class="line">system.system_port = system.membus.slave</span><br><span class="line"></span><br><span class="line">process = Process()</span><br><span class="line">process.cmd = [&#x27;tests/test-progs/hello/bin/x86/linux/hello&#x27;]</span><br><span class="line">system.cpu.workload = process</span><br><span class="line">system.cpu.createThreads()</span><br><span class="line"></span><br><span class="line">root = Root(full_system = False, system = system)</span><br><span class="line">m5.instantiate()</span><br><span class="line"></span><br><span class="line">print &quot;Beginning simulation!&quot;</span><br><span class="line">exit_event = m5.simulate()</span><br><span class="line">print &#x27;Exiting @ tick %i because %s&#x27; % (m5.curTick(), exit_event.getCause())</span><br></pre></td></tr></table></figure><ol><li>在命令行执行以下命令，可以运行模拟系统</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/X86/gem5.opt configs/learning_gem5/part2/simple_memobj.py</span><br></pre></td></tr></table></figure><p>输出内容出现Hello World则模拟成功。</p><ol start="2"><li>在命令行执行以下命令，可以在debug模式下运行模拟系统，由于输出较多，只输出前五十行。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/X86/gem5.opt --debug-flags=SimpleMemobj configs/learning_gem5/part2/simple_memobj.py | head -n 50</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Beginning simulation!</span><br><span class="line">      0: system.memobj: Got request for addr 0x190</span><br><span class="line">  77000: system.memobj: Got response for addr 0x190</span><br><span class="line">  77000: system.memobj: Got request for addr 0x190</span><br><span class="line"> 126000: system.memobj: Got response for addr 0x190</span><br><span class="line"> 126000: system.memobj: Got request for addr 0x190</span><br><span class="line"> 175000: system.memobj: Got response for addr 0x190</span><br><span class="line"> 175000: system.memobj: Got request for addr 0x94db0</span><br><span class="line"> 238000: system.memobj: Got response for addr 0x94db0</span><br><span class="line"> 238000: system.memobj: Got request for addr 0x190</span><br><span class="line"> 287000: system.memobj: Got response for addr 0x190</span><br><span class="line"> 287000: system.memobj: Got request for addr 0x198</span><br><span class="line"> 336000: system.memobj: Got response for addr 0x198</span><br><span class="line"> 336000: system.memobj: Got request for addr 0x198</span><br><span class="line"> 385000: system.memobj: Got response for addr 0x198</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Gem5模拟器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gem5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理——图片拼接</title>
      <link href="/2023/10/25/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E6%8B%BC%E6%8E%A5/"/>
      <url>/2023/10/25/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E6%8B%BC%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="问题导入"><a href="#问题导入" class="headerlink" title="问题导入"></a>问题导入</h1><p>图片全景拼接</p><p>观察者在同一个点，不是简单的平移旋转，需要运用投射关系（近大远小）</p><h1 id="图像全局变换"><a href="#图像全局变换" class="headerlink" title="图像全局变换"></a>图像全局变换</h1><p>研究对象为二维图像</p><h2 id="1-线性变换"><a href="#1-线性变换" class="headerlink" title="1. 线性变换"></a>1. 线性变换</h2><p>缩放 Scale</p><p>旋转 Rotation</p><p>剪切 Shear</p><p>镜像 mirror</p><p>S &#x3D; 2 * 2矩阵<br>$$<br>S &#x3D; \begin{bmatrix}<br> a &amp; b\<br> c &amp; d<br>\end{bmatrix}<br>$$</p><h2 id="2-仿射变换"><a href="#2-仿射变换" class="headerlink" title="2. 仿射变换"></a>2. 仿射变换</h2><p>仿射变换 &#x3D; 线性变换+平移</p><p>S &#x3D; 3 * 3矩阵<br>$$<br> S &#x3D; \begin{bmatrix} a &amp; b &amp; c\ d &amp; e &amp; f\ 0 &amp; 0 &amp; 1\end{bmatrix}<br>$$<br>6个未知数</p><h2 id="3-投影变换"><a href="#3-投影变换" class="headerlink" title="3. 投影变换"></a>3. 投影变换</h2><p>S &#x3D; 3 * 3矩阵<br>$$<br>S &#x3D; \begin{bmatrix}<br> a &amp; b &amp; c\<br> d &amp; e &amp; f\<br> g &amp; h &amp; 1<br>\end{bmatrix}<br>$$<br>8个未知数，即8个自由度，表示能力最强</p>]]></content>
      
      
      <categories>
          
          <category> 数字图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片拼接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（三）</title>
      <link href="/2023/10/24/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/10/24/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Gem5学习——创建一个简单的SimObject"><a href="#Gem5学习——创建一个简单的SimObject" class="headerlink" title="Gem5学习——创建一个简单的SimObject"></a>Gem5学习——创建一个简单的SimObject</h1><h2 id="一、名词解释"><a href="#一、名词解释" class="headerlink" title="一、名词解释"></a>一、名词解释</h2><ul><li><p>$\textcolor[RGB]{200,50,50}{SimObject}$</p><p>在gem5中，SimObject是一个基础类，用于<strong>创建和管理模拟对象</strong>。</p></li><li><p>$\textcolor[RGB]{200,50,50}{SimObjects}$</p><p>SimObjects是gem5中用于管理模拟对象的组件。通常，gem5中的模拟对象都会继承自SimpleObject类，并且通过SimObjects组件来进行管理。</p></li><li><p>$\textcolor[RGB]{200,50,50}{SimpleObject}$</p><p>SimpleObject是SimObject类的一个派生类，它在SimObject类的基础上增加了一些额外的功能，通常，在gem5中创建新的模拟对象时，都会从SimpleObject类进行派生，以便获得这些基本的功能。</p></li></ul><h2 id="二、创建一个简单的SimObject"><a href="#二、创建一个简单的SimObject" class="headerlink" title="二、创建一个简单的SimObject"></a>二、创建一个简单的SimObject</h2><p>即官网教程创建helloobject<a href="https://www.gem5.org/documentation/learning_gem5/part2/helloobject/">gem5: Creating a very simple SimObject</a></p><p><strong>$\textcolor[RGB]{100,200,50}{Gem5使用了Python和C++两种编程语言混合编程}$</strong></p><p>gem5一方面通过python语言配置模拟器运行的参数和控制模拟过程的脚本，优势在于便于快速阅读和编写配置脚本；另一方面通过C++实现gem5中的各种模型（SimObjects），优势在于C++是一种高性能的编程语言，能够保证其模拟性能。混合编程充分发挥了两种语言的优势。</p>]]></content>
      
      
      <categories>
          
          <category> Gem5模拟器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gem5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（二）</title>
      <link href="/2023/10/24/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/10/24/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="理解gem5的输出"><a href="#理解gem5的输出" class="headerlink" title="理解gem5的输出"></a>理解gem5的输出</h1><p>本文是对官网教程<a href="https://www.gem5.org/documentation/learning_gem5/part1/gem5_stats/">gem5: Understanding gem5 statistics and output</a>的整理，主要介绍了gem5的输出文件</p><p>模拟输出默认存放在<code>m5out</code>文件夹中，也可通过<code>-d dirname</code>命令行选项控制输出文件夹，但注意该选项只能在gem5.opt和配置脚本之间。例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/X86/gem5.opt -d cache_out configs/learning_gem5/part1/two_level.py</span><br></pre></td></tr></table></figure><p>模拟系统会自动在当前文件夹下创建一个cache_out文件夹，并存放所用输出数据</p><p>输出如下</p><h2 id="1-config-ini"><a href="#1-config-ini" class="headerlink" title="1. config.ini"></a>1. config.ini</h2><p>模拟系统的全部配置参数</p><h2 id="2-config-json"><a href="#2-config-json" class="headerlink" title="2. config.json"></a>2. config.json</h2><p>模拟系统的全部配置参数，json文件格式</p><h2 id="3-stats-txt"><a href="#3-stats-txt" class="headerlink" title="3. stats.txt"></a>3. stats.txt</h2><p>模拟过程的数据统计。</p><p>SimObject的每个实例化都有自己的统计信息。模拟结束时，或发出特殊统计转储命令时，所有SimObjects的统计信息的当前状态都会转储到一个文件中。</p><p>统计转储以<del>—————-开始模拟统计—————-</del>开始。如果在gem5执行期间存在多个统计转储，则单个文件中可能存在多个此类转储。这对于长时间运行的应用程序或从检查点恢复时很常见。</p><p>每个统计信息都有一个名称（第一列）、一个值（第二列）和一个描述（最后一列以#开头），后跟统计信息的单位。</p><h4 id="（1）有关执行的一般统计信息："><a href="#（1）有关执行的一般统计信息：" class="headerlink" title="（1）有关执行的一般统计信息："></a>（1）有关执行的一般统计信息：</h4><p>首先，统计信息文件包含有关执行的一般统计信息：</p><p>比如总模拟时间<code>simSeconds</code>，CPU提交的指令数<code>simInsts</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">---------- Begin Simulation Statistics ----------</span><br><span class="line">simSeconds                                   0.000057                       # Number of seconds simulated (Second)</span><br><span class="line">simTicks                                     57467000                       # Number of ticks simulated (Tick)</span><br><span class="line">finalTick                                    57467000                       # Number of ticks from beginning of simulation (restored from checkpoints and never reset) (Tick)</span><br><span class="line">simFreq                                  1000000000000                       # The number of ticks per simulated second ((Tick/Second))</span><br><span class="line">hostSeconds                                      0.03                       # Real time elapsed on the host (Second)</span><br><span class="line">hostTickRate                               2295882330                       # The number of ticks simulated per host second (ticks/s) ((Tick/Second))</span><br><span class="line">hostMemory                                     665792                       # Number of bytes of host memory used (Byte)</span><br><span class="line">simInsts                                         6225                       # Number of instructions simulated (Count)</span><br><span class="line">simOps                                          11204                       # Number of ops (including micro ops) simulated (Count)</span><br><span class="line">hostInstRate                                   247382                       # Simulator instruction rate (inst/s) ((Count/Second))</span><br><span class="line">hostOpRate                                     445086                       # Simulator op (including micro ops) rate (op/s) ((Count/Second))</span><br><span class="line"></span><br><span class="line">---------- Begin Simulation Statistics ----------</span><br><span class="line">simSeconds                                   0.000490                       # Number of seconds simulated (Second)</span><br><span class="line">simTicks                                    490394000                       # Number of ticks simulated (Tick)</span><br><span class="line">finalTick                                   490394000                       # Number of ticks from beginning of simulation (restored from checkpoints and never reset) (Tick)</span><br><span class="line">simFreq                                  1000000000000                       # The number of ticks per simulated second ((Tick/Second))</span><br><span class="line">hostSeconds                                      0.03                       # Real time elapsed on the host (Second)</span><br><span class="line">hostTickRate                              15979964060                       # The number of ticks simulated per host second (ticks/s) ((Tick/Second))</span><br><span class="line">hostMemory                                     657488                       # Number of bytes of host memory used (Byte)</span><br><span class="line">simInsts                                         6225                       # Number of instructions simulated (Count)</span><br><span class="line">simOps                                          11204                       # Number of ops (including micro ops) simulated (Count)</span><br><span class="line">hostInstRate                                   202054                       # Simulator instruction rate (inst/s) ((Count/Second))</span><br><span class="line">hostOpRate                                     363571                       # Simulator op (including micro ops) rate (op/s) ((Count/Second))</span><br></pre></td></tr></table></figure><h4 id="（2）SimObjects的统计信息"><a href="#（2）SimObjects的统计信息" class="headerlink" title="（2）SimObjects的统计信息"></a>（2）SimObjects的统计信息</h4><p>接下来，将打印SimObjects的统计信息，比如CPU、内存控制器等等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">system.clk_domain.clock                          1000                       # Clock period in ticks (Tick)</span><br><span class="line">system.clk_domain.voltage_domain.voltage            1                       # Voltage in Volts (Volt)</span><br><span class="line">system.cpu.numCycles                            58236                       # Number of cpu cycles simulated (Cycle)</span><br><span class="line">system.cpu.numWorkItemsStarted                      0                       # Number of work items this cpu started (Count)</span><br><span class="line">system.cpu.numWorkItemsCompleted                    0                       # Number of work items this cpu completed (Count)</span><br><span class="line">system.cpu.dcache.demandHits::cpu.data           1951                       # number of demand (read+write) hits (Count)</span><br><span class="line">system.cpu.dcache.demandHits::total              1951                       # number of demand (read+write) hits (Count)</span><br><span class="line">system.cpu.dcache.overallHits::cpu.data          1951                       # number of overall hits (Count)</span><br><span class="line">system.cpu.dcache.overallHits::total             1951                       # number of overall hits (Count)</span><br><span class="line">system.cpu.dcache.demandMisses::cpu.data          136                       # number of demand (read+write) misses (Count)</span><br><span class="line">system.cpu.dcache.demandMisses::total             136                       # number of demand (read+write) misses (Count)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">system.mem_ctrl.avgPriority_cpu.inst::samples       228.00                       # Average QoS priority value for accepted requests (Count)</span><br><span class="line">system.mem_ctrl.avgPriority_cpu.data::samples       136.00                       # Average QoS priority value for accepted requests (Count)</span><br><span class="line">system.mem_ctrl.priorityMinLatency       0.000000018750                       # per QoS priority minimum request to response latency (Second)</span><br><span class="line">system.mem_ctrl.priorityMaxLatency       0.000000489500                       # per QoS priority maximum request to response latency (Second)</span><br><span class="line">system.mem_ctrl.numReadWriteTurnArounds             0                       # Number of turnarounds from READ to WRITE (Count)</span><br><span class="line">system.mem_ctrl.numWriteReadTurnArounds             0                       # Number of turnarounds from WRITE to READ (Count)</span><br><span class="line">system.mem_ctrl.numStayReadState                  742                       # Number of times bus staying in READ state (Count)</span><br><span class="line">system.mem_ctrl.numStayWriteState                   0                       # Number of times bus staying in WRITE state (Count)</span><br><span class="line">system.mem_ctrl.readReqs                          364                       # Number of read requests accepted (Count)</span><br><span class="line">system.mem_ctrl.writeReqs                           0                       # Number of write requests accepted (Count)</span><br><span class="line">system.mem_ctrl.readBursts                        364                       # Number of controller read bursts, including those serviced by the write queue (Count)</span><br><span class="line">system.mem_ctrl.writeBursts                         0                       # Number of controller write bursts, including those merged in the write queue (Count)</span><br></pre></td></tr></table></figure><p>安装python的Pydot包之后，当运行gem5进行模拟仿真之后，即可在m5out目录下找到config.pdf之类的配置图,如图1所示。</p><p>还可以通过dot命令将config.dot文件转换成自己需要的格式</p><p>pip install pydot<br>cd m5out<br>dot -Tpng -o config.png config.dot</p><p>RISCV1024核模拟报错</p><img src="/2023/10/24/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/image-20231118163457835.png" class="" title="image-20231118163457835">]]></content>
      
      
      <categories>
          
          <category> Gem5模拟器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gem5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1211-</title>
      <link href="/2023/10/23/1211/"/>
      <url>/2023/10/23/1211/</url>
      
        <content type="html"><![CDATA[<h1 id="12月11日"><a href="#12月11日" class="headerlink" title="12月11日"></a>12月11日</h1><h2 id="1-fs-py代码阅读"><a href="#1-fs-py代码阅读" class="headerlink" title="1. fs.py代码阅读"></a>1. fs.py代码阅读</h2><p>gem5通过python内置的<code>optparse</code>模块添加命令行选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 实例化命令行模块</span><br><span class="line">parser = optparse.OptionParser</span><br><span class="line"># 通过调用configs/common/Options.py模块中的方法添加相应命令行选项</span><br><span class="line">Options.addCommonOptions(parser)   # 添加常用参数。如CPU类型、CPU时钟频率等</span><br><span class="line">Options.addFSOptions(parser)       # 添加FS模拟参数。如使用的内核、镜像文件等</span><br><span class="line"></span><br><span class="line"># 如果命令行参数含有&#x27;--ruby&#x27;，则增加ruby需要的命令行选项</span><br><span class="line">if &#x27;--ruby&#x27; in sys.argv:</span><br><span class="line">    Ruby.define_options(parser)    </span><br><span class="line">    </span><br><span class="line"># 解析参数</span><br><span class="line"># parse_args()返回两个值：</span><br><span class="line"># options, 这是一个对象（optpars.Values)，保存有命令行参数值。只要知道命令行参数名，如file,就可以访问其对应的值：options.file。</span><br><span class="line"># args，一个由positional arguments组成的列表。 </span><br><span class="line">(options, args) = parser.parse_args()</span><br><span class="line"></span><br><span class="line">if args:</span><br><span class="line">    print(&quot;Error: script doesn&#x27;t take any positional arguments&quot;)</span><br><span class="line">    sys.exit(1)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>args 是一个包含所有命令行参数值的命名空间对象。每个命令行参数都成为这个对象的一个属性，可以通过 args.参数名 的形式访问。<br>在 gem5 的上下文中，这意味着 args 包含了模拟器运行所需的所有配置信息，如是否启用 Ruby 模拟、文件系统的配置等。</p><p>以上代码定义了argparse解析器并添加了命令行参数。然后它解析了这些参数，并基于这些参数来设置CPU类和内存类。之后，它构建测试系统，可能还会构建驱动系统，最后创建一个root根对象来启动模拟。</p><p>在gem5中，root是整个模拟环境的最顶层容器，它通常包含了模拟的计算机系统（如处理器、内存、总线等）以及与这些组件连接的所有设备和系统的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">np = options.num_cpus</span><br><span class="line"></span><br><span class="line">test_sys = build_test_system(np)</span><br><span class="line">if len(bm) == 2:</span><br><span class="line">    drive_sys = build_drive_system(np)</span><br><span class="line">    root = makeDualRoot(True, test_sys, drive_sys, options.etherdump)</span><br><span class="line">elif len(bm) == 1 and options.dist:</span><br><span class="line">    # This system is part of a dist-gem5 simulation</span><br><span class="line">    root = makeDistRoot(test_sys,</span><br><span class="line">                        options.dist_rank,</span><br><span class="line">                        options.dist_size,</span><br><span class="line">                        options.dist_server_name,</span><br><span class="line">                        options.dist_server_port,</span><br><span class="line">                        options.dist_sync_repeat,</span><br><span class="line">                        options.dist_sync_start,</span><br><span class="line">                        options.ethernet_linkspeed,</span><br><span class="line">                        options.ethernet_linkdelay,</span><br><span class="line">                        options.etherdump);</span><br><span class="line">elif len(bm) == 1:</span><br><span class="line">    root = Root(full_system=True, system=test_sys)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;Error I don&#x27;t know how to create more than 2 systems.&quot;)</span><br><span class="line">    sys.exit(1)</span><br></pre></td></tr></table></figure><p>在这个脚本中，root对象是在不同条件下被创建的：<br>如果模拟的是一个双系统（dual系统），那么root会通过调用makeDualRoot()函数被创建，这意味着会有两个系统（test_sys和drive_sys）并行运行在模拟中。<br>如果启用了分布式模拟（dist模式），则通过调用makeDistRoot()函数创建root，此时root代表的系统会作为分布式模拟中的一个节点。<br>如果模拟的是单个系统，那么root会简单地通过Root(full_system&#x3D;True, system&#x3D;test_sys)创建，其中test_sys是通过build_test_system()函数构建的测试系统。</p><p><a href="https://blog.csdn.net/qq_34898487/article/details/134318122">https://blog.csdn.net/qq_34898487/article/details/134318122</a></p>]]></content>
      
      
      <categories>
          
          <category> 毕设学习记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SCons</title>
      <link href="/2023/10/23/SCons/"/>
      <url>/2023/10/23/SCons/</url>
      
        <content type="html"><![CDATA[<p>scons是一个Python写的自动化构建工具，使用SConstruct文件进行构建。</p><p>官网：<a href="https://scons.org/">https://scons.org/</a></p><p>Wiki：<a href="https://github.com/SCons/scons/wiki">https://github.com/SCons/scons/wiki</a></p><p>manual page： <a href="https://www.scons.org/doc/HTML/scons-man.html">SCons 4.6.0</a></p><p> SConstruct文件，类似于Make系统中的Makefile文件，这是SCons读取并控制编译构建的输入文件。 SConstruct和Makefile的最大不同是：SConstruct文件是python脚本，这会大大简化构建的过程。</p><p>是从</p><p><strong>Scons函数与构建顺序无关</strong></p><p>   SConstruct有一点和一般python脚本不同，SCons函数的书写调用顺序，并不影响SCons真实的构建顺序，这点和Makefile有点相似。换句话说，当你调用Program构建时（或者其他构建方法），SCons并非在此刻构建可执行文件，相反，这仅仅是告诉SCons你想要获得一个可执行文件的构建结果。举例来说，需要构建hello.c的源文件，SCons也仅仅是获取了构建可执行文件hello和源码hello.c之间的关系。</p><h1 id="一、Scons构建方法"><a href="#一、Scons构建方法" class="headerlink" title="一、Scons构建方法"></a>一、Scons构建方法</h1><h2 id="1-Program构建二进制文件"><a href="#1-Program构建二进制文件" class="headerlink" title="1. Program构建二进制文件"></a>1. Program构建二进制文件</h2><p>如果想构建hello.c程序，新建一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Program(&#x27;hello.c&#x27;)</span><br></pre></td></tr></table></figure><p>在SCons命令行中执行<code>scons</code>命令进行构建，会有scons会执行以下编译命令，默认得到<code>hello</code>二进制可执行文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; scons</span><br><span class="line">scons: Reading SConscript files ...</span><br><span class="line">scons: done reading SConscript files.</span><br><span class="line">scons: Building targets ...</span><br><span class="line">cc -o hello.o -c hello.c</span><br><span class="line">cc -o hello hello.o</span><br><span class="line">scons: done building targets. </span><br></pre></td></tr></table></figure><h3 id="1-1-指定二进制文件名称"><a href="#1-1-指定二进制文件名称" class="headerlink" title="1.1 指定二进制文件名称"></a>1.1 指定二进制文件名称</h3><p>如果想要<strong>指定二进制文件的文件名</strong>，则需要在源文件的前面，指明输出名称即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Program(&#x27;new_hello&#x27;, &#x27;hello.c&#x27;)</span><br></pre></td></tr></table></figure><h3 id="1-2-简化构建输出"><a href="#1-2-简化构建输出" class="headerlink" title="1.2 简化构建输出"></a>1.2 简化构建输出</h3><p>如果想要<strong>简化构建时命令行的输出</strong>，只看实际执行的编译命令，则在构建时使用-Q选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; scons -Q</span><br><span class="line">cc -o hello.o -c hello.c</span><br><span class="line">cc -o new_hello hello.o</span><br></pre></td></tr></table></figure><h3 id="1-3-编译多个源文件"><a href="#1-3-编译多个源文件" class="headerlink" title="1.3 编译多个源文件"></a>1.3 编译多个源文件</h3><p><strong>编译多个源文件</strong>，可以采用列表的方式指定多个源文件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># build hello.c only</span><br><span class="line">Program(&quot;My_hello&quot;, &quot;hello.c&quot;)</span><br><span class="line"></span><br><span class="line"># build hello.c name.c</span><br><span class="line">Program(&quot;My_hello&quot;, [&quot;hello.c&quot;, &quot;name.c&quot;])</span><br><span class="line"></span><br><span class="line"># build all the .c file in the current dir</span><br><span class="line">Program(&quot;My_hello&quot;, Glob(&#x27;*.c&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以用scons内置的Split函数自动分割字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Split function help divide the file string</span><br><span class="line">Program(&#x27;program&#x27;, Split(&#x27;main.c file1.c file2.c&#x27;))</span><br><span class="line"></span><br><span class="line">src_file = Split(&quot;&quot;&quot;&quot; main.c</span><br><span class="line">                      file1.c </span><br><span class="line">                      file2.c&quot;&quot;&quot;)</span><br><span class="line">Program(&#x27;program&#x27;, src_files)</span><br></pre></td></tr></table></figure><h3 id="1-4-关键字参数"><a href="#1-4-关键字参数" class="headerlink" title="1.4 关键字参数"></a>1.4 关键字参数</h3><p>SCons同样支持输入或输出文件的关键字定义。输出文件的关键字是<em>target</em>，输入源文件的关键字是<em>source</em>， 因为关键字已经指明了该参数的含义，因此关键字的顺序不做要求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src_files = Split(&#x27;main.c file1.c file2.c&#x27;)</span><br><span class="line">Program(source=src_files, target=&#x27;program&#x27;)</span><br></pre></td></tr></table></figure><h3 id="1-5-构建多个工程"><a href="#1-5-构建多个工程" class="headerlink" title="1.5  构建多个工程"></a>1.5  构建多个工程</h3><p>用一个SConstruct文件，构建多个工程，最简单的方式是调用Program多次构建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Program(&#x27;foo.c&#x27;)</span><br><span class="line">Program(&#x27;bar&#x27;, [&#x27;bar1.c&#x27;, &#x27;bar2.c&#x27;])</span><br></pre></td></tr></table></figure><h3 id="1-6-多工程编译共享中间文件"><a href="#1-6-多工程编译共享中间文件" class="headerlink" title="1.6 多工程编译共享中间文件"></a>1.6 多工程编译共享中间文件</h3><p>   同一份源码文件对应多个工程，最直接的方式是每个工程都加入该源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Program(Split(<span class="string">&#x27;foo.c common1.c common2.c&#x27;</span>))</span><br><span class="line">Program(<span class="string">&#x27;bar&#x27;</span>, Split(<span class="string">&#x27;bar1.c bar2.c common1.c common2.c&#x27;</span>))</span><br></pre></td></tr></table></figure><p>   当采用这种方式构建时，SCons会意识到common1.c和common2.c的复用，因此会将其仅仅编译一份中间文件，尽管生成的目标文件分别链接到各自的中间文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">% scons -Q</span><br><span class="line">cc -o bar1.o -c bar1.c</span><br><span class="line">cc -o bar2.o -c bar2.c</span><br><span class="line">cc -o common1.o -c common1.c</span><br><span class="line">cc -o common2.o -c common2.c</span><br><span class="line">cc -o bar bar1.o bar2.o common1.o common2.o</span><br><span class="line">cc -o foo.o -c foo.c</span><br><span class="line">cc -o foo foo.o common1.o common2.o</span><br></pre></td></tr></table></figure><h3 id="1-7-清理构建的工程"><a href="#1-7-清理构建的工程" class="headerlink" title="1.7 清理构建的工程"></a>1.7 清理构建的工程</h3><p>采用SCons我们不需要增加特殊的指令在构建后执行清除操作，相反，你可以简单使用-c或者–clean选项，此时SCons会自动删除构建的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; scons</span><br><span class="line">scons: Reading SConscript files ...</span><br><span class="line">scons: done reading SConscript files.</span><br><span class="line">scons: Building targets ...</span><br><span class="line">cc -o hello.o -c hello.c</span><br><span class="line">cc -o hello hello.o</span><br><span class="line">scons: done building targets.</span><br><span class="line"></span><br><span class="line">&gt; scons -c</span><br><span class="line">scons: Reading SConscript files ...</span><br><span class="line">scons: done reading SConscript files.</span><br><span class="line">scons: Cleaning targets ...</span><br><span class="line">Removed hello.o</span><br><span class="line">Removed hello</span><br><span class="line">scons: done cleaning targets.</span><br></pre></td></tr></table></figure><h2 id="2-Object构建中间文件"><a href="#2-Object构建中间文件" class="headerlink" title="2. Object构建中间文件"></a>2. Object构建中间文件</h2><p>Object用于构建中间文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object(<span class="string">&#x27;hello.c&#x27;</span>)</span><br></pre></td></tr></table></figure><p>执行scons命令，去构建整个工程，在LINUX工程中这将会仅仅构建hello.o。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; scons</span><br><span class="line">scons: Reading SConscript files ...</span><br><span class="line">scons: <span class="keyword">done</span> reading SConscript files.</span><br><span class="line">scons: Building targets ...</span><br><span class="line">cc -o hello.o -c hello.c</span><br><span class="line">scons: <span class="keyword">done</span> building targets.</span><br></pre></td></tr></table></figure><h2 id="3-Libary编译库文件"><a href="#3-Libary编译库文件" class="headerlink" title="3. Libary编译库文件"></a>3. Libary编译库文件</h2><p>与Program格式相同</p><h3 id="3-1-全部通过源文件来编译库"><a href="#3-1-全部通过源文件来编译库" class="headerlink" title="3.1 全部通过源文件来编译库"></a>3.1 全部通过<code>源文件</code>来编译库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Library(<span class="string">&#x27;foo&#x27;</span>, [<span class="string">&#x27;f1.c&#x27;</span>, <span class="string">&#x27;f2.c&#x27;</span>, <span class="string">&#x27;f3.c&#x27;</span>])</span><br></pre></td></tr></table></figure><p>SCons会自动根据系统来创建合适的库文件前缀和后缀，因此在Linux系统上，上述示例将会构建以下内容：</p><p>SCons会自动给库文件加入前缀和后缀。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; scons -Q</span><br><span class="line">cc -o f1.o -c f1.c</span><br><span class="line">cc -o f2.o -c f2.c</span><br><span class="line">cc -o f3.o -c f3.c</span><br><span class="line">ar rc libfoo.a f1.o f2.o f3.o</span><br><span class="line">ranlib libfoo.a</span><br></pre></td></tr></table></figure><p>如果不特别指定目标库文件名称，SCons将会从源文件列表中选择第一个作为库文件名称。</p><h3 id="3-2-通过中间文件或源文件和中间文件来编译库"><a href="#3-2-通过中间文件或源文件和中间文件来编译库" class="headerlink" title="3.2 通过中间文件或源文件和中间文件来编译库"></a>3.2 通过<code>中间文件</code>或<code>源文件和中间文件</code>来编译库</h3><p>上述示例介绍了通过源文件列表构建库文件，SCons同样也支持通过中间文件构建，或者源文件和中间文件混在一起构建也可以。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Library(<span class="string">&#x27;foo&#x27;</span>, [<span class="string">&#x27;f1.c&#x27;</span>, <span class="string">&#x27;f2.o&#x27;</span>, <span class="string">&#x27;f3.c&#x27;</span>, <span class="string">&#x27;f4.o&#x27;</span>])</span><br><span class="line">Library(<span class="string">&#x27;foo&#x27;</span>, [<span class="string">&#x27;f1.c&#x27;</span>, <span class="string">&#x27;f2.o&#x27;</span>, <span class="string">&#x27;f3.c&#x27;</span>, <span class="string">&#x27;f4.o&#x27;</span>])</span><br></pre></td></tr></table></figure><p>   同时SCons也会意识到，只有源文件才需要进一步构建成中间文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; scons -Q</span><br><span class="line">cc -o f1.o -c f1.c</span><br><span class="line">cc -o f3.o -c f3.c</span><br><span class="line">ar rc libfoo.a f1.o f2.o f3.o f4.o</span><br><span class="line">ranlib libfoo.a</span><br></pre></td></tr></table></figure><h2 id="4-StaticLibrary编译静态库"><a href="#4-StaticLibrary编译静态库" class="headerlink" title="4. StaticLibrary编译静态库"></a>4. StaticLibrary编译静态库</h2><p> 对于<strong>Library</strong>和<strong>StaticLibrary</strong>，他们完全等价，没有任何区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StaticLibrary(&#x27;foo&#x27;, [&#x27;f1.c&#x27;, &#x27;f2.c&#x27;, &#x27;f3.c&#x27;])</span><br></pre></td></tr></table></figure><h2 id="5-SharedLibrary构建动态库文件"><a href="#5-SharedLibrary构建动态库文件" class="headerlink" title="5. SharedLibrary构建动态库文件"></a>5. SharedLibrary构建动态库文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharedLibrary(&#x27;foo&#x27;, [&#x27;f1.c&#x27;, &#x27;f2.c&#x27;, &#x27;f3.c&#x27;])</span><br></pre></td></tr></table></figure><p>Linux系统上输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; scons -Q</span><br><span class="line">cc -o f1.os -c f1.c</span><br><span class="line">cc -o f2.os -c f2.c</span><br><span class="line">cc -o f3.os -c f3.c</span><br><span class="line">cc -o libfoo.so -shared f1.os f2.os f3.os</span><br></pre></td></tr></table></figure><h1 id="二、链接库文件"><a href="#二、链接库文件" class="headerlink" title="二、链接库文件"></a>二、链接库文件</h1><h2 id="1-LIBS关键字指明库文件"><a href="#1-LIBS关键字指明库文件" class="headerlink" title="1. LIBS关键字指明库文件"></a>1. LIBS关键字指明库文件</h2><p>通过指明<strong>LIBS</strong>变量关键字，来指定需要链接的库文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Library(&#x27;foo&#x27;, [&#x27;f1.c&#x27;, &#x27;f2.c&#x27;, &#x27;f3.c&#x27;])</span><br><span class="line">Program(&#x27;prog.c&#x27;, LIBS=[&#x27;foo&#x27;, &#x27;bar&#x27;], LIBPATH=&#x27;.&#x27;)</span><br></pre></td></tr></table></figure><p>不需要特别声明库文件的前缀（如lib），或者后缀（如.a或.lib），SCons会自动根据系统来查找相关前缀或后缀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; scons -Q</span><br><span class="line">cc -o f1.o -c f1.c</span><br><span class="line">cc -o f2.o -c f2.c</span><br><span class="line">cc -o f3.o -c f3.c</span><br><span class="line">ar rc libfoo.a f1.o f2.o f3.o</span><br><span class="line">ranlib libfoo.a</span><br><span class="line">cc -o prog.o -c prog.c</span><br><span class="line">cc -o prog prog.o -L. -lfoo -lbar</span><br></pre></td></tr></table></figure><h2 id="2-LIBPATH关键字指明库文件的查找路径"><a href="#2-LIBPATH关键字指明库文件的查找路径" class="headerlink" title="2.LIBPATH关键字指明库文件的查找路径"></a>2.LIBPATH关键字指明库文件的查找路径</h2><p>通过指明<strong>LIBPATH</strong>变量关键字，来指定库文件的查找路径</p><p>默认情况下，连接器只会在系统路径中查找库文件，SCons可以通过用户指定的LIBPATH变量，来查找用户定义路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Program(<span class="string">&#x27;prog.c&#x27;</span>, LIBS = <span class="string">&#x27;m&#x27;</span>,</span><br><span class="line">                  LIBPATH = [<span class="string">&#x27;/usr/lib&#x27;</span>, <span class="string">&#x27;usr/local/lib&#x27;</span>])</span><br></pre></td></tr></table></figure><p>Linux 中输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; scons -Q</span><br><span class="line">cc -o prog.o -c prog.c</span><br><span class="line">cc -o prog prog.o -L/usr/lib -L/usr/local/lib -lm</span><br></pre></td></tr></table></figure><p>这里推荐使用python的列表（list），因为python是跨平台的，这要迁移起来比较方便。当然您也可以将搜索路径放到一个字符串中，采用系统指定的分割符分开，如POSIX系统中采用冒号，Windows系统中采用分号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># POSIX</span></span><br><span class="line">LIBPATH = <span class="string">&#x27;/usr/lib:/usr/local/lib&#x27;</span></span><br><span class="line"><span class="comment"># Windows</span></span><br><span class="line">LIBPATH = <span class="string">&#x27;C:\\lib;D:\\lib&#x27;</span>  </span><br></pre></td></tr></table></figure><p>python在Windows路径中要求采用<strong>反斜杠</strong>转义符</p><h1 id="三、节点对象"><a href="#三、节点对象" class="headerlink" title="三、节点对象"></a>三、节点对象</h1><p>在SCons内部，所有的文件和路径都被看作是节点（<em>Nodes</em>），这种方式让SConscript脚本更加便于<strong>迁移</strong>和<strong>阅读</strong>。</p><h2 id="1-跨平台时出现的问题"><a href="#1-跨平台时出现的问题" class="headerlink" title="1. 跨平台时出现的问题"></a>1. 跨平台时出现的问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object(&#x27;hello.c&#x27;, CCFLAGS=&#x27;-DHELLO&#x27;)</span><br><span class="line">Object(&#x27;goodbye.c&#x27;, CCFLAGS=&#x27;-DGOODBYE&#x27;)</span><br><span class="line">Program([&#x27;hello.o&#x27;, &#x27;goodbye.o&#x27;])</span><br></pre></td></tr></table></figure><p>以上代码在linux上是可以正常编译的，但在windows上不可以，因为在Windows平台上，生成的中间文件是hello.obj和goodbye.obj，而非hello.o和goodby.o。</p><p>较好的处理方式是将<strong>Object</strong>的构建输出存入变量中，这样我们可以不断在列表后追加新的内容，将其作为<strong>Program</strong>的输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello_list = Object(&#x27;hello.c&#x27;, CCFLAGS=&#x27;-DHELLO&#x27;)</span><br><span class="line">goodbye_list = Object(&#x27;goodbye.c&#x27;, CCFLAGS=&#x27;-DGOODBYE&#x27;)</span><br><span class="line">Program(hello_list + goodbye_list)</span><br></pre></td></tr></table></figure><p>这样SConstruct脚本的跨平台性可以得到保证，其在Linux平台输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; scons -Q</span><br><span class="line">cc -o goodbye.o -c -DGOODBYE goodbye.c</span><br><span class="line">cc -o hello.o -c -DHELLO hello.c</span><br><span class="line">cc -o hello hello.o goodbye.o</span><br></pre></td></tr></table></figure><p>   Windows平台输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;scons -Q</span><br><span class="line">cl /Fogoodbye.obj /c goodbye.c -DGOODBYE</span><br><span class="line">cl /Fohello.obj /c hello.c -DHELLO</span><br><span class="line"><span class="built_in">link</span> /nologo /OUT:hello.exe hello.obj goodbye.obj</span><br><span class="line">embedManifestExeCheck(target, <span class="built_in">source</span>, <span class="built_in">env</span>)</span><br></pre></td></tr></table></figure><h2 id="2-构建方法返回目标节点列表"><a href="#2-构建方法返回目标节点列表" class="headerlink" title="2. 构建方法返回目标节点列表"></a>2. 构建方法返回目标节点列表</h2><p>所有的构建方法返回一个节点对象列表，这些节点可以被用作其他构建方法的参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object_list = Object(&#x27;hello.c&#x27;)</span><br><span class="line">program_list = Program(object_list)</span><br><span class="line">print(type(object_list))</span><br><span class="line">print(object_list)</span><br></pre></td></tr></table></figure><p>linux平台输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; scons -Q</span><br><span class="line">&lt;class &#x27;SCons.Node.NodeList&#x27;&gt;</span><br><span class="line">[&#x27;hello.o&#x27;]</span><br><span class="line">The object file is: hello.o</span><br><span class="line">The program file is: hello</span><br></pre></td></tr></table></figure><h2 id="3-File创建文件节点-Dir创建路径节点"><a href="#3-File创建文件节点-Dir创建路径节点" class="headerlink" title="3. File创建文件节点 &amp; Dir创建路径节点"></a>3. File创建文件节点 &amp; Dir创建路径节点</h2><p>SCons明确了文件节点和路径节点的不同，SCons支持<strong>File</strong> 和<strong>Dir</strong>两个函数，用于返回文件和路径节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello_c = File(&#x27;hello.c&#x27;)</span><br><span class="line">Program(hello_c)</span><br><span class="line"></span><br><span class="line">classes = Dir(&#x27;classes&#x27;)</span><br><span class="line">Java(classes, &#x27;src&#x27;)</span><br></pre></td></tr></table></figure><p>通常情况下，您不需要手动调用File或Dir，因为调用构建方法时，会自动将输入作为文件或目录的名称，并将其转换为一个Node对象。</p><p>有时对象可能是文件也可能是一个路径，此时SCons提供了一个<strong>Entry</strong>函数，用于返回一个文件节点或者路径节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xyzzy = Entry(&#x27;xyzzy&#x27;)</span><br></pre></td></tr></table></figure><h2 id="4-打印节点对象名称"><a href="#4-打印节点对象名称" class="headerlink" title="4. 打印节点对象名称"></a>4. 打印节点对象名称</h2><p>大多数情况下我们需要调用节点去打印其内部的文件名称，但是请注意<strong>此时的对象是节点列表，而非文件对象</strong>，因此打印的时候需要增加<strong>下标访问</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object_list = Object(<span class="string">&#x27;hello.c&#x27;</span>)</span><br><span class="line">program_list = Program(object_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The object file is: %s&quot;</span>%object_list[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The program file is: %s&quot;</span>%program_list[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>   在Linux系统输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; scons -Q</span><br><span class="line">The object files is: hello.o</span><br><span class="line">The program file is: hello</span><br><span class="line">cc - o hello.o -c hello.c</span><br><span class="line">cc -o hello hello.o</span><br></pre></td></tr></table></figure><p>在上面的示例中，object_list[0]从列表中提取了一个实际的Node对象，Python的print语句将该对象转换为要打印的字符串。</p><h2 id="5-节点对象转换为字符串"><a href="#5-节点对象转换为字符串" class="headerlink" title="5. 节点对象转换为字符串"></a>5. 节点对象转换为字符串</h2><p>如上节介绍所示，我们可以直接打印节点的文件信息，但是如果您想得到一个节点字符串，而非列表，则可以通过python内置的<strong><em>str</em>函数</strong>实现。举例而言，如果您希望使用Python的<em>os.path.exists</em>来确认文件是否存在，您可以采用如下方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line">program_list = Program(<span class="string">&#x27;hello.c&#x27;</span>)</span><br><span class="line">program_name = <span class="built_in">str</span>(program_list[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(program_name):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s doses not exist!&quot;</span>%program_name)</span><br></pre></td></tr></table></figure><p>   此时，在Linux系统中将会得到如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; scons -Q</span><br><span class="line">hello does not exist!</span><br><span class="line">cc -o hello.o -c hello.c</span><br><span class="line">cc - o hello hello.o</span><br></pre></td></tr></table></figure><h1 id="四、判断是否需要重新编译"><a href="#四、判断是否需要重新编译" class="headerlink" title="四、判断是否需要重新编译"></a>四、判断是否需要重新编译</h1><p>SCons很智能，只会编译需要编译的内容。比如我刚执行完scons，再次执行，则会提示<code>scons: . is up to date.</code>。 那么他是如何做到的呢？也不复杂，依赖一个Decider的方法，以及一个<code>.sconsign.dblite</code>文件。</p><p>默认情况下，如果文件的<a href="https://so.csdn.net/so/search?q=md5&spm=1001.2101.3001.7020">md5</a>值改变了，才会重新编译。每次编译，SCons都会把md5存起来，再次执行时，如果md5没变，则不需要rebuild。</p><h1 id="五、解析命令行选项"><a href="#五、解析命令行选项" class="headerlink" title="五、解析命令行选项"></a>五、解析命令行选项</h1><h2 id="1-AddOption"><a href="#1-AddOption" class="headerlink" title="1. AddOption"></a>1. AddOption</h2><p>作用：添加一项命令行选项</p><p>用法类似python中optparse库解析命令行参数的方法<code>add_option</code></p><p><a href="https://blog.csdn.net/lwnylslwnyls/article/details/8199454">https://blog.csdn.net/lwnylslwnyls/article/details/8199454</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AddOption(</span><br><span class="line">    &#x27;--prefix&#x27;,</span><br><span class="line">    dest=&#x27;prefix&#x27;,</span><br><span class="line">    nargs=1,</span><br><span class="line">    type=&#x27;string&#x27;,</span><br><span class="line">    action=&#x27;store&#x27;,</span><br><span class="line">    metavar=&#x27;DIR&#x27;,</span><br><span class="line">    help=&#x27;installation prefix&#x27;,</span><br><span class="line">)</span><br><span class="line">env = Environment(PREFIX=GetOption(&#x27;prefix&#x27;))</span><br></pre></td></tr></table></figure><p>添加以上命令行选项后，执行scons -h后可以看到添加的选项说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Local Options:</span><br><span class="line">  --prefix=DIR                installation prefix</span><br></pre></td></tr></table></figure><h2 id="2-GetOption"><a href="#2-GetOption" class="headerlink" title="2. GetOption"></a>2. GetOption</h2><p>作用：读取相应的命令行选项</p><p>通过AddOption得到的命令行参数，可以通过GetOption(‘参数名’)来获得，如上例所示</p><h2 id="3-SetOption"><a href="#3-SetOption" class="headerlink" title="3. SetOption"></a>3. SetOption</h2><p>作用：设置相应的命令行选项。</p><p>通过命令行选项设置的值将优先于使用SetOption设置的值</p><p>SetOption允许在脚本中设置项目默认值，并通过命令行临时覆盖它。SetOption调用也可以放在site_init.py文件中。</p><h2 id="4-Help"><a href="#4-Help" class="headerlink" title="4. Help"></a>4. Help</h2><p>在一个命令不知道怎么使用时，使用 –help 来获取当前命令的选项帮助是最好的方法。SCons 也是提供了 help 选项的编写，可以帮助用户简单的创建 –help 的语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Help(&quot;&quot;&quot;</span><br><span class="line">Type: &#x27;scons program&#x27; to build the production program,</span><br><span class="line">&#x27;scons debug&#x27; to build the debug version.</span><br><span class="line">&quot;&quot;&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>scons -h输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; scons -h</span><br><span class="line">scons: Reading SConscript files ...</span><br><span class="line">scons: done reading SConscript files.</span><br><span class="line"></span><br><span class="line">Type: &#x27;scons program&#x27; to build the production program,</span><br><span class="line">&#x27;scons debug&#x27; to build the debug version.</span><br><span class="line"></span><br><span class="line">Use scons -H for help about command-line options.</span><br></pre></td></tr></table></figure><h1 id="六、site-scons目录"><a href="#六、site-scons目录" class="headerlink" title="六、site_scons目录"></a>六、site_scons目录</h1><p>在scons解析SConscript文件之前，scons将首先在<code>各种系统目录</code>，<code>含有SConstruct文件的目录</code>和<code>scons 的命令行选项--site-dir指定的目录</code>这三种目录下寻找site_scons目录，并将找到的site_scons目录放到python模块的搜索路径中，即sys.path。这样就使得SConscript文件可以引入site_scons目录下的模块并使用。</p><p>此外，有的site_scons目录还可能含有 <code>site_init.py</code>文件和<code>site_tools</code>目录</p><h2 id="1-site-init-py"><a href="#1-site-init-py" class="headerlink" title="1.site_init.py"></a>1.site_init.py</h2><p>site_init.py文件将会先于SConscript文件被执行</p><h2 id="2-site-tools"><a href="#2-site-tools" class="headerlink" title="2. site_tools"></a>2. site_tools</h2><p>site_tools目录的路径会被预先添加到默认工作路径</p><h1 id="七、SCons内置函数"><a href="#七、SCons内置函数" class="headerlink" title="七、SCons内置函数"></a>七、SCons内置函数</h1><h2 id="1-GetCurrentDir"><a href="#1-GetCurrentDir" class="headerlink" title="1 GetCurrentDir()"></a>1 GetCurrentDir()</h2><p>获取当前路径。</p><h2 id="2-Glob"><a href="#2-Glob" class="headerlink" title="2 Glob()"></a>2 Glob()</h2><p>获取当前目录下的所有 C 文件。修改参数的值为其他后缀就可以匹配当前目录下的所有某类型的文件。</p><h2 id="3-Split-str"><a href="#3-Split-str" class="headerlink" title="3 Split(str)"></a>3 Split(str)</h2><p>将字符串 str 分割成一个列表 list。</p><h1 id="八、环境"><a href="#八、环境" class="headerlink" title="八、环境"></a>八、环境</h1><p>环境是可以影响程序执行方式的值的集合，SCons区分了三种不同类型的环境，这些环境都可能会影响SCons本身的行为、它执行的编译器以及其他工具。</p><h2 id="1-外部环境-External-Environment"><a href="#1-外部环境-External-Environment" class="headerlink" title="1. 外部环境 External Environment"></a>1. 外部环境 External Environment</h2><p>外部环境是用户运行SCons时用户环境中的一组变量。这些变量不是SCons构建的自动组成部分，但在需要时可以进行检查。</p><p>外部环境即为Python 中os模块的environ字典，它提供了用户在执行SCons时有效的外部环境变量设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">print(&quot;Shell is&quot;, os.environ[&#x27;SHELL&#x27;])</span><br></pre></td></tr></table></figure><p><strong>os.environ 是一个字典，是环境变量的字典</strong>，环境变量是程序和操作系统之间的通信方式</p><p>常见 key 字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">windows：</span><br><span class="line">os.environ[&#x27;HOMEPATH&#x27;]:当前用户主目录。</span><br><span class="line">os.environ[&#x27;TEMP&#x27;]:临时目录路径。</span><br><span class="line">os.environ[&quot;PATHEXT&quot;]:可执行文件。</span><br><span class="line">os.environ[&#x27;SYSTEMROOT&#x27;]:系统主目录。</span><br><span class="line">os.environ[&#x27;LOGONSERVER&#x27;]:机器名。</span><br><span class="line">os.environ[&#x27;PROMPT&#x27;]:设置提示符。</span><br><span class="line"></span><br><span class="line">linux：</span><br><span class="line">os.environ[&#x27;USER&#x27;]:当前使用用户。</span><br><span class="line">os.environ[&#x27;LC_COLLATE&#x27;]:路径扩展的结果排序时的字母顺序。</span><br><span class="line">os.environ[&#x27;SHELL&#x27;]:使用shell的类型。</span><br><span class="line">os.environ[&#x27;LAN&#x27;]:使用的语言。</span><br><span class="line">os.environ[&#x27;SSH_AUTH_SOCK&#x27;]:ssh的执行路径。</span><br></pre></td></tr></table></figure><h2 id="2-构造环境-Construction-Environment"><a href="#2-构造环境-Construction-Environment" class="headerlink" title="2. 构造环境 Construction Environment"></a>2. 构造环境 Construction Environment</h2><p>构造环境是在SConscript文件中创建的一个不同对象，它包含的值会影响SCons如何决定使用什么操作来构建目标，甚至定义应该从哪些源构建哪些目标。SCons最强大的功能之一是能够创建多个构造环境，包括从现有构造环境克隆新的自定义构造环境的能力。</p><p>构造环境是一个对象，它有许多相关的构造变量，每个变量都有一个名称和一个值，就像字典一样。</p><h3 id="2-1-设置环境构造变量"><a href="#2-1-设置环境构造变量" class="headerlink" title="2.1 设置环境构造变量"></a>2.1 设置环境构造变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 由Environment()方法创建一个构造环境对象</span><br><span class="line">env = Environment()</span><br><span class="line"># 默认情况下，SCons使用一组适用于当前平台的构建器方法和构建变量初始化每个新的构造环境</span><br><span class="line"># 初始化构造环境时，可以设置环境构造变量的值，以控制程序的生成方式。</span><br><span class="line">env = Environment(CC=&#x27;gcc&#x27;, CCFLAGS=&#x27;-O2&#x27;)</span><br><span class="line">env.Program(&#x27;foo.c&#x27;)</span><br></pre></td></tr></table></figure><p>用户已明确指定使用GNU C编译器gcc，并且在编译对象文件时应使用-O2（优化级别2）标志。换句话说，$CC和$CCFLAGS的显式初始化会覆盖新创建的构造环境中的默认值。此时使用scons输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; scons -Q</span><br><span class="line">gcc -o foo.o -c -O2 foo.c</span><br><span class="line">gcc -o foo foo.o</span><br></pre></td></tr></table></figure><h3 id="2-2-获取环境构造变量的值"><a href="#2-2-获取环境构造变量的值" class="headerlink" title="2.2 获取环境构造变量的值"></a>2.2 获取环境构造变量的值</h3><p>Python打印调用将为我们输出CC和LATEX的值</p><p>ps:使用.get（xxx, None）方法进行获取意味着，如果未设置变量，我们将返回None，而不是失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">env = Environment()</span><br><span class="line">print(&quot;CC is: %s&quot; % env[&#x27;CC&#x27;])</span><br><span class="line">print(&quot;LATEX is: %s&quot; % env.get(&#x27;LATEX&#x27;, None))</span><br></pre></td></tr></table></figure><p>构造环境实际上是一个具有关联方法和属性的对象。如果您只想直接访问构造变量的字典，则可以使用env的Dictionary方法获取该字典。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">env = Environment(FOO=&#x27;foo&#x27;, BAR=&#x27;bar&#x27;)</span><br><span class="line">cvars = env.Dictionary()</span><br><span class="line">for key in [&#x27;OBJSUFFIX&#x27;, &#x27;LIBSUFFIX&#x27;, &#x27;PROGSUFFIX&#x27;]:</span><br><span class="line">    print(&quot;key = %s, value = %s&quot; % (key, cvars[key]))</span><br></pre></td></tr></table></figure><p>使用dump()方法格式化输出构造环境的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env = Environment()</span><br><span class="line">print(env.Dump())</span><br></pre></td></tr></table></figure><p><strong>subst方法</strong></p><p>直接通过字典索引的方式输出环境构造变量的值时，有些环境构造变量不会展开，使得阅读存在困难</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env = Environment(CCFLAGS=&#x27;-DFOO&#x27;)</span><br><span class="line">print(&quot;CCCOM is: %s&quot; % env[&#x27;CCCOM&#x27;])</span><br><span class="line"></span><br><span class="line">&gt; scons -Q</span><br><span class="line">CCCOM is: $CC $CCFLAGS $CPPFLAGS $_CPPDEFFLAGS $_CPPINCFLAGS -c -o $TARGET $SOURCES</span><br><span class="line">scons: `.&#x27; is up to date.</span><br></pre></td></tr></table></figure><p>而使用subst方法输出，则会展开全部环境构造变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env = Environment(CCFLAGS=&#x27;-DFOO&#x27;)</span><br><span class="line">print(&quot;CCCOM is: %s&quot; % env.subst(&#x27;$CCCOM&#x27;))</span><br><span class="line"></span><br><span class="line">&gt; scons -Q</span><br><span class="line">CCCOM is: gcc -DFOO -c -o</span><br><span class="line">scons: `.&#x27; is up to date.</span><br></pre></td></tr></table></figure><p>可见，CC被展开为gcc，CCFLAGS被展开为-DFOO</p><h3 id="2-3-默认构造环境"><a href="#2-3-默认构造环境" class="headerlink" title="2.3 默认构造环境"></a>2.3 默认构造环境</h3><p>如果没有指定构造环境，Program和Library等构造方法都是使用默认构造环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用默认构造环境</span><br><span class="line">Program(&#x27;foo&#x27;, &#x27;foo.c&#x27;)</span><br><span class="line"></span><br><span class="line"># 使用指定构造环境</span><br><span class="line">opt = Environment(CCFLAGS=&#x27;-O2&#x27;)</span><br><span class="line">opt.Program(&#x27;foo&#x27;, &#x27;foo.c&#x27;)</span><br></pre></td></tr></table></figure><p>而控制默认构造和环境的方法为<code>DefaultEnvironment</code></p><p>DefaultEnvironment函数返回初始化的默认构造环境对象，然后可以像任何其他构造环境一样对其进行操作，例如以下示例指定了默认构造环境使用的编译器为’&#x2F;usr&#x2F;local&#x2F;bin&#x2F;gcc’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 方式一</span><br><span class="line">DefaultEnvironment(CC=&#x27;/usr/local/bin/gcc&#x27;)</span><br><span class="line"># 方式二</span><br><span class="line">def_env = DefaultEnvironment()</span><br><span class="line">def_env[&#x27;CC&#x27;] = &#x27;/usr/local/bin/gcc&#x27;</span><br><span class="line"># 两种方式等价</span><br></pre></td></tr></table></figure><h3 id="2-4-创建多个构造环境"><a href="#2-4-创建多个构造环境" class="headerlink" title="2.4 创建多个构造环境"></a>2.4 创建多个构造环境</h3><p>SCons的一大优势是可以创造多个构造环境。</p><p>不同的源文件可能需要在命令行上启用不同的选项，或者不同的可执行程序需要与不同的库链接。SCons允许您创建和配置控制软件构建方式的多个构建环境，从而满足这些不同的构建需求。</p><p>每个构建环境根据构建某个软件或其他文件的不同方式进行定制。例如，如果我们需要用 -O2标志构建一个程序，用 -g (debug)标志构建另一个程序，我们可以这样做:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">opt = Environment(CCFLAGS=&#x27;-O2&#x27;)</span><br><span class="line">dbg = Environment(CCFLAGS=&#x27;-g&#x27;)</span><br><span class="line">opt.Program(&#x27;foo&#x27;, &#x27;foo.c&#x27;)</span><br><span class="line">dbg.Program(&#x27;bar&#x27;, &#x27;bar.c&#x27;)</span><br><span class="line">        </span><br><span class="line">&gt; scons -Q</span><br><span class="line">cc -o bar.o -c -g bar.c</span><br><span class="line">cc -o bar bar.o</span><br><span class="line">cc -o foo.o -c -O2 foo.c</span><br><span class="line">cc -o foo foo.o</span><br></pre></td></tr></table></figure><p>甚至可以构建同一个源文件的不同版本程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">opt = Environment(CCFLAGS=&#x27;-O2&#x27;)</span><br><span class="line">dbg = Environment(CCFLAGS=&#x27;-g&#x27;)</span><br><span class="line">opt.Program(&#x27;foo&#x27;, &#x27;foo.c&#x27;)</span><br><span class="line">dbg.Program(&#x27;foo&#x27;, &#x27;foo.c&#x27;)</span><br><span class="line"></span><br><span class="line">&gt; scons -Q</span><br><span class="line">scons: *** Two environments with different actions were specified for the same target: foo.o</span><br><span class="line">File &quot;/home/my/project/SConstruct&quot;, line 6, in &lt;module&gt;</span><br></pre></td></tr></table></figure><p>但是因为产生了相同名字的不同中间文件而报错，为了避免这个问题，我们必须明确指定每个环境使用object生成器将foo.c编译为一个单独命名的对象文件，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">opt = Environment(CCFLAGS=&#x27;-O2&#x27;)</span><br><span class="line">dbg = Environment(CCFLAGS=&#x27;-g&#x27;)</span><br><span class="line">o = opt.Object(&#x27;foo-opt&#x27;, &#x27;foo.c&#x27;)</span><br><span class="line">opt.Program(o)</span><br><span class="line">d = dbg.Object(&#x27;foo-dbg&#x27;, &#x27;foo.c&#x27;)</span><br><span class="line">dbg.Program(d)</span><br><span class="line">        </span><br><span class="line">&gt; scons -Q</span><br><span class="line">cc -o foo-dbg.o -c -g foo.c</span><br><span class="line">cc -o foo-dbg foo-dbg.o</span><br><span class="line">cc -o foo-opt.o -c -O2 foo.c</span><br><span class="line">cc -o foo-opt foo-opt.o</span><br></pre></td></tr></table></figure><h3 id="2-5-复制构造环境"><a href="#2-5-复制构造环境" class="headerlink" title="2.5 复制构造环境"></a>2.5 复制构造环境</h3><p>有时，您希望多个构造环境共享一个或多个变量的相同值。在创建每个构造环境时，不必总是重复所有公共变量，而是可以使用env构造环境的Clone方法来创建构造环境的副本。</p><p>与创建构造环境的Environment调用一样，Clone方法接受构造变量赋值，该赋值将覆盖复制的构造环境中的值。</p><p>例如，假设我们想使用gcc创建一个程序的三个版本，一个是优化的，一个调试的，还有一个两者都没有。我们可以通过创建一个“基本”构造环境来实现这一点，该环境将CC设置为gcc，然后创建两个副本，一个设置CCFLAGS用于优化，另一个设置CCFLAGS用于调试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">env = Environment(CC=&#x27;gcc&#x27;)</span><br><span class="line">opt = env.Clone(CCFLAGS=&#x27;-O2&#x27;)</span><br><span class="line">dbg = env.Clone(CCFLAGS=&#x27;-g&#x27;)</span><br><span class="line"></span><br><span class="line">env.Program(&#x27;foo&#x27;, &#x27;foo.c&#x27;)</span><br><span class="line">o = opt.Object(&#x27;foo-opt&#x27;, &#x27;foo.c&#x27;)</span><br><span class="line">opt.Program(o)</span><br><span class="line">d = dbg.Object(&#x27;foo-dbg&#x27;, &#x27;foo.c&#x27;)</span><br><span class="line">dbg.Program(d)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">&gt; scons -Q</span><br><span class="line">gcc -o foo.o -c foo.c</span><br><span class="line">gcc -o foo foo.o</span><br><span class="line">gcc -o foo-dbg.o -c -g foo.c</span><br><span class="line">gcc -o foo-dbg foo-dbg.o</span><br><span class="line">gcc -o foo-opt.o -c -O2 foo.c</span><br><span class="line">gcc -o foo-opt foo-opt.o</span><br></pre></td></tr></table></figure><h3 id="2-6-更改环境构造变量"><a href="#2-6-更改环境构造变量" class="headerlink" title="2.6 更改环境构造变量"></a>2.6 更改环境构造变量</h3><p>通过env的Replace方法可以更改env构造环境中环境构造变量的值，如果这个环境构造变量不存在，则新增。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">env = Environment(CCFLAGS=&#x27;-DDEFINE1&#x27;)</span><br><span class="line">env.Replace(CCFLAGS=&#x27;-DDEFINE2&#x27;)</span><br><span class="line">env.Program(&#x27;foo.c&#x27;)</span><br><span class="line"></span><br><span class="line">&gt; scons -Q</span><br><span class="line">cc -o foo.o -c -DDEFINE2 foo.c</span><br><span class="line">cc -o foo foo.o</span><br></pre></td></tr></table></figure><p>在构建环境实际用于构建目标之前，变量不会展开，而且SCons函数和方法调用与顺序无关，所以最后一个替换“获胜”并用于构建所有目标，而不管对Replace（）的调用与对构建器方法的调用之间的顺序如何</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">env = Environment(CCFLAGS=&#x27;-DDEFINE1&#x27;)</span><br><span class="line">print(&quot;CCFLAGS = %s&quot; % env[&#x27;CCFLAGS&#x27;])</span><br><span class="line">env.Program(&#x27;foo.c&#x27;)</span><br><span class="line"></span><br><span class="line">env.Replace(CCFLAGS=&#x27;-DDEFINE2&#x27;)</span><br><span class="line">print(&quot;CCFLAGS = %s&quot; % env[&#x27;CCFLAGS&#x27;])</span><br><span class="line">env.Program(&#x27;bar.c&#x27;)</span><br><span class="line"></span><br><span class="line">&gt; scons</span><br><span class="line">scons: Reading SConscript files ...</span><br><span class="line">CCFLAGS = -DDEFINE1</span><br><span class="line">CCFLAGS = -DDEFINE2</span><br><span class="line">scons: done reading SConscript files.</span><br><span class="line">scons: Building targets ...</span><br><span class="line">cc -o bar.o -c -DDEFINE2 bar.c</span><br><span class="line">cc -o bar bar.o</span><br><span class="line">cc -o foo.o -c -DDEFINE2 foo.c</span><br><span class="line">cc -o foo foo.o</span><br><span class="line">scons: done building targets.</span><br></pre></td></tr></table></figure><h2 id="3-执行环境-Execution-Environment"><a href="#3-执行环境-Execution-Environment" class="headerlink" title="3. 执行环境 Execution Environment"></a>3. 执行环境 Execution Environment</h2><p>执行环境是SCons在执行外部命令（如编译器或链接器）以构建一个或多个目标时设置的值。</p><p>参考资料：</p><p><a href="https://www.jianshu.com/u/ddb7903b52e4">VictorWANG1992 - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/danshiming/article/details/122771064?ops_request_misc=%7B%22request_id%22:%22169805899416777224422665%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=169805899416777224422665&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122771064-null-null.142%5Ev96%5Epc_search_result_base2&utm_term=SCons&spm=1018.2226.3001.4187">SCons简单入门（一）-CSDN博客</a></p><p><a href="https://www.scons.org/doc/production/HTML/scons-user/index.html">SCons 4.5.2官方文档</a></p><p><a href="https://blog.csdn.net/jeek_we/category_12034807.html">scons_jeek_we的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/645748713">【千锋RT-Thread】第31章 SCons 构建工具 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Scons </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：指令系统</title>
      <link href="/2023/10/22/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/10/22/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-指令系统结构的分类"><a href="#1-指令系统结构的分类" class="headerlink" title="1 指令系统结构的分类"></a>1 指令系统结构的分类</h1><p>CPU中用来存放操作数的存储单元主要有三种：<strong>堆栈</strong>、<strong>累加器</strong>、<strong>通用寄存器组</strong>。据此，指令系统（Instruction Set Architecture）可分为三种：</p><ul><li><strong>$\color[RGB]{40,120,181}{堆栈型结构}$：</strong>堆栈栈顶和次栈顶中的数据，运算后写入栈顶。两个操作数都是隐式的。<strong>优点：</strong>指令字比较短，程序占用的空间小；<strong>缺点：</strong>不能随机地访问堆栈，难以生成有效的代码，而且对栈顶的访问是个瓶颈。</li><li><strong>$\color[RGB]{40,120,181}{累加器型结构}$：</strong>一个操作数是隐式的，即累加器；另一个是显示给出的。<strong>优点：</strong>指令字比较短，程序占用的空间小；<strong>缺点：</strong>只有一个中间结果暂存在累加器中，需要频繁访问存储器。</li></ul><p>早期计算机大多采用堆栈型结构或累加器型结构</p><ul><li><strong>$\color[RGB]{40,120,181}{通用寄存器型结构}$：</strong>所有操作数都是显示给出的。<strong>优点：</strong>1.寄存器的访问比存储器快得多 2. 编译器能够更加容易、有效地分配寄存器 。根据操作数显式给出的来源不同，又可以分为两类：<ul><li>$\color[RGB]{248,172,140}{寄存器-存储器型结构(RM结构)}:$一个操作数来自寄存器，另一个来自存储器。</li><li>$\color[RGB]{248,172,140}{寄存器-寄存器型结构(RR结构)}:$两个操作数都来自寄存器。</li></ul></li></ul><p>**显式给出:**用指令字中的操作数字段给出</p><p>**隐式给出:**用事先约定好的单元</p><span id="more"></span><h1 id="2-寻址方式"><a href="#2-寻址方式" class="headerlink" title="2. 寻址方式"></a>2. 寻址方式</h1><p>寻址方式（Addressing Mode）是指指令系统中产生所要访问的数据地址的方法。寻址方式可以指明指令中的操作数是一个<strong>立即数</strong>、一个<strong>寄存器操作数</strong>或者是一个<strong>存储器操作数</strong></p><h2 id="2-1-寻址方式举例"><a href="#2-1-寻址方式举例" class="headerlink" title="2.1 寻址方式举例"></a>2.1 寻址方式举例</h2><ul><li>寄存器寻址</li><li>立即数寻址</li><li>偏移寻址</li></ul><p>等等</p><h2 id="2-2-字节对齐"><a href="#2-2-字节对齐" class="headerlink" title="2.2 字节对齐"></a>2.2 字节对齐</h2><p>计算机中信息的单位可分为字节(8bit)、半字(16bit)、单字(32bit)、双字(64bit)。计算机中采用按字节编址，各类信息都是用改信息的首字节地址来寻址的。</p><h3 id="信息存储的整数边界"><a href="#信息存储的整数边界" class="headerlink" title="信息存储的整数边界"></a>信息存储的整数边界</h3><p>此外还需要对它们的存储方式进行限制，如果允许它们任意存储，就可能出现一个信息跨存储字边界而存储与两个存储单元的情况，而在这种情况下，读取该信息就需要花费两个存储周期，为了避免出现这个问题，就要求<strong>宽度不超过主存宽度的信息必须存放在一个存储字内，信息在主存中存放的起始地址必须是该信息宽度（字节数）的整数倍</strong>，从而避免了跨边界，保证了访问速度。</p><p>对于一个32位机器（主存宽度为32位），要求：</p><h5 id="字节信息的起始地址为：x…xxxx"><a href="#字节信息的起始地址为：x…xxxx" class="headerlink" title="字节信息的起始地址为：x…xxxx"></a>字节信息的起始地址为：x…xxxx</h5><h5 id="半字信息的起始地址为：x…xxx0"><a href="#半字信息的起始地址为：x…xxx0" class="headerlink" title="半字信息的起始地址为：x…xxx0"></a>半字信息的起始地址为：x…xxx0</h5><h5 id="单字信息的起始地址为：x…xx00"><a href="#单字信息的起始地址为：x…xx00" class="headerlink" title="单字信息的起始地址为：x…xx00"></a>单字信息的起始地址为：x…xx00</h5><h5 id="双字信息的起始地址为：x…x000"><a href="#双字信息的起始地址为：x…x000" class="headerlink" title="双字信息的起始地址为：x…x000"></a>双字信息的起始地址为：x…x000</h5>]]></content>
      
      
      <categories>
          
          <category> 《计算机体系结构》学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
            <tag> 指令系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宝藏博客</title>
      <link href="/2023/10/19/1019-1021/"/>
      <url>/2023/10/19/1019-1021/</url>
      
        <content type="html"><![CDATA[<p><a href="https://dongshao.blog.csdn.net/?type=blog">董哥的黑板报_APUE编程,TCP&#x2F;IP卷一,C++-CSDN博客</a></p><p><a href="https://csdiy.wiki/">CS自学指南 (csdiy.wiki)</a></p>]]></content>
      
      
      <categories>
          
          <category> 收藏 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo主题和插件</title>
      <link href="/2023/10/18/hexo%E4%B8%BB%E9%A2%98%E5%92%8C%E6%8F%92%E4%BB%B6/"/>
      <url>/2023/10/18/hexo%E4%B8%BB%E9%A2%98%E5%92%8C%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Hexo主题"><a href="#1-Hexo主题" class="headerlink" title="1. Hexo主题"></a>1. Hexo主题</h1><p>hexo官方提供了很多的主题模板，可以在<a href="https://hexo.io/themes/index.html">hexo主题官网</a>中看到，<a href="https://hexo.io/zh-cn/docs/themes.html">官方教程</a>中也有配置主题操作</p><span id="more"></span><h2 id="Next主题"><a href="#Next主题" class="headerlink" title="Next主题"></a><strong>Next主题</strong></h2><p>在众多主题中，Next是最受欢迎的主题之一，它提供了许多的界面模板，并且支持安装许多的插件。</p><h2 id="Next主题下载"><a href="#Next主题下载" class="headerlink" title="Next主题下载"></a><strong>Next主题下载</strong></h2><ol><li><p>$\color[RGB]{200, 100, 10}{下载}$。在git bash窗口中通过git clone即可下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>下载成功后，在<strong>blog&#x2F;themes</strong>文件夹下即可找到下载的next主题文件夹，其中包含了next主题的配置信息</p></li><li><p>$\color[RGB]{200, 100, 10}{修改Hexo主题}$。返回<strong>bolg根目录</strong>，打开**_config.yml 文件**，并将其中的theme项的值改为next</p></li></ol><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src=hexo主题和插件/image-20231019001323077.png>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #FFF;    padding: 2px;">hexo主题修改为next</div></center><p>经过以上两步，hexo的主题就成功更换为next啦！然后就通过hexo g重新生成博客，再通过hexo s 或 hexo d发布新的博客，看看新主题的样子。</p><hr><h1 id="2-添加分类、标签、关于"><a href="#2-添加分类、标签、关于" class="headerlink" title="2. 添加分类、标签、关于"></a>2. 添加分类、标签、关于</h1><p><a href="https://blog.csdn.net/weixin_48927364/article/details/123295436">【Hexo】nexT主题使用攻略基础——添加分类、标签及关于_hexo 分类-CSDN博客</a></p><h1 id="3-Hexo常用插件"><a href="#3-Hexo常用插件" class="headerlink" title="3. Hexo常用插件"></a>3. Hexo常用插件</h1><h2 id="（1）插入数学公式"><a href="#（1）插入数学公式" class="headerlink" title="（1）插入数学公式"></a>（1）插入数学公式</h2><p>在用markdown写技术文档时，免不了会碰到数学公式。Next这种大主题也集成了渲染数学公式的功能</p><p>目前Next提供两种数学公式渲染引擎，分别是Mathjax和Katex。</p><p>可以在Next主题的配置文件_config.yml中看到这两个项</p><img src="/2023/10/18/hexo%E4%B8%BB%E9%A2%98%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231019132036641.png" class="" title="Next主题的配置文件_config.yml"><p>默认情况下两个引擎的enable使能选项均为false，只需要改为true就可以渲染数学公式了</p><p>其中every_page项置为true的时候，引擎会默认对每篇博客中的数学公式进行渲染，但对于不含数学公式的博客，加载速度会额外变慢；而当置为false是，只会对在开头处声明使用mathjax引擎的博客进行渲染。</p><img src="/2023/10/18/hexo%E4%B8%BB%E9%A2%98%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231019145600478.png" class="" title="博客开头声明使用mathjax引擎"><p><strong>效果展示：</strong></p><ul><li><p>行内公式：</p><p>$f\left( x \right) &#x3D; \sum\limits_{i &#x3D; 1}^n {X_i^2} $</p><p>$MD\left(n_{i, j}, n_{x, y}\right)&#x3D;|i-x|+|j-y|$</p></li><li><p>行间公式：</p><p>$$ f\left( x \right) &#x3D; \sum\limits_{i &#x3D; 1}^n {X_i^2} $$</p><p>$$ MD\left(n_{i, j}, n_{x, y}\right)&#x3D;|i-x|+|j-y|$$</p></li></ul><p>（2）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu虚拟机</title>
      <link href="/2023/10/17/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2023/10/17/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机iso镜像下载"><a href="#虚拟机iso镜像下载" class="headerlink" title="虚拟机iso镜像下载"></a>虚拟机iso镜像下载</h1><p><a href="https://developer.aliyun.com/mirror/?spm=a2c6h.265751.1364563.38.728e2621iHKW48">阿里巴巴开源镜像站-OPSX镜像站-阿里云开发者社区 (aliyun.com)</a></p><p>进入阿里巴巴开源镜像站，点击OS，输入想要下载的发行版镜像及版本号，即可下载。</p><span id="more"></span><h1 id="Ubuntu20-04更换清华源"><a href="#Ubuntu20-04更换清华源" class="headerlink" title="Ubuntu20.04更换清华源"></a>Ubuntu20.04更换清华源</h1><p>Ubuntu安装完之后进行更换为国内源可以让下载更新的的速度快一点。</p><p>以下是具体操作的博客</p><p><a href="https://www.cnblogs.com/Lxk0825/p/9520002.html">ubuntu 执行apt-get update报错Failed to fetch - Lxk- - 博客园 (cnblogs.com)</a></p><p>使用清华源，将以下代码输入&#x2F;etc&#x2F;apt&#x2F;sources.list文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h1 id="解决Linux-下使用-ifconfig-查看不到-ip-地址"><a href="#解决Linux-下使用-ifconfig-查看不到-ip-地址" class="headerlink" title="解决Linux 下使用 ifconfig 查看不到 ip 地址"></a>解决Linux 下使用 ifconfig 查看不到 ip 地址</h1><p>ubuntu下ifconfig查找不到ens33</p><img src="/2023/10/17/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20231106094703783.png" class="" title="image-20231106094703783"><p>解决方案：<strong>在终端下使用 dhclient ens33 命令获取：</strong></p><p>效果立竿见影：</p><img src="/2023/10/17/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20231106094829938.png" class="" title="image-20231106094829938"><p>参考链接🔗：<a href="https://zhuanlan.zhihu.com/p/614401443">解决Linux 下使用 ifconfig 查看不到 ip 地址 - 知乎 (zhihu.com)</a></p><h1 id="python-版本切换"><a href="#python-版本切换" class="headerlink" title="python 版本切换"></a>python 版本切换</h1><p>使用update-alternatives 来为整个系统更改Python 版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --config python</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_43744723/article/details/122090500">Ubuntu下完美切换Python版，即设置系统默认的python版本(亲测有效)_ubuntu 切换python版本-CSDN博客</a></p><h1 id="配置、查看环境变量"><a href="#配置、查看环境变量" class="headerlink" title="配置、查看环境变量"></a>配置、查看环境变量</h1><p><a href="https://blog.csdn.net/white_idiot/article/details/78253004">【Ubuntu】Ubuntu设置和查看环境变量_ubuntu 环境变量-CSDN博客</a></p><h1 id="刚装好系统的虚拟机屏幕无法自适应"><a href="#刚装好系统的虚拟机屏幕无法自适应" class="headerlink" title="刚装好系统的虚拟机屏幕无法自适应"></a>刚装好系统的虚拟机屏幕无法自适应</h1><p>安装VMtools即可自适应屏幕</p><p>以后开机后会无法自适应屏幕，但只需要点击“自由拉伸”，然后取消，就会自适应</p><h1 id="虚拟机无法与宿主机实现复制粘贴"><a href="#虚拟机无法与宿主机实现复制粘贴" class="headerlink" title="虚拟机无法与宿主机实现复制粘贴"></a>虚拟机无法与宿主机实现复制粘贴</h1><p>安装VMtools，然后重启即可</p><h1 id="磁盘扩容"><a href="#磁盘扩容" class="headerlink" title="磁盘扩容"></a>磁盘扩容</h1><p><a href="https://blog.csdn.net/qq_45853229/article/details/124595300">Ubuntu磁盘扩容(简单亲测有效）_ubuntu扩展磁盘空间___乔木的博客-CSDN博客</a></p><h1 id="通过交换分区增加内存容量"><a href="#通过交换分区增加内存容量" class="headerlink" title="通过交换分区增加内存容量"></a>通过交换分区增加内存容量</h1><p><a href="https://www.vpsgo.com/linux-swap.html">Linux Swap交换分区设置教程</a></p><h1 id="安装VMTools"><a href="#安装VMTools" class="headerlink" title="安装VMTools"></a>安装VMTools</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt install open-vm-tools-desktop -y</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h1 id="apt-get报错：Could-not-get-lock-var-lib-dpkg-lock-frontend"><a href="#apt-get报错：Could-not-get-lock-var-lib-dpkg-lock-frontend" class="headerlink" title="apt-get报错：Could not get lock &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-frontend"></a>apt-get报错：Could not get lock &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-frontend</h1><p>使用apt安装时报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarily unavailable)</span><br><span class="line">E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?</span><br></pre></td></tr></table></figure><p>解决方案：</p><h3 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo killall apt apt-get</span><br></pre></td></tr></table></figure><p>如果提示没有apt进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt: no process found</span><br><span class="line">apt-get: no process found</span><br></pre></td></tr></table></figure><p>往下看方案二</p><h3 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h3><p>依次执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /var/lib/apt/lists/lock</span><br><span class="line">sudo rm /var/cache/apt/archives/lock</span><br><span class="line">sudo rm /var/lib/dpkg/lock*</span><br><span class="line">sudo dpkg --configure -a</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/lun55423/article/details/108907779">【已解决】Could not get lock &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-frontend_could not get lock &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-frontend - o-CSDN博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（一）</title>
      <link href="/2023/10/17/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/10/17/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Gem5模拟器简介"><a href="#一、Gem5模拟器简介" class="headerlink" title="一、Gem5模拟器简介"></a>一、Gem5模拟器简介</h1><p>gem5是一个开源、模块化的时钟精确的全系统模拟器，应用于计算机体系结构研究。该模拟器可以对CPU、存储系统、片上互连系统、I&#x2F;O等系统组件进行详细的建模，并通过修改不同组件的具体实现和各个组件的配置参数可以灵活配置不同的计算系统。</p><span id="more"></span><h2 id="1-1-模拟组件"><a href="#1-1-模拟组件" class="headerlink" title="1.1 模拟组件"></a>1.1 模拟组件</h2><ul><li><p><strong>$\color[RGB]{0,150,255}{多种ISA}$</strong> ：gem5支持常见的各种指令集：X86、ARM、RISCV、SPARC、POWER、MIPS。不同的指令集包含了每条指令执行的完整过程。当前gem5中可用于全系统模拟的ISA主要有ARM、X86和RISCV；</p></li><li><p><strong>$\color[RGB]{0,150,255}{多种CPU模型}$</strong> ：gem5支持4种CPU模型：Simple、In-Order、Out-of-Order(简称O3)和KVM。每种CPU的具体实现和ISA不关联，因此CPU模型和ISA间可以任意搭配以组成多种计算机系统；</p></li><li><p><strong>$\color[RGB]{0,150,255}{Port  Interface}$</strong> ：该组件的主要功能是将系统中各个组件通过端口进行连接，屏蔽不同架构硬件实现细节，简化不同组件间的连接方式并增强系统通用性；</p></li><li><p><strong>$\color[RGB]{0,150,255}{Cache模型}$</strong> ：在gem5中支持Ruby和Classic Cache两种模型。</p></li><li><p><strong>Ruby存储模型</strong>:用户可以自定义不同Cache一致性协议，并对片上网络(Network-of-Chip, NoC)进行了详细建模；</p></li><li><p><strong>Classic存储模型</strong>: 支持硬编码的层次MOESI一致性协议</p></li><li><p><strong>$\color[RGB]{0,150,255}{DRAM模型}$</strong> ：gem5中的DRAM模型是事件驱动的，支持多种市面上常见的DRAM，如DDR3、DDR4、DDR5、GDDR、HMC、HBM等。在gem5中，DRAM模型不是时钟精确的，但是可以和时钟精确的DRAM模拟器DRAMSim3结合使用，gem5中提供了和DRAMSim连接的接口；</p></li><li><p><strong>$\color[RGB]{0,150,255}{GPU模型}$</strong> ：其GPU模型基于AMD的Graphic Core Next(GCN),是一种基于计算的时钟级GPU，支持多种异构系统的计算应用程序，不支持图形应用程序。一般都使用AMD的APU模拟器(基于gem5)对GPU进行模拟；</p></li><li><p><strong>$\color[RGB]{0,150,255}{I&#x2F;O设备}$</strong> ：支持常见的磁盘控制器、PCI、Ethernet等等，是进行全系统模拟必不可少的系统组件；</p></li><li><p><strong>$\color[RGB]{0,150,255}{丰富的接口}$</strong>  ：虽然gem5模拟器功能全面、配置灵活，但是在对各个组件进行建模的过程中，考虑复杂性和实现等方面因素，并不是对所有系统组件进行详细建模，因此配置了多种其他体系结构模拟器的结构，如SST、SystemC、DRAMSys、DRAMSim。</p></li></ul><h2 id="1-2-模拟模式"><a href="#1-2-模拟模式" class="headerlink" title="1.2 模拟模式"></a>1.2 模拟模式</h2><p>gem5支持两种系统模拟方式，一种是System Call Emulation(SE)，也叫系统调用模拟模式；另一种是Full System Simuluation(FS)，也叫全系统模拟模式。</p><ul><li><p>系统调用模拟模式 System Call Emulation(SE)</p></li><li><p>全系统模拟模式 Full System Simuluation(FS)</p></li></ul><h1 id="二、Gem5安装与测试"><a href="#二、Gem5安装与测试" class="headerlink" title="二、Gem5安装与测试"></a>二、Gem5安装与测试</h1><p>官网教程<a href="https://www.gem5.org/documentation/learning_gem5/part1/building/">gem5: Building gem5</a></p><h2 id="2-1-下载gem5源码"><a href="#2-1-下载gem5源码" class="headerlink" title="2.1 下载gem5源码"></a>2.1 下载gem5源码</h2><p>通过gitee网站下载源码，速度较快</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/koverlu/gem5.git</span><br></pre></td></tr></table></figure><h2 id="2-2-安装依赖"><a href="#2-2-安装依赖" class="headerlink" title="2.2 安装依赖"></a>2.2 安装依赖</h2><p>根据官网的安装命令一键安装全部依赖，主要包括git,gcc,python,protobuf,Boost</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential git m4 scons zlib1g zlib1g-dev \</span><br><span class="line">    libprotobuf-dev protobuf-compiler libprotoc-dev libgoogle-perftools-dev \</span><br><span class="line">    python3-dev python-is-python3 libboost-all-dev pkg-config</span><br></pre></td></tr></table></figure><h2 id="2-3-设置swap交换分区"><a href="#2-3-设置swap交换分区" class="headerlink" title="2.3 设置swap交换分区"></a>2.3 设置swap交换分区</h2><p>关于设置交换分区，读者可以自行百度或者看这篇博客<a href="https://www.vpsgo.com/linux-swap.html">Linux Swap交换分区设置教程</a>。简单说，Swap分区的作用就是在内存不够的情况下，操作系统先把内存中暂时不用的数据，存到硬盘的交换空间，腾出内存来让别的程序运行。而构建gem5环境是需要很大的内存，因此很需要通过交换分区来“扩大”内存。否则会因为内存补不足而报错如下：</p><img src="/2023/10/17/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/image-20231025185902443.png" class="" title="error"><p>linux下设置swap分区的操作如下：</p><ul><li><p><strong>清空默认的Swap分区</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo swapoff -a</span><br></pre></td></tr></table></figure></li><li><p><strong>创建分区文件并指定大小</strong></p><p>&#x2F;var&#x2F;swapfile是分区文件的位置，bs*count为文件大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dd if=/dev/zero of=/var/swapfile bs=1M count=10240</span><br></pre></td></tr></table></figure></li><li><p>格式化为Swap分区文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkswap /var/swapfile</span><br></pre></td></tr></table></figure></li><li><p>启动Swap分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo swapon /var/swapfile</span><br></pre></td></tr></table></figure></li><li><p>查看分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure><p>输出如下所示，分区创建成功，我的虚拟机设置的2GB内存+10GB分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu:~/Desktop/gem5$ free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:          1.9Gi       1.2Gi       116Mi        33Mi       567Mi       471Mi</span><br><span class="line">Swap:           9Gi       351Mi       9.7Gi</span><br></pre></td></tr></table></figure></li><li><p>设置开机启动</p><p>只需要在&#x2F;etc&#x2F;fstab中的末尾增加一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/swapfile swap swap defaults 0 0</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-4-编译gem5环境"><a href="#2-4-编译gem5环境" class="headerlink" title="2.4 编译gem5环境"></a>2.4 编译gem5环境</h2><p>下面创建一个简单的x86环境试一下，首先进入gem5目录，然后通过以下命令构建环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scons build/X86/gem5.opt -j[NumberOfThread]</span><br></pre></td></tr></table></figure><p>这里使用SCons构建工具，SCons使用当前目录和每个子目录的SConstruct文件查找和编译所有gem5源代码。</p><p>命令中build&#x2F;X86&#x2F;gem5.opt是构建环境的目标文件（opt后缀代表它是一个带有调试符号的优化二进制文件，其他后缀后面会介绍）。</p><p>[NumberOfThread]是用户期望该编译使用多少个线程进行编译，去掉-j 选项默认单线程，建议读者采用多线程编译，一般选为电脑 CPU 核数 - 1 最佳。</p><p>编译时间或许会有些长（我的破电脑跑了九九八十一天终于炼出来了）</p><p>出现以下log则表示模拟环境构建成功！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Checking for C header file Python.h... yes</span><br><span class="line">Checking for C library pthread... yes</span><br><span class="line">Checking for C library dl... yes</span><br><span class="line">Checking for C library util... yes</span><br><span class="line">Checking for C library m... yes</span><br><span class="line">Checking for C library python2.7... yes</span><br><span class="line">Checking for accept(0,0,0) in C++ library None... yes</span><br><span class="line">Checking for zlibVersion() in C++ library z... yes</span><br><span class="line">Checking for GOOGLE_PROTOBUF_VERIFY_VERSION in C++ library protobuf... yes</span><br><span class="line">Checking for clock_nanosleep(0,0,NULL,NULL) in C library None... yes</span><br><span class="line">Checking for timer_create(CLOCK_MONOTONIC, NULL, NULL) in C library None... no</span><br><span class="line">Checking for timer_create(CLOCK_MONOTONIC, NULL, NULL) in C library rt... yes</span><br><span class="line">Checking for C library tcmalloc... yes</span><br><span class="line">Checking for backtrace_symbols_fd((void*)0, 0, 0) in C library None... yes</span><br><span class="line">Checking for C header file fenv.h... yes</span><br><span class="line">Checking for C header file linux/kvm.h... yes</span><br><span class="line">Checking size of struct kvm_xsave ... yes</span><br><span class="line">Checking for member exclude_host in struct perf_event_attr...yes</span><br><span class="line">Building in /local.chinook/gem5/gem5-tutorial/gem5/build/X86</span><br><span class="line">Variables file /local.chinook/gem5/gem5-tutorial/gem5/build/variables/X86 not found,</span><br><span class="line">  using defaults in /local.chinook/gem5/gem5-tutorial/gem5/build_opts/X86</span><br><span class="line">scons: done reading SConscript files.</span><br><span class="line">scons: Building targets ...</span><br><span class="line"> [ISA DESC] X86/arch/x86/isa/main.isa -&gt; generated/inc.d</span><br><span class="line"> [NEW DEPS] X86/arch/x86/generated/inc.d -&gt; x86-deps</span><br><span class="line"> [ENVIRONS] x86-deps -&gt; x86-environs</span><br><span class="line"> [     CXX] X86/sim/main.cc -&gt; .o</span><br><span class="line"> ....</span><br><span class="line"> .... &lt;lots of output&gt;</span><br><span class="line"> ....</span><br><span class="line"> [   SHCXX] nomali/lib/mali_midgard.cc -&gt; .os</span><br><span class="line"> [   SHCXX] nomali/lib/mali_t6xx.cc -&gt; .os</span><br><span class="line"> [   SHCXX] nomali/lib/mali_t7xx.cc -&gt; .os</span><br><span class="line"> [      AR]  -&gt; drampower/libdrampower.a</span><br><span class="line"> [   SHCXX] nomali/lib/addrspace.cc -&gt; .os</span><br><span class="line"> [   SHCXX] nomali/lib/mmu.cc -&gt; .os</span><br><span class="line"> [  RANLIB]  -&gt; drampower/libdrampower.a</span><br><span class="line"> [   SHCXX] nomali/lib/nomali_api.cc -&gt; .os</span><br><span class="line"> [      AR]  -&gt; nomali/libnomali.a</span><br><span class="line"> [  RANLIB]  -&gt; nomali/libnomali.a</span><br><span class="line"> [     CXX] X86/base/date.cc -&gt; .o</span><br><span class="line"> [    LINK]  -&gt; X86/gem5.opt</span><br><span class="line">scons: done building targets. &lt;这个代表环境构建成功&gt;</span><br></pre></td></tr></table></figure><h2 id="2-5-测试gem5"><a href="#2-5-测试gem5" class="headerlink" title="2.5 测试gem5"></a>2.5 测试gem5</h2><p>环境构建成功以后，就可以根据官网的指南编写python配置文件进行系统模拟了。</p><p>这里借助官网提供的默认配置文件se.py进行配置，并运行hello world程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/X86/gem5.opt ./configs/example/se.py -c ./tests/test-progs/hello/bin/x86/linux/hello</span><br></pre></td></tr></table></figure><p>出现以下输出则表示模拟正确</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">gem5 Simulator System.  https://www.gem5.org</span><br><span class="line">gem5 is copyrighted software; use the --copyright option for details.</span><br><span class="line"></span><br><span class="line">gem5 version 22.1.0.0</span><br><span class="line">gem5 compiled Oct 24 2023 01:52:12</span><br><span class="line">gem5 started Oct 24 2023 02:00:27</span><br><span class="line">gem5 executing on ubuntu, pid 28261</span><br><span class="line">command line: ./build/X86/gem5.opt ./configs/example/se.py -c ./tests/test-progs/hello/bin/x86/linux/hello</span><br><span class="line"></span><br><span class="line">warn: The `get_runtime_isa` function is deprecated. Please migrate away from using this function.</span><br><span class="line">warn: The `get_runtime_isa` function is deprecated. Please migrate away from using this function.</span><br><span class="line">Global frequency set at 1000000000000 ticks per second</span><br><span class="line">warn: No dot file generated. Please install pydot to generate the dot file and pdf.</span><br><span class="line">build/X86/mem/dram_interface.cc:690: warn: DRAM device capacity (8192 Mbytes) does not match the address range assigned (512 Mbytes)</span><br><span class="line">0: system.remote_gdb: listening for remote gdb on port 7000</span><br><span class="line">**** REAL SIMULATION ****</span><br><span class="line">build/X86/sim/simulate.cc:192: info: Entering event queue @ 0.  Starting simulation...</span><br><span class="line">Hello world!</span><br><span class="line">Exiting @ tick 5985500 because exiting with last active thread context</span><br></pre></td></tr></table></figure><h1 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h1><p><a href="https://blog.csdn.net/qq_45726331/article/details/129757815?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-129757815-blog-128272972.235%5Ev38%5Epc_relevant_sort_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-129757815-blog-128272972.235%5Ev38%5Epc_relevant_sort_base2&utm_relevant_index=5">有关gem5模拟器的资料导航</a></p><p><a href="https://www.gem5.org/">Gem5官网</a></p><p><a href="https://www.gem5.org/documentation/learning_gem5/introduction/">Gem5官方学习向导</a></p><p><a href="https://mp.weixin.qq.com/s/VoPI0jbAERg8VK98oVff4Q">gem5学习笔记一：模拟器安装与使用 (qq.com)</a></p><p><a href="https://www.terapines.com/post/767/">兆松科技研发的基于gem5的模拟器zemu</a></p><p><a href="https://blog.csdn.net/qq_43381135/article/details/104371236">GEM5教程–gem5开始之旅（一）-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_46675545/category_12120503.html">Gem5模拟器_好啊啊啊啊的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/ivy_reny/category_6666068.html">gem5_ivy_reny的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/wyj7260/category_1301132.html">gem5_wyj7260的博客-CSDN博客</a></p><p>收集一下前辈们的踩坑记录</p><p><a href="https://zhuanlan.zhihu.com/p/412917633">gem5安装踩坑指南 - 知乎 (zhihu.com)</a></p><ul><li><p>报错 <strong>ImportError: No module named six</strong></p><p>  通过pip 安装six模块即可 <code>pip install six</code></p></li><li><p>报错<strong>util&#x2F;cpt_upgrader.py: Permission denied</strong></p><p>  执行<code>sudo chmod 777 ./util/cpt_upgrader.py</code>给权限，</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Gem5模拟器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gem5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo上传图片</title>
      <link href="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
      <url>/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>Hexo网站已经搭建好了，我们可以开始愉快地写博客了！</p><h2 id="1-Typora编辑器"><a href="#1-Typora编辑器" class="headerlink" title="1. Typora编辑器"></a>1. Typora编辑器</h2><p>Typora是一种markdown语言的常用编辑器，这个软件的方便之处在于可以直接将markdown语法呈现出其效果，并且集成了许多有用的工具，是编辑markdown的不二之选。</p><p><a href="https://typora.io/">Typora官网</a></p><hr><h2 id="2-Hexo插入本地图片遇到的问题"><a href="#2-Hexo插入本地图片遇到的问题" class="headerlink" title="2. Hexo插入本地图片遇到的问题"></a>2. Hexo插入本地图片遇到的问题</h2><p>markdown的图片插入语法为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片描述](图片路径)</span><br></pre></td></tr></table></figure><p>如果使用Typora，可以直接将图片复制粘贴在想要放置的位置，十分方便</p><p>当我们将图片直接复制到Typora中时，会出现图片可以在markdown中显示，但却无法在网页中显示的问题。</p><span id="more"></span><p><img src="/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007210728956.png" alt="图一：Typora视角"></p><p><img src="/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007210809543.png" alt="图二：网页视角"></p><hr><h2 id="3-将本地图片上传至Github"><a href="#3-将本地图片上传至Github" class="headerlink" title="3. 将本地图片上传至Github"></a>3. 将本地图片上传至Github</h2><p>这其实很好理解，因为使用的图片还在你的本地，markdown语法也使用的是本地路径（如图三），而静态网页不可能在你电脑本地找图片，所以需要我们将图片也一起上传。</p><p><img src="/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007205825905.png" alt="图三：我从微信直接复制粘贴到Typora的一张图片"></p><p>上传图片等资源十分简单，只需要在Hexo的配置文件_config.yml里将post_asset_folder这一个选项配置从false更改为true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>于是每当你新建一个博客时，Hexo会自动在相同目录建立一个同名的资源文件夹，只需要将图片放到资源文件夹中，然会在markdown中通过相对路径找到图片就可以啦！</p><p>然而，每次在博客中添加图片还要手动放到资源文件夹中，然后再用语法![]()去描述图片，实在是麻烦！</p><p>好在我们可以使用Typora中的工具，依次在Typora中进入文件-&gt;偏好设置-&gt;图像，然后在插入图片时选择复制到指定路径，也就是那个在同目录下同名的资源文件夹.&#x2F;&amp;{filename}，并勾选</p><ul><li><p>对本地位置的图片应用上述规则</p></li><li><p>对网络位置的图片应用上述规则</p></li><li><p>优先使用相对路径</p></li></ul><p>建议都勾选上，至少要勾选上第一项</p><p><img src="/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007211935125.png" alt="图四"></p><img src="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007212121607.png" class="" title="图五"><p>于是，复制粘贴过来的图片就可以自动保存在资源文件夹中，并且也自动将图片路径指向了资源文件夹中的这张图片，真方便！</p><img src="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007212607249.png" class="" title="图六"><img src="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007212643086.png" class="" title="图七"><p>当我满心欢喜地将博客部署到Github上时，却发现还是和图二一样没法显示</p><p>这是问什么呢？！</p><hr><h2 id="4-Hexo显示图像语法"><a href="#4-Hexo显示图像语法" class="headerlink" title="4. Hexo显示图像语法"></a>4. Hexo显示图像语法</h2><p>翻阅Hexo<a href="https://hexo.io/zh-cn/docs/asset-folders#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%BC%95%E7%94%A8%E7%9A%84%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6">官方教程之后</a>，才发现Hexo并不可以直接将markdown显示图片的![]()语法在网页中显示图片，而必须使用以下图像标签插件来插入图片，否则图片会路径错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure><p>在markdown中编辑如下代码之后，卡比终于能在网页上出现了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img c0229a294ce2c67e2ba3d44298fcb98.jpg [我正在学习，请不要打扰] %&#125;</span><br></pre></td></tr></table></figure><img src="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231008110447546.png" class="" title="图八：使用Hexo插入图片语法——在页面中的视角"><p>然而，这种插入图片的Hexo语法不仅较为繁琐，而且在编辑的时候还不可以在编辑器里即时查看图片，这十分不方便。。</p><img src="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231008110647937.png" class="" title="图九：使用Hexo插入图片语法——在编辑器中的视角"><p>至此，我们现在有了两种都不完美的插入图片的方法</p><ol><li>使用markdown语法，好处是可以很方便地插入图片，而且可以享受实时预览图片，但坏处是根本因为路径问题无法在网页显示图片。</li><li>使用Hexo语法，可以在网页显示图片，但每插入一张图片需要手动编辑图片代码，还要手动把图片放进资源文件夹，还不能实时预览。</li></ol><p>既然如此，我们可不可以将两种方法结合起来，实现无痛插入图片的梦想？</p><p>使用Hexo的插件就可以实现！</p><hr><h2 id="5-Hexo插件实现无痛插入图片"><a href="#5-Hexo插件实现无痛插入图片" class="headerlink" title="5. Hexo插件实现无痛插入图片"></a>5. Hexo插件实现无痛插入图片</h2><p><a href="https://github.com/xcodebuild/hexo-asset-image">hexo-asset-img</a>插件可以在文章编译为html之前，自动地将markdown的图片语法自动转换成Hexo的图片语法，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![example](blogname/example.jpg) --&gt; &#123;% asset_img example.jpg example %&#125;</span><br></pre></td></tr></table></figure><p>hexo-asset-img的安装命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>ps.或者可以使用以下命令安装，安装后删除node_modules文件夹中的hexo-asset-image文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure><p>pps.有不少教程安装了 hexo-asset-image 包，但我电脑上不行，踩了一天坑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>安装好插件后，还需要在Hexo的配置文件_config.yml里加入两个配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure><p>如此，就可以在网页上看到插入的图片了！</p><img src="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231008123837571.png" class="" title="图十：博客中插入本地图片效果图"><hr><h2 id="6-全部步骤"><a href="#6-全部步骤" class="headerlink" title="6. 全部步骤"></a>6. 全部步骤</h2><ol><li><p>安装Typora编辑器</p></li><li><p>在Typora中进入文件-&gt;偏好设置-&gt;图像，在插入图片时选择复制到指定路径，也就是那个在同目录下同名的资源文件夹.&#x2F;&amp;{filename}，并勾选</p><ul><li><p>对本地位置的图片应用上述规则</p></li><li><p>对网络位置的图片应用上述规则</p></li><li><p>优先使用相对路径</p></li></ul></li><li><p>通过以下命令安装插件hexo-asset-img</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure></li><li><p>在Hexo的配置文件_config.yml里将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>这个配置项由false改为ture</p><p>并加入以下两个配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="7-最终效果"><a href="#7-最终效果" class="headerlink" title="7. 最终效果"></a>7. 最终效果</h2><p>经过以上操作，我们以后就在Hexo博客中很方便地插入本地图片啦。</p><p>只需要将图片直接复制粘贴到Typora编辑器中，图片就会自动保存在资源文件夹中，并通过正确的路径保存，同时还可以支持编辑过程中的实时预览！</p><p>ps：有对于图片如何添加题注感兴趣的小伙伴可以看这篇博客</p><p><a href="https://blog.csdn.net/Lincain/article/details/89892249">Markdown 图片居中并添加标题_markdown图片标题-CSDN博客</a></p><p>参考链接🔗：</p><ul><li><p><a href="https://moeci.com/posts/hexo-typora/">Hexo + Typora + 开发Hexo插件 解决图片路径不一致 | yiyun’s Blog (moeci.com)</a></p></li><li><p><a href="http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/">hexo中完美插入本地图片 | ETRD</a></p></li><li><p><a href="https://hexo.io/zh-cn/docs/asset-folders">资源文件夹 | Hexo</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 插入图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络配置</title>
      <link href="/2023/10/05/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/10/05/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-ifconfig（Linux）-ipconfig（windows）"><a href="#1-ifconfig（Linux）-ipconfig（windows）" class="headerlink" title="1. ifconfig（Linux） &#x2F; ipconfig（windows）"></a>1. ifconfig（Linux） &#x2F; ipconfig（windows）</h2><p>作用：用于查看网卡配置信息</p><p>如IPV4地址、IPV6地址、工作状态、网络类型</p><p>参考博客：<a href="https://blog.csdn.net/l_liangkk/article/details/114959914">查看网卡信息：ifconfig命令及详细介绍_ifconfig ether_-纸短情长的博客-CSDN博客</a> </p><p><img src="/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20231007104602303.png" alt="image-20231007104602303"></p><h2 id="2-Ubuntu网络图标消失"><a href="#2-Ubuntu网络图标消失" class="headerlink" title="2. Ubuntu网络图标消失"></a>2. Ubuntu网络图标消失</h2><p>[Ubuntu 虚拟机没有网络图标（连接不上网络）_ubuntu没有网络图标_快乐科研喵的博客-CSDN博客](<a href="https://blog.csdn.net/qq_53089817/article/details/119490128#:~:text=%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9A">https://blog.csdn.net/qq_53089817/article/details/119490128#:~:text=解决方法：</a> 1、先关闭当前的虚拟机。 2、选择虚拟机设置查看网络配置是否正确（选择NAT连接）。 点击确定。,3、选择菜单编辑的虚拟网络编辑器。 选择NAT模式后 点击更改设置。 4、最后重启Ubuntu系统就有网络图标了。)</p><p><a href="https://blog.csdn.net/aggie4628/article/details/125765055">ubuntu-22.04无法连接网络-sudo service network-manager stop说不行-CSDN博客</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo service NetworkManager stop</span><br><span class="line"> </span><br><span class="line">sudo rm /var/lib/NetworkManager/NetworkManager.state</span><br><span class="line"> </span><br><span class="line">sudo service NetworkManager start</span><br></pre></td></tr></table></figure><h2 id="3-能联网但无法ping通github"><a href="#3-能联网但无法ping通github" class="headerlink" title="3. 能联网但无法ping通github"></a>3. 能联网但无法ping通github</h2><p>DNS有问题，在windows下打开C:\Windows\System32\drivers\etc\hosts文件（Linux系统下为&#x2F;etc&#x2F;hosts），在文件末尾追加以下两个ip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">146.75.81.194 github.global.ssl.fastly.net </span><br><span class="line">140.82.113.4 github.com</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/yw99999/article/details/117393293">一分钟解决连接git&#x2F;github失败问题!亲测可行！_ip直连可以但使用git连接不行-CSDN博客</a></p><p>同时关闭代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 首先，查一下当前全局的 http 代理：</span><br><span class="line">git config --global http.proxy</span><br><span class="line">// 如果有代理，就取消</span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line"></span><br><span class="line">// 再查 https 的代理：</span><br><span class="line">git config --global https.proxy</span><br><span class="line">// 同样的，有就取消</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo网站搭建教程</title>
      <link href="/2023/09/26/Hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
      <url>/2023/09/26/Hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果</p><p>你也可以像我一样</p><p>拥有一篇属于你自己的Hexo框架博客网站</p><p>那我觉得</p><p>这件事情</p><p>泰酷辣！！！！！！！！！</p><p><img src="/Hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/1684920495319.png" alt="泰裤辣"></p></blockquote><hr><p>这是一个手把手教你如何搭建一个属于你自己的Hexo框架博客网站的教程</p><hr><h2 id="第一节-Hexo简介"><a href="#第一节-Hexo简介" class="headerlink" title="第一节  Hexo简介"></a>第一节  Hexo简介</h2><p>Hexo是一款基于Node.js的静态博客框架，Hexo 使用 <a href="https://link.zhihu.com/?target=http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，可以方便地生成静态网页，并托管在GitHub和Gitee上，是搭建博客的首选框架，让你实现在不用购买云服务器的情况下拥有一个属于自己的博客网站的梦想。</p><span id="more"></span><hr><h2 id="第二节-前期准备"><a href="#第二节-前期准备" class="headerlink" title="第二节 前期准备"></a>第二节 前期准备</h2><p>在安装Hexo之前，需要安装Node.js</p><p>进一步想要将Hexo部署到Github或Gitee上，还必须通过Git</p><h3 id="2-1-安装Node-js"><a href="#2-1-安装Node-js" class="headerlink" title="2.1 安装Node.js"></a>2.1 安装Node.js</h3><ul><li>Windows：</li></ul><p>在官网下载LTS版本（下载nodejs自带npm）</p><p><img src="/Hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/image-20231003193554011.png" alt="image-20231003193554011"></p><p>官网下载地址：<a href="https://nodejs.org/en">Node.js (nodejs.org)</a></p><ul><li>Linux</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><p>安装成功验证：</p><p>在命令行中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>能够顺利输出node和npm的版本号即可</p><h3 id="2-2-安装git"><a href="#2-2-安装git" class="headerlink" title="2.2 安装git"></a>2.2 安装git</h3><ul><li><p>Windows</p><p>点击Git官网下载安装包，然后按Wizard安装即可</p></li></ul><ul><li><p>Linux (Ubuntu, Debian)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git-core</span><br></pre></td></tr></table></figure></li><li><p>Linux (Fedora, Red Hat, CentOS)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install git-core</span><br></pre></td></tr></table></figure></li></ul><p>git -v查看版本，验证是否安装成功</p><h3 id="2-3-安装Hexo"><a href="#2-3-安装Hexo" class="headerlink" title="2.3 安装Hexo"></a>2.3 安装Hexo</h3><p>通过npm可以直接安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>hexo -v查看版本，验证是否安装成功</p><hr><h2 id="第三节-搭建本地静态博客"><a href="#第三节-搭建本地静态博客" class="headerlink" title="第三节 搭建本地静态博客"></a>第三节 搭建本地静态博客</h2><h3 id="3-1-初始化Hexo博客框架"><a href="#3-1-初始化Hexo博客框架" class="headerlink" title="3.1  初始化Hexo博客框架"></a>3.1  初始化Hexo博客框架</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2-进入新建的文件夹，安装一下npm"><a href="#3-2-进入新建的文件夹，安装一下npm" class="headerlink" title="3.2  进入新建的文件夹，安装一下npm"></a>3.2  进入新建的文件夹，安装一下npm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><ul><li><p>npm install 更新可能会较慢，如果失败，可以尝试配置npm代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//  配置nmp代理来提高速度，如设置淘宝镜像</span><br><span class="line">npm config set registry https://registry.npm.taobao.org </span><br><span class="line"></span><br><span class="line">// 查看配置是否成功</span><br><span class="line">npm config get registry </span><br><span class="line"></span><br><span class="line">// 成功后重新npm install安装</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li></ul><p>进入文件夹后，目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p><strong>_config.yml</strong></p><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p><p><strong>package.json</strong></p><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> 渲染引擎 已默认安装，您可以自由移除。</p><p><strong>scaffolds</strong></p><p><a href="https://hexo.io/zh-cn/docs/writing#%E6%A8%A1%E7%89%88%EF%BC%88Scaffold%EF%BC%89">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来创建文件。</p><p>Hexo 的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改 <code>scaffold/post.md</code> 中的 Front-matter 内容，那么每次新建一篇文章时都会包含这个修改。</p><p><strong>source</strong></p><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p><p><strong>themes</strong></p><p><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p><h3 id="3-3-生成静态博客网站"><a href="#3-3-生成静态博客网站" class="headerlink" title="3.3  生成静态博客网站"></a>3.3  生成静态博客网站</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><h3 id="3-4-启动服务器"><a href="#3-4-启动服务器" class="headerlink" title="3.4  启动服务器"></a>3.4  启动服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>默认情况下，访问网址为：<a href="http://localhost:4000/%EF%BC%8C%E8%AE%BF%E9%97%AE%E8%BF%99%E4%B8%AA%E6%9C%AC%E5%9C%B0%E7%BD%91%E5%9D%80%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E8%87%AA%E5%B7%B1%E7%94%9F%E6%88%90%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99">http://localhost:4000/，访问这个本地网址就可以看到自己生成的博客网站</a></p><hr><h2 id="第四节-将博客部署到Github"><a href="#第四节-将博客部署到Github" class="headerlink" title="第四节 将博客部署到Github"></a>第四节 将博客部署到Github</h2><p>生成的博客网站只能在自己电脑本地访问当然没意思，所以接下来看看如何把写好的博客部署到Github Pages上。</p><h5 id="GitHub-Pages-是什么"><a href="#GitHub-Pages-是什么" class="headerlink" title="GitHub Pages 是什么?"></a>GitHub Pages 是什么?</h5><ul><li><a href="https://link.zhihu.com/?target=https://help.github.com/en/articles/what-is-github-pages">What is GitHub Pages? - GitHub Help</a></li></ul><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。</p><h5 id="Hexo-Github-Pages-发布博客原理"><a href="#Hexo-Github-Pages-发布博客原理" class="headerlink" title="Hexo + Github Pages 发布博客原理"></a>Hexo + Github Pages 发布博客原理</h5><p>在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 上完成博文的发布。</p><p>下面看看怎么实现</p><h3 id="4-1-Github创建个人仓库"><a href="#4-1-Github创建个人仓库" class="headerlink" title="4.1 Github创建个人仓库"></a>4.1 Github创建个人仓库</h3><p>点击New repository，开始新建仓库</p><p>新仓库的名字有固定格式要求，否组无法建站</p><p>格式为：用户名 + .github.oi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repository name eg.     yourusername.github.oi</span><br></pre></td></tr></table></figure><h3 id="4-2-安装hexo上传插件"><a href="#4-2-安装hexo上传插件" class="headerlink" title="4.2 安装hexo上传插件"></a>4.2 安装hexo上传插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="4-3-修改hexo配置文件指定仓库路径"><a href="#4-3-修改hexo配置文件指定仓库路径" class="headerlink" title="4.3 修改hexo配置文件指定仓库路径"></a>4.3 修改hexo配置文件指定仓库路径</h3><p>打开文件夹中的_config.yml文件，在文件最下面的Deployment部分修改配置</p><ol><li>type项填入”git”</li><li>repo项填入你的仓库的https或者ssh地址（点开仓库主页那个绿色的Code就能看到）</li><li>branch项填入你的仓库的分支名</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line"> type: git</span><br><span class="line"> repo: 你的仓库的https或者ssh地址</span><br><span class="line"> branch: &lt;你的仓库的分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="4-4-部署博客到Github"><a href="#4-4-部署博客到Github" class="headerlink" title="4.4 部署博客到Github"></a>4.4 部署博客到Github</h3><p>部署命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>部署完成后，可以在仓库主页的Deployment</p><hr><h2 id="第五节-常用命令"><a href="#第五节-常用命令" class="headerlink" title="第五节 常用命令"></a>第五节 常用命令</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a><font color=#0080ff>new</font></h3><p>新建一个博客。执行以下命令后，会在blog&#x2F;source&#x2F;_posts&#x2F;文件夹中新建一个同名的博客文件（.md格式）。通过设置tags字段还可以给这个文章添加标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;博客名称&quot;</span><br></pre></td></tr></table></figure><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a><font color=#0080ff>clean</font></h3><p>清除缓存文件（db.json）和已经生成的静态博客文件（public文件夹下的内容）.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a><font color=#0080ff>generate</font></h3><p>生成静态博客</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">简写为:hexo g</span><br></pre></td></tr></table></figure><p><font color=#0080ff>server</font></p><p>启动本地的博客服务器。默认情况下，访问网址为：<code>http://localhost:4000/</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line">简写为:hexo s</span><br></pre></td></tr></table></figure><p><font color=#0080ff>deploy</font></p><p>在相应的网站服务器（一般是Github或Gitee）中部署博客</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">简写为:hexo d</span><br></pre></td></tr></table></figure><hr><h2 id="第六节-访问网站"><a href="#第六节-访问网站" class="headerlink" title="第六节 访问网站"></a>第六节 访问网站</h2><p>部署在Github后的默认网站url为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://你的用户名.github.io/</span><br></pre></td></tr></table></figure><p>如果能成功访问，那么恭喜！你已经成功部署了一个属于自己的博客网站！</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
