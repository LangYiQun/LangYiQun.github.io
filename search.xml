<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux学习——鸟哥私房菜</title>
      <link href="/2023/11/13/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E9%B8%9F%E5%93%A5%E7%A7%81%E6%88%BF%E8%8F%9C/"/>
      <url>/2023/11/13/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E9%B8%9F%E5%93%A5%E7%A7%81%E6%88%BF%E8%8F%9C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/1.html">目录及概述 | 鸟哥的 Linux 私房菜：基础学习篇 第四版 (gitbooks.io)</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python import</title>
      <link href="/2023/11/10/Python-import/"/>
      <url>/2023/11/10/Python-import/</url>
      
        <content type="html"><![CDATA[<p>总结下python import的零碎知识</p><h1 id="import的作用"><a href="#import的作用" class="headerlink" title="import的作用"></a>import的作用</h1><p>import语句用来导入其他python文件（称为模块module），使用该模块里定义的类、方法或者变量，从而达到代码复用的目的。</p><h1 id="import-的基本用法："><a href="#import-的基本用法：" class="headerlink" title="import 的基本用法："></a>import 的基本用法：</h1><p><strong>基本概念：</strong></p><p>模块（module）：一般是以.py结尾的python文件，也可以是”.pyo”、”.pyc”、”.pyd”、”.so”、”.dll”结尾的文件。</p><p>模块可以定义函数、类、变量，也能包含可执行的代码。module来源有3种：<br>①Python内置的模块（标准库）；<br>②第三方模块；<br>③自定义模块。</p><p>包（package）：含有Python模块的文件夹</p><h3 id="用法一："><a href="#用法一：" class="headerlink" title="用法一："></a>用法一：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import [module_name\package_name]</span><br></pre></td></tr></table></figure><p>Python会在两个地方寻找这个模块，</p><p>第一是<strong>sys.path</strong>（通过运行代码<code>import sys; print(sys.path)</code>查看），os这个模块所在的目录就在列表sys.path中，一般安装的Python库的目录都可以在sys.path中找到，所以对于安装好的库，我们直接import即可。</p><p>第二个地方就是<strong>运行文件所在的目录</strong>。</p><h3 id="用法二："><a href="#用法二：" class="headerlink" title="用法二："></a>用法二：</h3><p>从包中引入模块的import语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from [module_name\package_name] import [module_name\package_name\method]</span><br></pre></td></tr></table></figure><p>导入一个包的时候，实际上就是导入包里面的<code>__init__.py</code>作为模块</p><h1 id="import的工作原理"><a href="#import的工作原理" class="headerlink" title="import的工作原理"></a>import的工作原理</h1><p>下面解析一下python的导入是如何工作的。假设你导入了一个abc模块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import abc</span><br></pre></td></tr></table></figure><p>python 是如何找到这个模块的呢？</p><ol><li><p>首先，python会在<code>sys.modules</code>中查找这个模块名，<code>sys.modules</code>是先前曾被导入过的所有模块的缓存。简单来说，就是之前被导入过的模块，都被暂时保存在里面。</p></li><li><p>如果在缓存中找不到这个模块，python接下来会在<strong>内置的模块（标准库）</strong>中寻找</p></li><li><p>如果内置模块也找不到，Python将会去<code>sys.path</code> 定义的文件夹列表中搜索，sys.path 中默认的路径为：</p><ul><li>当前目录的路径，自定义的模块就是在这里被找到的。</li><li>环境变量 PYTHONPATH 中指定的路径列表</li><li>Python 安装路径的 lib 目录所在路径</li></ul></li></ol><p>如果以上步骤都找不到这个模块，python会报错ModuleNotFoundError</p><p><a href="https://zhuanlan.zhihu.com/p/87238735">详解 Python import 机制 (一):import 中的基本概念 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python import </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像拼接和全景构造</title>
      <link href="/2023/11/08/%E5%9B%BE%E5%83%8F%E6%8B%BC%E6%8E%A5%E5%92%8C%E5%85%A8%E6%99%AF%E6%9E%84%E9%80%A0/"/>
      <url>/2023/11/08/%E5%9B%BE%E5%83%8F%E6%8B%BC%E6%8E%A5%E5%92%8C%E5%85%A8%E6%99%AF%E6%9E%84%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/learning_tortosie/article/details/85083825">使用OpenCV和Python拼接图像_opencv python 合并图片-CSDN博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RISCV工具链</title>
      <link href="/2023/11/08/RISCV%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
      <url>/2023/11/08/RISCV%E5%B7%A5%E5%85%B7%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是工具链？"><a href="#什么是工具链？" class="headerlink" title="什么是工具链？"></a>什么是工具链？</h1>]]></content>
      
      
      
        <tags>
            
            <tag> RISCV 工具链sh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chiplet论文阅读—— Methodology for Simulating Multi-chiplet Systems UsingOpen-source Simulators</title>
      <link href="/2023/11/07/A-Methodology-for-Simulating-Multi-chiplet-Systems-Using-Open-source-Simulators/"/>
      <url>/2023/11/07/A-Methodology-for-Simulating-Multi-chiplet-Systems-Using-Open-source-Simulators/</url>
      
        <content type="html"><![CDATA[<h1 id="一、论文总结"><a href="#一、论文总结" class="headerlink" title="一、论文总结"></a>一、论文总结</h1><h1 id="二、摘要"><a href="#二、摘要" class="headerlink" title="二、摘要"></a>二、摘要</h1><p>为了支持早期的Chiplets系统的设计空间探索，提出了一种基于gem5、snipe、gpgpu-sim等开源模拟器的Chiplets架构模拟方法。</p><p>并开源在Github上 <a href="https://github.com/FCAS-SCUT/chiplet_simulators">https://github.com/FCAS-SCUT/chiplet_simulators</a></p><h1 id="三、背景-目前待解决的问题"><a href="#三、背景-目前待解决的问题" class="headerlink" title="三、背景&amp;目前待解决的问题"></a>三、背景&amp;目前待解决的问题</h1><p>Chiplet是后摩尔时代一种很有前途的设计模式，但针对Chiplet的体系结构研究缺乏可靠的模拟器。</p><h2 id="1-Chiplets微架构的设计空间比SoC要大得多，因此需要探索的设计更多"><a href="#1-Chiplets微架构的设计空间比SoC要大得多，因此需要探索的设计更多" class="headerlink" title="1. Chiplets微架构的设计空间比SoC要大得多，因此需要探索的设计更多"></a>1. Chiplets微架构的设计空间比SoC要大得多，因此需要探索的设计更多</h2><p>主要包括<strong>核的组织方式</strong>（128核系统可以分为32cores * 4 chiplets、16cores * 8 chiplets等）、<strong>互联的拓扑结构</strong>、<strong>内存模型</strong></p><h2 id="2-现有开源的模拟器无法直接用于chiplets系统的模拟，因为以下两个原因："><a href="#2-现有开源的模拟器无法直接用于chiplets系统的模拟，因为以下两个原因：" class="headerlink" title="2. 现有开源的模拟器无法直接用于chiplets系统的模拟，因为以下两个原因："></a>2. 现有开源的模拟器无法直接用于chiplets系统的模拟，因为以下两个原因：</h2><ul><li><p>没有精确的Chiplet间互联模型。现有开源模拟器（如gem5、sniper、Graphite、gpgpu-sim）都是纯网络模拟器（network-only simulator），缺乏详细准确的中介层互连延迟和功率模型{❓意思是仅能够精确模拟chiplet内部多核的互联，对chiplet间的互联模拟不精确吗❓}。</p></li><li><p>无法进行大规模并行模拟。Multi-Chiplets系统一般具有大量的核，这样的系统模拟起来会很耗时，因此需要通过大规模的并行来加速模拟。虽然Graphite和sniper支持并行模拟，但并不支持精确的互联建模。</p></li></ul><span id="more"></span><h1 id="四、文章贡献"><a href="#四、文章贡献" class="headerlink" title="四、文章贡献"></a>四、文章贡献</h1><p>文章通过集成和修改开源模拟器，提出了一种模拟Multi-Chiplets系统的方法。</p><ol><li>现有开源模拟器用来模拟单个chiplet，通过多开[reuse]模拟器并行运行实现Multi-Chiplets。并提出模拟器间进程通信和同步协议[a full set of inter-simulator-process communication and synchronization protocol]来模拟chiplets之间的通信。</li><li>基于插入器的互连[Interposer-based interconnection]是使用特定参数精确建模的。互联可以通过<u>仅网络方式[Network Only]</u>、<u>系统调用仿真[SE]</u>、<u>全系统仿真[FS]</u>来模拟。可以容易的实现各种chiplet间和chiplet内的网络拓扑。</li><li>支持两种典型的内存模型：消息传递和共享内存</li><li>提出了一种基于文件的模拟器间进程通信和同步协议，使得多个模拟器进程同步运行，同理可集成其他模拟器。通过时序模型文件[Timing models files]和功能模型文件[Functional models files]支持远程存储器读写。这种通过进程的多开模拟器方法可以很好地实现并行模拟。</li></ol><h1 id="五、Multi-Chiplets系统仿真框架"><a href="#五、Multi-Chiplets系统仿真框架" class="headerlink" title="五、Multi-Chiplets系统仿真框架"></a>五、Multi-Chiplets系统仿真框架</h1><p>此部分对应文章第三章</p><h2 id="3-1-框架总览"><a href="#3-1-框架总览" class="headerlink" title="3.1 框架总览"></a>3.1 框架总览</h2><img src="/2023/11/07/A-Methodology-for-Simulating-Multi-chiplet-Systems-Using-Open-source-Simulators/image-20231107214349591.png" class="" title="image-20231107214349591"><ul><li><strong>电路和物理层[Circuit and physical layer]：</strong></li><li><strong>微体系结构和chiplet内部层 [micro-architectural and intra-chiplet layer]：</strong>每个单独的chiplet由一个模拟器进行模拟，模拟器还用于模拟路由器间的通道</li><li><strong>chiplet间网络层[ inter-chiplet network layer]：</strong>该框架利用集中式网络管理器读取配置文件，以配置chiplet间的网络拓扑</li><li><strong>系统层[system layer]：</strong>通过功能模型文件和时序模型文件来实现共享内存模型和分布式内存模型。<ul><li>功能模型文件：远程读写请求写入每对模拟器进程的功能模型文件。</li><li>时序模型文件：积累远程读写请求的延迟❓用来统计吗❓。</li></ul></li><li><strong>应用层[Application layer]：</strong>该框架在应用层为程序员提供了用于远程读写的API，程序员可以借助此API开发测试程序。在gem5中的FS模式下，这个API使用m5 opt向主机生成时序模型文件和功能模型文件，用于模拟器之间的进程通信。在gem5的SE模式下，这个API系统调用处理程序向主机生成时序和功能模型文件，用于模拟器之间的进程通信。</li></ul><h2 id="3-2-远程读写协议"><a href="#3-2-远程读写协议" class="headerlink" title="3.2 远程读写协议"></a>3.2 远程读写协议</h2><h3 id="（1）远程读-Remote-Read"><a href="#（1）远程读-Remote-Read" class="headerlink" title="（1）远程读 Remote Read"></a>（1）远程读 Remote Read</h3><p>远程读遵从握手协议，即Source Chiplet发送读取请求，Destination Chiplet回复</p><img src="/2023/11/07/A-Methodology-for-Simulating-Multi-chiplet-Systems-Using-Open-source-Simulators/image-20231107220406161.png" class="" title="image-20231107220406161"><p>Source Chiplet有一个计时器，如果收到NACK或计时器超时未收到回复，则重新发送请求。其中，NACK用于模拟传输发生错误。</p><ul><li><p>在Destination Chiplet上，如果根据请求读取数据成功，则其接口节点，用ACK进行回复，它还可以通过回复NACK模拟传输错误</p></li><li><p>其中，接口节点[Interface node]是每个Chiplet中负责Chiplet间通信的一个或多个节点</p></li></ul><h3 id="（2）远程写-Remote-Write"><a href="#（2）远程写-Remote-Write" class="headerlink" title="（2）远程写 Remote Write"></a>（2）远程写 Remote Write</h3><p>远程写是非阻塞的。如果写入成功，则源Chiplet不受影响；若写入失败，则重新发送写请求。</p><p>存在一个缓冲区，用来保存未被确认的写入数据。</p><h3 id="计算远程读请求的传输时间"><a href="#计算远程读请求的传输时间" class="headerlink" title="计算远程读请求的传输时间"></a>计算远程读请求的传输时间</h3><p>为了计算远程读请求的传输时间[transmission time]，Destination Chiplet的接口节点应该添加请求包从Source Chiplet发送过来的传输延迟；Source Chiplet一旦接收到回复，就计算此次请求的往返延迟（请求包和相应包的传输延迟）</p><p>全局内存一致性由软件管理。</p><p>尚未实现多芯片系统实现高速缓存&#x2F;内存一致性协议。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在该系统中存在两种类型的死锁：</p><p>第一种是**路由级死锁[routing level deadlock]<strong>，由数据包的循环依赖性引起。必须使用无死锁路由算法。第二种是</strong>协议级死锁[protocol level deadlock]**，由请求和应答数据包之间的依赖关系引起。</p><h2 id="3-3-模拟器间进程通信和同步协议"><a href="#3-3-模拟器间进程通信和同步协议" class="headerlink" title="3.3 模拟器间进程通信和同步协议"></a>3.3 模拟器间进程通信和同步协议</h2><p>模拟器间进程通信[inter-simulator-process communi-cation]使用两种类型的文件，即<u>功能模型文件</u>和<u>时序模型文件</u>。每个模拟器为其他模拟器产生这两种类型的文件，并读取其他模拟器的这两种文件。</p><p>系统支持两种互联架构：**平铺式网络拓扑[tiled inter-chiplet network topologies]<strong>和</strong>集中式网络拓扑[centralized inter-chiplet network topologies]**，在平铺式网络拓扑中，每个Chiplet有一个用于连接其他Cihplet的互连单元（AMD EPYC采用这样的网络架构）。在集中式网络拓扑中，有一个中心Chiplet，它连接这其他负责计算的Chiplet（AMD Ryzen采用了这样的架构）。</p><p>为了支持互联架构，提出了一种用来模拟中介层网络[ interposer-level network ]的网络管理器[ network manager ]</p><h3 id="使用功能模型文件和时序模型文件进行远程读取的过程："><a href="#使用功能模型文件和时序模型文件进行远程读取的过程：" class="headerlink" title="使用功能模型文件和时序模型文件进行远程读取的过程："></a>使用功能模型文件和时序模型文件进行远程读取的过程：</h3><ul><li>Step 1：Chiplet i 通过API初始化了一个远程读Chiplet j 某个存储地址的请求。请求线程被stalled</li><li>Step 2：请求包首先被发送到接口节点</li><li>Step 3：接口节点分别生成功能模型文件$$F_{ik}$$和时序模型文件$$T_{iN}$$，其中，$$T_{iN}$$被发送到网络管理器，$$F_{ik}$$处理Chiplet间网络路由，并把该</li></ul><img src="/2023/11/07/A-Methodology-for-Simulating-Multi-chiplet-Systems-Using-Open-source-Simulators/image-20231111131252278.png" class="" title="image-20231111131252278"><h1 id="开源仿真器说明书"><a href="#开源仿真器说明书" class="headerlink" title="开源仿真器说明书"></a>开源仿真器说明书</h1><p>摘自<em>基于多芯粒集成的 X86 指令集共享式储存仿真器说明书</em></p><h2 id="一、-简介"><a href="#一、-简介" class="headerlink" title="一、 简介"></a>一、 简介</h2><p>基于多芯粒集成 CPU 共享式储存仿真器是一款用于模拟多芯粒系统中 CPU 芯粒的仿真软件。它的主要功能是：模拟在 CPU 组成的多芯粒系统中，一个操作系统中某个或多个应用程序运行的过程，并给出运行结果以及各项性能指标，如程序的运行时间等。</p><p>二、gem5底层架构</p><h2 id="三、仿真原理"><a href="#三、仿真原理" class="headerlink" title="三、仿真原理"></a>三、仿真原理</h2><p>每个chiplet 拥有自己独一无二的编号和自己的独特的共享储存区域，但是该储存区域可以被任何Chiplet读写。每个共享储存区域以 communication 开头表征，被所有 chiplet 共享。</p><p>当chiplet 需要从其他 chiplet 接收数据时，它会以自身 chiplet 编号对共享储存对应的区域进行检索，当检索到储存中有之前未读且停留在共享储存最久的数据时，它会将其读入自己的储存中，并标记该数据为已读。</p><p><strong>1. 共享储存读操作</strong></p><p>在功能模型上，读操作包括根据 chiplet 编号搜索储存，查找最久的未读数据以及标记本次读入的数据（若没有读入数据则跳过）。在 gem5 中，gadia_receive(a)函数执行读操作，a 表示本次要搜索的 chiplet 编号对应的储存。每次执行该函数时，gem5 将访问communicationa 文件，并读取该文件中最久没有被读取过内容读取完成之后将标记该数据已读并返回该数据，否则返回特定的数字(uint64_t)-1 的值。在时序模型上，读操作的时序由写操作的时序模型一起计算。</p><p><strong>2. 共享储存写操作</strong></p><p>在功能模型上，写操作包括根据 chiplet 的编号查找对应储存地址，写入数据。在gem5 中，gadia_call(a, b, c, d)函数执行写操作，其中 a 为当前 chiplet 编号，b 为数据将要传送的目标 chiplet 编号，c 为数据本身，d 为是否初始化共享储存。当 d 参数不要求初始化共享储存空间时，gem5 将访问文件 communicationb ，并在其内容追加内容 “gem5 当前 cycle a b c \n”。在时序模型上，每次写操作执行时，每个 chiplet 会自动检测当前的 cycle 数并将其一起写入共享储存，在仿真完成之后将交由 popnet 计算出共享储存的读写操作的延迟 cycle数。</p><h2 id="四、仿真器工作流程"><a href="#四、仿真器工作流程" class="headerlink" title="四、仿真器工作流程"></a>四、仿真器工作流程</h2><img src="/2023/11/07/A-Methodology-for-Simulating-Multi-chiplet-Systems-Using-Open-source-Simulators/image-20231111154718789.png" class="" title="image-20231111154718789"><ul><li><strong>Step1</strong> 编写多机版本的负载程序，并编译成二进制文件。</li><li><strong>Step1</strong> 挂载img镜像文件的方式将二进制负载程序放入img文件</li><li><strong>Step1</strong> 启动多个gem5和m5</li><li><strong>Step1</strong> 运行负载程序</li><li><strong>Step1</strong> 编译附录A中的辅助程序，该程序统计共享储存的通信文件并输出 popnet 的输入文件，得到以 bench 开头的 trace 文件</li><li><strong>Step1</strong> 以这些bench 开头的文件为输入，使用 popnet 计算片间通信。</li></ul><p>popnet 是一款开源的互连网络模拟器，能够根据网络节点间的通信记录信息（trace 文件）计算出网络传递数据包的平均延迟以及总能耗。</p><h2 id="五、仿真器使用具体步骤"><a href="#五、仿真器使用具体步骤" class="headerlink" title="五、仿真器使用具体步骤"></a>五、仿真器使用具体步骤</h2><h3 id="1-通过github或gitee下载仿真器源码"><a href="#1-通过github或gitee下载仿真器源码" class="headerlink" title="1. 通过github或gitee下载仿真器源码"></a>1. 通过github或gitee下载仿真器源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Github</span><br><span class="line">git clone https://github.com/FCAS-SCUT/chiplet_simulators</span><br><span class="line"># Gitee</span><br><span class="line">git clone https://gitee.com/hic_0757/Chiplet-Gem5-sharedMemory</span><br></pre></td></tr></table></figure><h3 id="2-构建X86环境"><a href="#2-构建X86环境" class="headerlink" title="2. 构建X86环境"></a>2. 构建X86环境</h3><p>切换到gem目录下，然后构建环境，运行全系统模拟</p><h3 id="3-挂载测试程序"><a href="#3-挂载测试程序" class="headerlink" title="3. 挂载测试程序"></a>3. 挂载测试程序</h3><h3 id="4-开启gem5和m5"><a href="#4-开启gem5和m5" class="headerlink" title="4.开启gem5和m5"></a>4.开启gem5和m5</h3><p>进入gem文件夹，开启gem5的FS模拟</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./build/X86/gem5.opt ./configs/example/fs.py --kernel=[vmlinux 二进制文件] --disk-image=[img 格式的系统镜像文件] -n [cpu 核数]</span><br><span class="line"></span><br><span class="line">./build/X86/gem5.opt ./configs/example/fs.py --kernel=/binaries/x86-linux-kernel-4.19.83 --disk-image=disks/x86-parsec -n 2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Chiplet论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chiplet </tag>
            
            <tag> 模拟器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc编译器参数</title>
      <link href="/2023/11/07/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%82%E6%95%B0/"/>
      <url>/2023/11/07/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是GCC？"><a href="#一、什么是GCC？" class="headerlink" title="一、什么是GCC？"></a>一、什么是GCC？</h1><p>GCC(GNU Compiler Collection)即GNU编译器套件，属于一种编程语言编译器。其原名也为GCC（GNU C Compiler），虽然缩写一样但是仅可编译C语言，后来经过发展才变成支持编译多语言。GCC的初衷是为GNU操作系统专门编写的一款编译器，原本的GNU是专用于编译C代码，现如今已扩展为可以编译C、C++、Java、Objective-C等多种编程语言的编译器集合了。</p><h1 id="二、GCC、gcc、g-三者有何关系？"><a href="#二、GCC、gcc、g-三者有何关系？" class="headerlink" title="二、GCC、gcc、g++三者有何关系？"></a>二、GCC、gcc、g++三者有何关系？</h1><p><strong>gcc</strong>（GUN C Compiler）是GCC中的c编译器，而**g++**（GUN C++ Compiler）是GCC中的c++编译器。<br>gcc和g++两者都可以编译c和cpp文件，但存在差异。</p><ul><li><p>gcc在编译cpp时语法按照c来编译但默认不能链接到c++的库（gcc默认链接c库，g++默认链接c++库）。</p></li><li><p>g++编译.c和.cpp文件都统一按cpp的语法规则来编译。</p><p>  一般<strong>编译c用gcc</strong>，**编译c++用g++**。</p></li></ul><h1 id="三、GCC编译步骤"><a href="#三、GCC编译步骤" class="headerlink" title="三、GCC编译步骤"></a>三、GCC编译步骤</h1><p>GCC广义上的编译流程可分为以下四个部分：</p><ul><li>预处理（Pre-Processing）</li><li>编译（Compiling）</li><li>汇编（Assembling）</li><li>链接（Linking）</li></ul><p><a href="https://blog.csdn.net/qq_42475711/article/details/85224010">浅显易懂的GCC使用教程——初级篇_gcc -ddebug-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_50697073/article/details/123759516?app_version=6.2.2&csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22123759516%22,%22source%22:%22m0_52631482%22%7D&utm_source=app">【精选】gcc的基本使用-CSDN博客</a></p><p><a href="https://blog.csdn.net/wohu1104/article/details/110789570">GCC 编译 C(C++)静态链接库（gcc -L、gcc -l）和动态链接库（gcc -fPIC -shared）的创建和使用_c++ 链接 -l-CSDN博客</a></p><p><a href="https://www.cnblogs.com/alan666/p/8311984.html">gcc -I -L -l区别 - 隔壁王叔叔a - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（六）</title>
      <link href="/2023/11/06/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2023/11/06/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Checkpoints"><a href="#Checkpoints" class="headerlink" title="Checkpoints"></a>Checkpoints</h1><p>官网介绍<a href="https://www.gem5.org/documentation/general_docs/checkpoints/">gem5: Checkpoints</a></p><p>检查点相当于gem5模拟系统的快照。通常来说，创建一个全系统模拟需要大量的时间，但为这个模拟系统创建了检查点之后，可以在下次启动时将模拟系统快速回复至检查点状态，从而节省系统启动时间。</p><p>一旦创建了checkpoint，gem5会在输出目录中增加一个cpt目录（cpt.TICKNUMBER，其中TICKNUMBER为创建此检查点时的Tick值），该目录存储checkpoint相关信息。</p><h2 id="1-创建检查点"><a href="#1-创建检查点" class="headerlink" title="1. 创建检查点"></a>1. 创建检查点</h2><p>有三种创建检查点的方式：</p><ul><li>启动模拟器环境后，在模拟器终端执行<strong>m5 checkpoint命令</strong>，也可以将其包含在运行脚本中。</li><li>专门有一个<strong>伪指令</strong>用于创建检查点，例如可以在应用中创建检查点（还不熟悉）</li><li>python配置脚本（fs.py、ruby_fs.py）中通过<strong>命令行参数</strong>设置检查点。–take-checkpoints选项可以定期储存检查点，–checkpoint-at-end可以在模拟结束创建检查点</li></ul><h2 id="2-恢复检查点"><a href="#2-恢复检查点" class="headerlink" title="2. 恢复检查点"></a>2. 恢复检查点</h2><p>检查点恢复需要在启动系统模拟时设置几个命令行参数</p><ul><li><strong>–checkpoint-dir</strong>：用于指定使用的checkpoint的cpt文件夹所在路径</li><li><strong>-r</strong>：用于指定使用的checkpoint的序号</li><li><strong>–restore-with-cpu</strong>用于指定恢复时CPU的类型</li></ul><p>启动系统模拟后，再通过m5term接入模拟系统，然后很快就会进入到命令行了。</p><h1 id="m5"><a href="#m5" class="headerlink" title="m5"></a>m5</h1><p>在使用m5时首先要用Scons编译</p><h1 id="修改镜像文件"><a href="#修改镜像文件" class="headerlink" title="修改镜像文件"></a>修改镜像文件</h1><p>在全系统模拟中，运行程序一般比较慢，特别是一些比较大的benchmark，如果在全系统模拟中编译会极慢，因此需要将benchmark在宿主机编译完之后，直接放在镜像文件中，这样就可以开启模拟后直接运行benchmark了。</p><p>然而，镜像文件不可以像文件一样直接操作，必须进行磁盘挂载。在 Linux 中，挂载磁盘是将新的磁盘设备连接到文件系统的过程，使得该磁盘可用于存储和访问文件。简单来说，就是将镜像文件挂载到一个文件夹中，再像文件一样直接操作。</p><p>首先，创建一个文件夹作为挂载点。在disks文件夹中新建文件夹.&#x2F;mnt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ./mnt</span><br></pre></td></tr></table></figure><p>然后，使用mount命令挂载镜像文件到指定挂载点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o loop,offset=1048576 镜像文件 ./mnt</span><br></pre></td></tr></table></figure><p>此时，可以通过df -h命令查看磁盘设备列表，并打开.&#x2F;mnt文件夹可以看到镜像文件的内容。</p><img src="/2023/11/06/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/image-20231107111710727.png" class="" title="image-20231107111710727"><img src="/2023/11/06/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/image-20231107111521636.png" class="" title="image-20231107111521636"><p>将测试文件放入挂载点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp 测试文件 ./mnt</span><br></pre></td></tr></table></figure><p>最后，取消挂载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount ./mnt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MobaXterm通过SSH连接虚拟机</title>
      <link href="/2023/11/04/MobaXterm%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2023/11/04/MobaXterm%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="1-在Ubuntu下安装SSH服务"><a href="#1-在Ubuntu下安装SSH服务" class="headerlink" title="1. 在Ubuntu下安装SSH服务"></a>1. 在Ubuntu下安装SSH服务</h2><p>查看SSH是否启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd status</span><br></pre></td></tr></table></figure><span id="more"></span><p>如果没有安装SSH，会出现以下报错</p><img src="/2023/11/04/MobaXterm%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20231104100420401.png" class="" title="image-20231104100420401"><p>那么需要通过以下命令进行安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure><p>安装完毕后再次查看SSH是否启动，若成功，会出现以下输出</p><img src="/2023/11/04/MobaXterm%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20231104100550221.png" class="" title="image-20231104100550221"><h2 id="2-查看虚拟机ip"><a href="#2-查看虚拟机ip" class="headerlink" title="2. 查看虚拟机ip"></a>2. 查看虚拟机ip</h2><p>通过ifconfig命令查看虚拟机ip</p><img src="/2023/11/04/MobaXterm%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20231104100736596.png" class="" title="image-20231104100736596"><p>可以虚拟机ip为192.168.199.128</p><h2 id="3-通过SSH连接虚拟机"><a href="#3-通过SSH连接虚拟机" class="headerlink" title="3. 通过SSH连接虚拟机"></a>3. 通过SSH连接虚拟机</h2><p>打开MobaXterm，首先进入主页的Session，然后选择SSH，再输入虚拟机IP，最后OK即可连接虚拟机。</p><img src="/2023/11/04/MobaXterm%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20231104101010696.png" class="" title="image-20231104101010696"><p>一般通过SSH连接虚拟机是为了能够在主机和虚拟机之间互传文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> MobaXterm 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（五）</title>
      <link href="/2023/11/02/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2023/11/02/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="FS全系统模拟"><a href="#FS全系统模拟" class="headerlink" title="FS全系统模拟"></a>FS全系统模拟</h1><h2 id="一、构建X86系统"><a href="#一、构建X86系统" class="headerlink" title="一、构建X86系统"></a>一、构建X86系统</h2><p>切换到gem目录下，使用Scons进行构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scons ./build/X86/gem5.opt -j [NumberOfThread]</span><br></pre></td></tr></table></figure><h2 id="二、获取镜像文件和Linux内核文件"><a href="#二、获取镜像文件和Linux内核文件" class="headerlink" title="二、获取镜像文件和Linux内核文件"></a>二、获取镜像文件和Linux内核文件</h2><p> FS模拟会启动Linux操作系统，会模拟系统的所有组件。因此需要给系统配置相应的Linux内核以及磁盘镜像</p><p>img 文件和 vmlinux 文件是 gem5 中启动操作系统所需的两个重要文件。</p><ul><li><strong>磁盘镜像（img 文件）</strong>储存了操作系统的文件系统和应用程序，这些文件是操作系统运行所必需的。操作系统需要文件系统来存储和组织文件，需要应用程序来实现特定功能。</li><li><strong>Linux内核文件（vmlinux 文件）</strong>储存了操作系统的内核代码。内核是操作系统的核心部分，负责管理系统资源和提供基本的服务。如果没有内核，操作系统就无法正常启动和运行。</li></ul><h3 id="1-自动获取脚本"><a href="#1-自动获取脚本" class="headerlink" title="1. 自动获取脚本"></a>1. 自动获取脚本</h3><p>官方教程中使用的img和vmlinux直接来自于gem5资源库（resource repository），直接利用Resource类（<a href="https://www.gem5.org/documentation/general_docs/gem5_resources/">gem5: gem5-resources</a>）下载到本地。Gem5官网提供了通过Resource自动获取img文件和vmlinux文件，并运行全系统模拟的示例脚本，脚本代码在<code>configs/example/gem5_library/</code>目录中。以configs&#x2F;example&#x2F;gem5_library&#x2F;x86-parsec-benchmarks.py为例</p><p>gem5可以通过KVM对仿真进行加速，但有的CPU不支持KVM，查看你的处理器是否支持KVM。可以通过安装sudo apt install qemu-kvm并通过kvm-ok来查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装qemu-kvm</span><br><span class="line">sudo apt install qemu-kvm</span><br><span class="line"># 查看KVM是否安装</span><br><span class="line">kvm-ok</span><br></pre></td></tr></table></figure><p>我的处理器并不支持KVM</p><img src="/2023/11/02/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/image-20231114123822874.png" class="" title="image-20231114123822874"><p>因此只能关闭KVM</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Step1 使用requires进行检查时将kvm_required置为False</span><br><span class="line">requires(</span><br><span class="line">    isa_required=ISA.X86,</span><br><span class="line">    coherence_protocol_required=CoherenceProtocol.MESI_TWO_LEVEL,</span><br><span class="line">    # kvm_required=True,</span><br><span class="line">    kvm_required=False,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Step2 设置处理器时，均使用TIMING处理器</span><br><span class="line">processor = SimpleSwitchableProcessor(</span><br><span class="line">    # starting_core_type=CPUTypes.KVM,</span><br><span class="line">    starting_core_type=CPUTypes.TIMING,</span><br><span class="line">    switch_core_type=CPUTypes.TIMING,</span><br><span class="line">    isa=ISA.X86,</span><br><span class="line">    num_cores=2,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样就可以运行模拟了，使用的benchmark和size可以在该脚本的注释中查看</p><img src="/2023/11/02/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/image-20231114093504398.png" class="" title="image-20231114093504398"><img src="/2023/11/02/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/image-20231114093427885.png" class="" title="image-20231114093427885"><h3 id="2-自己制作img文件"><a href="#2-自己制作img文件" class="headerlink" title="2.自己制作img文件"></a>2.自己制作img文件</h3><p>二、设置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改bashrc文件以添加环境变量</span><br><span class="line">vim ~/.bashrc</span><br><span class="line"># 在打开的文件的尾部加入环境变量</span><br><span class="line">export M5_PATH=gem5绝对路径/full-system-image</span><br></pre></td></tr></table></figure><h1 id="m5端"><a href="#m5端" class="headerlink" title="m5端"></a>m5端</h1><h3 id="1-m5介绍"><a href="#1-m5介绍" class="headerlink" title="1. m5介绍"></a>1. m5介绍</h3><h3 id="2-启动m5端"><a href="#2-启动m5端" class="headerlink" title="2. 启动m5端"></a>2. 启动m5端</h3><p>启动m5有两种方法，一种是通过系统自带的telnet或者gem5中提供的m5term工具，推荐m5term。</p><h4 id="（1）telnet"><a href="#（1）telnet" class="headerlink" title="（1）telnet"></a>（1）telnet</h4><p>使用不需要额外安装或配置，直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telent &lt;host&gt; &lt;post&gt;</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 3456</span><br><span class="line">// 3456表示用于连接模拟系统的端口号，再gem5模拟中，默认的起始端口号为3456，</span><br><span class="line">// 当后续需要模拟多个系统，端口号需要每次增加1</span><br></pre></td></tr></table></figure><h4 id="（2）m5term"><a href="#（2）m5term" class="headerlink" title="（2）m5term"></a>（2）m5term</h4><p>使用m5前，必须先根据源码构建该工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Step 1 切换到gem5/util/term目录</span><br><span class="line"> cd util/term</span><br><span class="line"># Step 2 编译</span><br><span class="line"> gcc  -o m5term term.c</span><br><span class="line"># Step 3 安装</span><br><span class="line"> sudo install -o root -m 555 m5term /usr/local/bin</span><br></pre></td></tr></table></figure><p>之后，就可以通过与telnet类似的方式启动m5了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m5term &lt;host&gt; &lt;post&gt;</span><br></pre></td></tr></table></figure><h3 id="3-生成m5以及对应的libm5-a库"><a href="#3-生成m5以及对应的libm5-a库" class="headerlink" title="3. 生成m5以及对应的libm5.a库"></a>3. 生成m5以及对应的libm5.a库</h3><p>要在应用程序中使用m5提供的指令，首先需要生成m5以及对应的libm5.a库</p><p>ps: 编译之前好像要确保安装clang，并保证其版本为6-10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Step 1 切换到gem5/util/m5目录</span><br><span class="line"> cd util/m5</span><br><span class="line"># Step 2 编译</span><br><span class="line"> scons build/x86/out/m5</span><br></pre></td></tr></table></figure><p> 利用libm5.a库，即可在应用程序中使用libm5.a库中的函数</p><p>编写如下测试程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">########hello_m5.cpp##########</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;gem5/m5ops.h&quot;  //引入m5ops.h库</span><br><span class="line"> </span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    m5_reset_stats(0,0);  //重置模拟统计数据，m5库中实现的函数</span><br><span class="line"> </span><br><span class="line">    printf(&quot;Hello world!\n&quot;);</span><br><span class="line">    </span><br><span class="line">    m5_dump_stats(0,0);  //将模拟统计数据保存，m5库中实现的函数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用g++和库进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g++ -o hello_m5 hello_m5.cpp -std=c++11 \</span><br><span class="line">-Igem5绝对路径/include \</span><br><span class="line">-Lgem5绝对路径/util/m5/build/x86/out -lm5</span><br><span class="line"></span><br><span class="line">g++ -o hello_m5 hello_m5.cpp -std=c++11 \</span><br><span class="line">-I$GEM5/include \</span><br><span class="line">-L$GEM5/util/m5/build/x86/out -lm5</span><br></pre></td></tr></table></figure><p>然后将编译出的可执行文件通过文件挂载的方式存储到img镜像文件中。</p>]]></content>
      
      
      <categories>
          
          <category> Gem5模拟器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gem5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多级存储层次</title>
      <link href="/2023/10/31/%E5%A4%9A%E7%BA%A7%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1/"/>
      <url>/2023/10/31/%E5%A4%9A%E7%BA%A7%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、多级存储层次"><a href="#一、多级存储层次" class="headerlink" title="一、多级存储层次"></a>一、多级存储层次</h1><p>用多种存储器构成存储层次结构是提高存储系统整体性能的必要方法。</p><h2 id="1-1-为什么需要多级存储层次"><a href="#1-1-为什么需要多级存储层次" class="headerlink" title="1.1 为什么需要多级存储层次"></a>1.1 为什么需要多级存储层次</h2><p>存储器的三个主要指标是<strong>容量</strong>、<strong>速度</strong>和<strong>单位价格</strong>。我们希望设计“容量大、速度快、价格低”的存储系统，例如，大规模应用程序要求存储系统容量大、价格低；然而，存储系统又应该在CPU执行程序时以足够快的素的向CPU提供指令和数据。然而，目前还没有一种存储器技术能满足这三个要求，现有的存储器技术只能满足其中一或两个要求。</p><p>解决这些矛盾的方法，就是采用多种存储器技术，构成多级存储层次。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cache基础知识</title>
      <link href="/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Cache技术"><a href="#一、Cache技术" class="headerlink" title="一、Cache技术"></a>一、Cache技术</h1><p>现代计算机都在CPU和主存之间设置一个高速、小容量的缓冲处理器，称为Cache。Cache的存在填补了CPU和主存在速度上的巨大差距，对于提高整个计算机系统的性能有重要意义，是现代计算系统必不可少的部件，然而，<strong>Cache对程序员是透明的</strong>。</p><p>此外，Cache技术这个此被广泛用于指代利用缓冲技术来实现局部数据再利用的技术。其能够缓解两个部件之间访问数据速度差距较大的问题，在硬盘、网页中都能看见缓冲技术的身影，本文专指CPU与主存之间的Cache。</p><span id="more"></span><h1 id="二、Cache结构"><a href="#二、Cache结构" class="headerlink" title="二、Cache结构"></a>二、Cache结构</h1><p>Cache 和主存间信息的交互<strong>按块来组织</strong>。Cache和主存均被分割为大小相同的块，块大小（blocksize）通常为2的幂次方字节。</p><p>【图一：Cache、内存被分割为块】</p><p>CPU通过访存指令中的主存地址向Cache请求主存数据，该主存地址被分割为两部分：<strong>块地址</strong>和<strong>块内位移</strong></p><img src="/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231031155331776.png" class="" title="内存地址分割为块地址和块内偏移"><p>【图二：主存地址被分割为块地址和块内偏移】</p><p>硬件会<u>根据<strong>块地址</strong>查找该块在Cache中的位置</u>，再<u>通过<strong>块内位移</strong>确定所访问的数据再该块中的位置</u>。</p><h1 id="三、Cache工作原理"><a href="#三、Cache工作原理" class="headerlink" title="三、Cache工作原理"></a>三、Cache工作原理</h1><p>在每个存储层次中，都绕不开这四个关键问题：</p><ul><li>映像规则：当把一个块从主存调入Cache时，可以放到哪些位置上？</li><li>查找算法：当所要访问的块在Cache中时，如何找到该块？</li><li>替换算法：当发生失效时，应该替换Cache中的哪一个块？</li><li>写策略：当进行写访问时，应该如何操作？</li></ul><p>下面一一进行探讨：</p><h2 id="（1）映像规则"><a href="#（1）映像规则" class="headerlink" title="（1）映像规则"></a>（1）映像规则</h2><p>当要把一个块从主存调入Cache中时，首先要确定这个块可以放在Cache中的哪些位置上。一般来说，主存的容量远远大于Cache的容量，因此要确定较多的主存块与较少的Cache块之间的对应关系，这就是Cache与主存间的映像规则。主要有以下三种：</p><h3 id="1-直接映像"><a href="#1-直接映像" class="headerlink" title="1. 直接映像"></a>1. 直接映像</h3><p>直接映像（Direct Mapping）是指每个主存块只能被放置到唯一的一个Cache块位置。</p><p>通常采用直接取模的方式进行映像。对于主存的第i块（即块地址为i），设它映像到Cache的第j块（即块地址为j），Cache总共有M块，则对应关系为：<br>$$<br>j &#x3D; i mod M<br>$$</p><h3 id="2-全相联映像"><a href="#2-全相联映像" class="headerlink" title="2. 全相联映像"></a>2. 全相联映像</h3><p>全相联映像（Fully Associative Mapping）是指每个主存块可以被放置到任何一个Cache块位置。</p><h3 id="3-组相联映像"><a href="#3-组相联映像" class="headerlink" title="3. 组相联映像"></a>3. 组相联映像</h3><p>组相联映像（Set Associative Mapping）是指每个主存块可以被放置到Cache中唯一的一个组中的任何一个块位置。</p><p>这里引入了组的概念，Cache被等分为若干个组，每组由若干个块构成。具体地，假设组相联Cache一共有M个块，这M个块被分为G组，则每组有n&#x3D;M&#x2F;G个块，称该映像规则为n路组相联（n-way Set Associative）,直接映像实际上即为1路组相联，全相联即为M路组相联。</p><p>通常也通过直接取模的方法进行组的映像，对于主存的第i块（即块地址为i），设它映像到Cache的第k组，Cache总共有G组，则对应关系为：<br>$$<br>k &#x3D; i mod G<br>$$<br>相联度的高低有利有弊，在实际设计时是一个值得tradeoff的事情。</p><p>相联度越高，Cache空间的利用率越高，块冲突的概率就越低，因此Cache的失效率就越低。但高相联度的查找块过程较复杂，会使Cache的实现复杂度和代价增大，从而降低访问速度。</p><table><thead><tr><th></th><th>利</th><th>弊</th></tr></thead><tbody><tr><td>高相联度</td><td>Cache失效率低</td><td>访问Cache速度慢</td></tr><tr><td>低相联度</td><td>访问Cache速度块</td><td>Cache失效率高</td></tr></tbody></table><h2 id="（2）查找方法"><a href="#（2）查找方法" class="headerlink" title="（2）查找方法"></a>（2）查找方法</h2><p>前面提到，当CPU发送内存地址给Cache后，Cache需要查找该地址所在的主存块当前是否在Cache中，如果在，则命中（Hit），如果不在，则失效（Miss）。主存地址被分为块地址和块内位移，我们需要根据块地址来进行查找。</p><p>无论采取哪种映像规则，多个主存块都可能映像到同一个Cache块的位置，为了区分当前某Cache块位置保存的是哪一个主存块，必须记录唯一标识此主存块的信息，记录这些信息的硬件结构称为<strong>目录表</strong>。目录表共有M项，每个目录项对应于Cache中的一个块，目录项记录了其对应保存的主存块的块地址中除了索引意外的部分，称为标识（tag），每个主存块能唯一地由其标识来确定。此外，每个目录项还有一个有效位，用以指示该项是否有效。</p><p>当要在Cache中查找某一块时，首先根据索引找到块（组）的位置，然后通过查找目录表来确定该块是否在这些位置中的一个。</p><p>查找Cache块的方法基本取决于Cache的映像规则，下面分别进行讨论：</p><h3 id="1-查找直接映像Cache"><a href="#1-查找直接映像Cache" class="headerlink" title="1. 查找直接映像Cache"></a>1. 查找直接映像Cache</h3><p>对于直接映像Cache，其主存块地址被分为tag和块索引，该主存块在Cache中具有唯一位置。因此当CPU访问该主存块时，利用块索引查找到这个位置对应的唯一一个目录项，如果主存地址的tag于该目录项的tag相同，且该目录项有效位为1，则命中；否则失效。</p><img src="/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231031163658464.png" class="" title="直接映像Cache块地址划分"><h3 id="2-查找组相联Cache"><a href="#2-查找组相联Cache" class="headerlink" title="2. 查找组相联Cache"></a>2. 查找组相联Cache</h3><p>对于组相联Cache，其主存地址划分为tag和组索引，该主存块在Cache中具有唯一组别。因此当CPU访问该主存块时，首先通过组索引找到具有该组索引的若干目录项，然后比较这些目录项的tag与主存地址的tag，如果其中有一个目录项的tag与主存地址tag相同，且该目录项有效位为1，则该目录项命中；否则失效。</p><img src="/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231031163555331.png" class="" title="4路组相联"><h3 id="3-查找全相联Cache"><a href="#3-查找全相联Cache" class="headerlink" title="3. 查找全相联Cache"></a>3. 查找全相联Cache</h3><p>对于全相联Cache，其主存块地址即为tag，该主存块可能在Cache的任意位置。当CPU访问该主存块时，该tag需要与Cache中所有块对应的tag比较，若其中有一个块的tag与主存地址的tag相同，且该目录项有效位为1，则该目录项命中；否则失效。</p><img src="/2023/10/31/Cache%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20231031164639343.png" class="" title="全相联"><h2 id="（3）替换算法"><a href="#（3）替换算法" class="headerlink" title="（3）替换算法"></a>（3）替换算法</h2><p>之前说过，无论哪种映像，都会有较多主存块共享一个（或一组）Cache块的位置的情况，所以当一个块要从主存调入Cache时。可能会出现该块所映像的一个（或一组）Cache块位置已经全部被占用的情况。这是需要通过替换算法选择一个块位置来存放这个新调入的块，替换掉这个位置原来的块。</p><ul><li>对于直接映像Cache，每个内存块只映像到一个Cache块位置，因此必定是原来在该位置的块被替换，不存在替换策略。</li><li>对于组相联和全相联Cache，每个内存块映像到一组或全部Cache块，有多个Cache块可能被选择替换掉，则就需要使用合理的替换策略，以<strong>达到尽可能避免替换掉马上就要用的Cache块的目的</strong>。</li></ul><p>主要的替换算法有以下几种：</p><h4 id="1-随机法"><a href="#1-随机法" class="headerlink" title="1. 随机法"></a>1. 随机法</h4><p>顾名思义，随机法在可能被替换的Cache块中随机地选择，<u>以便均匀使用一组中的各个块</u></p><h4 id="2-先进先出法"><a href="#2-先进先出法" class="headerlink" title="2. 先进先出法"></a>2. 先进先出法</h4><p>先进先出法（First In First Out, FIFO）选择最早调入地块作为被替换的块。其很容易实现，但<u>与局部性原理相左</u>，因为最先进入的块很可能马上就要再次使用。</p><h4 id="3-最近最少使用法"><a href="#3-最近最少使用法" class="headerlink" title="3. 最近最少使用法"></a>3. 最近最少使用法</h4><p>最近最少使用法（Least Recently Used, LRU）选择近期最久没有被访问过的块作为被替换的块，它所依据的是<u>局部性原理的推论：如果最近刚使用的块很可能就是马上要再用到的块，那么最久没有被用过的块就是最不可能再被用到的块</u></p><h4 id="4-最不常使用法"><a href="#4-最不常使用法" class="headerlink" title="4. 最不常使用法"></a>4. 最不常使用法</h4><p>最不常使用法（Least Frequently Used, LFU）选择过去一个时间段内访问次数最少的数据块，是<u>最符合局部性原理的算法</u>，但这种算法需要记录一段时间内各块被访问的次数，实现起来代价很大。</p><h2 id="（4）写策略"><a href="#（4）写策略" class="headerlink" title="（4）写策略"></a>（4）写策略</h2><p>相较于读操作，写操作显然更为复杂，因为写会更新数据，改变Cache中数据的状态，而读不会。写策略需要解决以下两个问题：</p><p>如果被写的块不在Cache中（写失效），应该怎样更新？</p><p>如果被写的块在Cache中（写命中），应该只更新Cache，还是同时更新主存中的内容？</p><h3 id="1-对于写失效情况，可以选择是否将响应的块调入Cache"><a href="#1-对于写失效情况，可以选择是否将响应的块调入Cache" class="headerlink" title="1. 对于写失效情况，可以选择是否将响应的块调入Cache"></a>1. 对于写失效情况，可以选择是否将响应的块调入Cache</h3><ul><li><strong>按写分配（Write Allocate）</strong>：先把需要写的块从内存调入Cache，然后再进行写操作。</li><li><strong>不按写分配（No Write Allocate）</strong>：直接写入内存。也称为<strong>绕写（Write Around）</strong>。</li></ul><h3 id="2-对于写命中或写失效时按写分配，有两种策略来维护Cache与主存的一致性"><a href="#2-对于写命中或写失效时按写分配，有两种策略来维护Cache与主存的一致性" class="headerlink" title="2. 对于写命中或写失效时按写分配，有两种策略来维护Cache与主存的一致性"></a>2. 对于写命中或写失效时按写分配，有两种策略来维护Cache与主存的一致性</h3><ul><li><p><strong>写直达（Write Through）</strong>：把数据写入Cache中相应的块，同时也写入主存中相应的块。也称为<strong>写穿透</strong>。</p></li><li><p><strong>写回（Write Back）</strong>：只把数据写入Cache中相应的块，只有后面在该块被替换时，才会写回内存。</p></li><li><p>按写分配通常与写回搭配；不按写分配通常与写直达搭配。</p></li><li><p>在写回法中，为了减少在替换时块的写回，常采用“脏位”标志，即为每个Cache中的块设置一个脏位（dirty）。当该块第一次被改写时，该块的脏位就会置为1，表示这个Cache块曾经被修改过，如果之后再次被改写，脏位仍为1，如果该块需要被替换回内存，则需要将该块写回内存的对应块中。反之，若该块一次都没有被改写，则不需要写回内存。</p></li><li><p>写回与写直达比较</p><table><thead><tr><th></th><th>优点</th></tr></thead><tbody><tr><td>写回</td><td>1. <strong>速度快</strong>。写操作能以Cache的速度进行       2. <strong>使用存储器带宽小</strong>。多次写只需更新一次</td></tr><tr><td>写直达</td><td>1. <strong>实现简单</strong>  2. <strong>简化了数据一致性问题</strong>。内存中的数据总是最新的</td></tr></tbody></table></li><li><p>在进行写直达时，若写操作中CPU必须等待数据写入内存，则称CPU<strong>写停顿（Write Stall）</strong>，造成性能大量损失。为了缓解该问题，可采用<strong>写缓冲器（Write Buffer）</strong>来减少写停顿的时间，写访问数据一旦进入该缓冲器，CPU就可以继续执行，从而实现延迟隐藏。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（四）</title>
      <link href="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本文是官网教程<a href="https://www.gem5.org/documentation/learning_gem5/part2/memoryobject/">gem5: Creating SimObjects in the memory system</a>的学习笔记。</p><p>本节教程是创建一个位于CPU和内存总线之间的阻塞式简单内存对象，主要实现了基本请求的传递。在下一节教程中，会在本节创建的简单内存对象之上增加部分逻辑，使其成为一个非常简单的阻塞单处理器缓存。下图是整个系统的示意图，其中，我们创建的内存对象有两个CPU侧的从端口（slave port）和一个内存总线侧的主端口（master port）。它将实现将请求从CPU传递到内存总线，并将响应从内存总线传递到CPU。</p><span id="more"></span><img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/simple_memobj.png" class="" title="System with a simple memory object which sits between a CPU and the memory bus."><h1 id="一、主从端口"><a href="#一、主从端口" class="headerlink" title="一、主从端口"></a>一、主从端口</h1><p>主端口（master port）和从端口（slave port）是模拟器中创造的概念，用于描述计算机系统中不同组件之间的数据传输关系。在模拟器中用于连接计算机系统中的各种组件。其中，<strong>主端口负责发送请求（send req）、接收响应（recv resp）</strong>；<strong>从端口负责接受请求（recv req）、发送响应（send resp）</strong>，因此，<u>主从端口必须配对使用</u>。</p><p>以本模拟系统为例，memory object有两个CPU侧的从端口，用于接收CPU的请求，并向其返回响应；同时有一个mem bus侧的主接口，用于向mem bus发送请求，并接收其响应。</p><p>这些端口实现三种不同的存储系统模式：</p><ul><li>定时模式（timing mode）。唯一的产生正确模拟结果的模式，最常用。</li><li>原子模式（atomic mode）。</li><li>功能模式（functional mode）。</li></ul><p>其他模式暂时不懂。。。</p><h1 id="二、数据包"><a href="#二、数据包" class="headerlink" title="二、数据包"></a>二、数据包</h1><p>在gem5中，<strong>端口通过发送数据包（packet）实现交互</strong>。数据包由MemReq组成，MemReq是内存请求对象。MemReq保存初始化包的原始请求的信息，例如请求者、地址和请求类型（读、写等）。数据包还有一个MemCmd，它是数据包的当前命令。此命令可以在数据包的整个生命周期中改变（例如，一旦满足内存命令，请求就变成响应）。最常见的MemCmd是ReadReq（读请求）、ReadResp（读响应）、WriteReq（写请求）、WriteResp（写响应）。还有缓存和许多其他命令类型的写回请求（WritebackDirty、WritebackClean）</p><h1 id="三、主从交互"><a href="#三、主从交互" class="headerlink" title="三、主从交互"></a>三、主从交互</h1><p>在定时模式下，主从端口的交互有以下三种情况，需要理清其函数调用链</p><h2 id="（1）正常情况下的主从交互"><a href="#（1）正常情况下的主从交互" class="headerlink" title="（1）正常情况下的主从交互"></a>（1）正常情况下的主从交互</h2><p>正常情况下，主机通过调用sendTimingReq函数发送请求，从机的recvTimingReq函数也随之被调用，如果从机目前可以接受此请求，则返回true，表示从机已经接受此次请求。从机接受请求后随即开始处理此请求。</p><p>从机处理完请求后，通过调用sendTimingResp函数发送此次请求的响应，类似地，主机的recvTimingResp函数随之被调用，如果主机目前可以接受此响应，则返回true，表示主机已经接受了此次响应。交互结束。</p><img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/master_slave_1.png" class="" title="Simple master-slave interaction when both can accept the request and the response."><h2 id="（2）从机忙时的主从交互"><a href="#（2）从机忙时的主从交互" class="headerlink" title="（2）从机忙时的主从交互"></a>（2）从机忙时的主从交互</h2><p>以上情况是主从都顺利接收的理想情况，但当从机接受请求或主机接受响应时，它们可能正忙。</p><p>下面就是从机忙时主从交互的过程。</p><p>从机忙时，从机无法接受主机发送的请求，因此recvTimingReq函数返回false，拒绝接受此次请求。但当从机结束忙态后，会通过调用sendReqRetry函数通知主机，“邀请”主机再次重试发送请求，主机通过recvReqRetry函数接收重试通知后，随机再次发起新的请求。当然，新请求也可能再次因为从机忙而被拒绝。</p><img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzgxMTM1,size_16,color_FFFFFF,t_70.png" class="" title="交互"><h2 id="（3）主机忙时的主从交互"><a href="#（3）主机忙时的主从交互" class="headerlink" title="（3）主机忙时的主从交互"></a>（3）主机忙时的主从交互</h2><p>类似地，在主机忙时，主机无法接收从机发送的响应，因此recvTimingResp函数返回false，拒绝接收此次响应。但当主机结束忙态后，会通过调用sendRespRetry函数通知从机，“邀请”从机再次重试发送响应，从机通过recvRespRetry函数接收重试通知后，随机再次发起新的响应。</p><img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzgxMTM1,size_16,color_FFFFFF,t_70-169863203577313.png" class="" title="交互"><h1 id="四、SimpleMemobj主从端口函数实现"><a href="#四、SimpleMemobj主从端口函数实现" class="headerlink" title="四、SimpleMemobj主从端口函数实现"></a>四、SimpleMemobj主从端口函数实现</h1><p>在本节的简单内存对象（SimpleMemobj）下定义了两个嵌套类CPUSidePort和MemSidePort，它们分别继承自ResponsePort&#x2F;SlavePort和RequstPort&#x2F;MasterPort，即从端口和主端口。</p><ul><li>SimpleMemobj类的成员变量<ul><li><strong>CPU侧从端口</strong>  CPUSidePort instPort; CPUSidePort dataPort;</li><li><strong>内存总线侧主端口</strong>  MemSidePort memPort; </li><li><strong>阻塞标志</strong> 目前是否正在阻塞等待一个响应 bool blocked;</li></ul></li><li>CPUSidePort类的成员变量<ul><li><strong>父对象指针（即SimpleMemobj对象）</strong> SimpleMemobj *owner;</li><li><strong>是否需要重发</strong> CPU试图发送请求给端口，但被拒绝的情况下，需要记录一下存在这种情况，端口在结束忙态后会通知CPU重发。bool needRetry;</li><li><strong>被阻塞的数据包指针</strong> 该端口试图给CPU发送响应，但被CPU拒绝，需要暂存这个数据包。PacketPtr blockedPacket;</li></ul></li><li>MemSidePort类的成员变量<ul><li><strong>父对象指针（即SimpleMemobj对象）</strong> SimpleMemobj *owner;</li><li><strong>被阻塞的数据包指针</strong> 该端口试图给主存发送请求，但被主存拒绝，需要暂存这个数据包。PacketPtr blockedPacket;</li></ul></li></ul><p>各类的成员函数如下图，其中，加粗函数为必须实现的函数，未加粗的函数为在父类中已经实现的函数。</p><img src="/2023/10/30/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/memobj_api.png" class="" title="Interaction between SimpleMemobj and its ports"><p>下面按上图顺序分别对五个函数调用链进行梳理 </p><h2 id="textcolor-RGB-250-106-106-1-获取内存模型的地址范围-CPU-–-Mem-bus"><a href="#textcolor-RGB-250-106-106-1-获取内存模型的地址范围-CPU-–-Mem-bus" class="headerlink" title="$\textcolor[RGB]{250,106,106}{(1)获取内存模型的地址范围         (CPU –&gt; Mem bus)}$"></a>$\textcolor[RGB]{250,106,106}{(1)获取内存模型的地址范围         (CPU –&gt; Mem bus)}$</h2><p>CPU 发送请求，查询内存模型的地址范围，并返回一个 AddrRangeList 类型的值。这种查询请求<strong>不存在阻塞情况</strong>。</p><h3 id="1-SimpleMemobj-CPUSidePort-getAddrRanges"><a href="#1-SimpleMemobj-CPUSidePort-getAddrRanges" class="headerlink" title="1. SimpleMemobj::CPUSidePort::getAddrRanges"></a>1. SimpleMemobj::CPUSidePort::getAddrRanges</h3><p>CPUSidePort直接将请求传递给其父对象SimpleMemobj</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AddrRangeList</span><br><span class="line">SimpleMemobj::CPUSidePort::getAddrRanges() const</span><br><span class="line">&#123;</span><br><span class="line">    return owner-&gt;getAddrRanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SimpleMemobj-getAddrRanges"><a href="#2-SimpleMemobj-getAddrRanges" class="headerlink" title="2. SimpleMemobj::getAddrRanges"></a>2. SimpleMemobj::getAddrRanges</h3><p>SimpleMemobj同样直接将请求传递给其子对象MemSidePort </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AddrRangeList</span><br><span class="line">SimpleMemobj::getAddrRanges() const</span><br><span class="line">&#123;</span><br><span class="line">    DPRINTF(SimpleMemobj, &quot;Sending new ranges\n&quot;);</span><br><span class="line">    // Just use the same ranges as whatever is on the memory side.</span><br><span class="line">    return memPort.getAddrRanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MemSidePort.getAddrRanges()函数已经在MemSidePort的父类RequestPort中被实现了，返回地址范围，可直接使用。</p><h2 id="textcolor-RGB-100-106-255-2-通知内存模型的地址范围发生更改-Mem-bus-–-CPU"><a href="#textcolor-RGB-100-106-255-2-通知内存模型的地址范围发生更改-Mem-bus-–-CPU" class="headerlink" title="$\textcolor[RGB]{100,106,255}{(2)通知内存模型的地址范围发生更改(Mem bus –&gt; CPU)} $"></a>$\textcolor[RGB]{100,106,255}{(2)通知内存模型的地址范围发生更改(Mem bus –&gt; CPU)} $</h2><p>Mem bus发送请求，向CPU通知内存模型的地址范围发生更改，同样此通知也<strong>不会阻塞</strong>。</p><h3 id="1-SimpleMemobj-MemSidePort-recvRangeChange"><a href="#1-SimpleMemobj-MemSidePort-recvRangeChange" class="headerlink" title="1. SimpleMemobj::MemSidePort::recvRangeChange"></a>1. SimpleMemobj::MemSidePort::recvRangeChange</h3><p>MemSidePort 直接将请求传递给其父对象 SimpleMemobj</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::MemSidePort::recvRangeChange()</span><br><span class="line">&#123;</span><br><span class="line">    owner-&gt;sendRangeChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SimpleMemobj-sendRangeChange"><a href="#2-SimpleMemobj-sendRangeChange" class="headerlink" title="2. SimpleMemobj::sendRangeChange"></a>2. SimpleMemobj::sendRangeChange</h3><p>SimpleMemobj同样直接将请求传递给其子对象CPUSidePort</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::sendRangeChange()</span><br><span class="line">&#123;</span><br><span class="line">    instPort.sendRangeChange();</span><br><span class="line">    dataPort.sendRangeChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CPUSidePort.sendRangeChange函数同样已经在CPUSidePort的父类ResponsePort中被实现了，可直接使用。</p><h2 id="textcolor-RGB-250-250-100-3-功能请求与响应-CPU-–-Mem-bus"><a href="#textcolor-RGB-250-250-100-3-功能请求与响应-CPU-–-Mem-bus" class="headerlink" title="$\textcolor[RGB]{250,250,100}{(3)功能请求与响应(CPU –&gt; Mem bus)} $"></a>$\textcolor[RGB]{250,250,100}{(3)功能请求与响应(CPU –&gt; Mem bus)} $</h2><p>功能请求是指不改变系统状态的请求，通常用于读取数据或检查系统状态。同样这种请求也<strong>不会发生阻塞</strong>。</p><p>这个过程的调用链与获取地址范围大致相同，只不过需要传递数据包指针。</p><h3 id="1-SimpleMemobj-CPUSidePort-recvFunctional"><a href="#1-SimpleMemobj-CPUSidePort-recvFunctional" class="headerlink" title="1. SimpleMemobj::CPUSidePort::recvFunctional"></a>1. SimpleMemobj::CPUSidePort::recvFunctional</h3><p>CPUSidePort直接将请求传递给其父对象 SimpleMemobj</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::CPUSidePort::recvFunctional(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Just forward to the memobj.</span><br><span class="line">    return owner-&gt;handleFunctional(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SimpleMemobj-handleFunctional"><a href="#2-SimpleMemobj-handleFunctional" class="headerlink" title="2. SimpleMemobj::handleFunctional"></a>2. SimpleMemobj::handleFunctional</h3><p>SimpleMemobj同样直接将请求传递给其子对象MemSidePort </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::handleFunctional(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Just pass this on to the memory side to handle for now.</span><br><span class="line">    memPort.sendFunctional(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MemSidePort.sendFunctional()函数已经在MemSidePort的父类RequestPort中被实现了，可直接使用。</p><h2 id="textcolor-RGB-250-100-250-4-发送定时请求-CPU-–-Mem-bus"><a href="#textcolor-RGB-250-100-250-4-发送定时请求-CPU-–-Mem-bus" class="headerlink" title="$\textcolor[RGB]{250,100,250}{(4)发送定时请求(CPU –&gt; Mem bus)} $"></a>$\textcolor[RGB]{250,100,250}{(4)发送定时请求(CPU –&gt; Mem bus)} $</h2><p>定时请求是指需要等待一段时间后才能完成的请求，通常用于写入数据或执行耗时操作。由于CPU发送请求时，mem bus可能尚未处理完上一次请求，处于忙态，无法接收此次请求，因此这个过程<strong>可能会发生阻塞</strong>。</p><h3 id="1-SimpleMemobj-CPUSidePort-recvTimingReq"><a href="#1-SimpleMemobj-CPUSidePort-recvTimingReq" class="headerlink" title="1. SimpleMemobj::CPUSidePort::recvTimingReq"></a>1. SimpleMemobj::CPUSidePort::recvTimingReq</h3><p>CPUSidePort尝试通过父对象 SimpleMemobj的handleRequest函数发送定时请求</p><p>如果成功，返回true；</p><p>如果失败，将needRetry置为true并返回false，该请求被阻止，CPU在将来某个时候需要发送一个重试（SimpleMemobj::CPUSidePort::trySendRetry()函数）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">SimpleMemobj::CPUSidePort::recvTimingReq(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Just forward to the memobj.</span><br><span class="line">    if (!owner-&gt;handleRequest(pkt)) &#123;</span><br><span class="line">        needRetry = true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SimpleMemobj-handleRequest"><a href="#2-SimpleMemobj-handleRequest" class="headerlink" title="2. SimpleMemobj::handleRequest"></a>2. SimpleMemobj::handleRequest</h3><p>来到SimpleMemobj的handleRequest函数。首先检查目前没有在等待响应（被阻塞）</p><p>如果没有被阻塞，则将blocked置为true，即进入阻塞状态，并通过子对象MemSidePort的sendPacket函数发送数据包，并返回true；</p><p>反之如果被阻塞，直接返回false，拒绝此请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">SimpleMemobj::handleRequest(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    if (blocked) &#123;</span><br><span class="line">        // There is currently an outstanding request. Stall.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    DPRINTF(SimpleMemobj, &quot;Got request for addr %#x\n&quot;, pkt-&gt;getAddr());</span><br><span class="line">    </span><br><span class="line">    // This memobj is now blocked waiting for the response to this packet.</span><br><span class="line">    blocked = true;</span><br><span class="line">    </span><br><span class="line">    // Simply forward to the memory port</span><br><span class="line">    memPort.sendPacket(pkt);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-SimpleMemobj-MemSidePort-sendPacket"><a href="#3-SimpleMemobj-MemSidePort-sendPacket" class="headerlink" title="3. SimpleMemobj::MemSidePort::sendPacket"></a>3. SimpleMemobj::MemSidePort::sendPacket</h3><p>MemSidePort的sendPacket会调用sendTimingReq函数（在其父类中定义，可直接使用）发送请求数据包给内存总线。如果发送不成功，则将要发送的数据包指针保存下来，准备重发该数据包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::MemSidePort::sendPacket(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Note: This flow control is very simple since the memobj is blocking.</span><br><span class="line">    panic_if(blockedPacket != nullptr, &quot;Should never try to send if blocked!&quot;);</span><br><span class="line">    </span><br><span class="line">    // If we can&#x27;t send the packet across the port, store it for later.</span><br><span class="line">    if (!sendTimingReq(pkt)) &#123;</span><br><span class="line">        blockedPacket = pkt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-SimpleMemobj-MemSidePort-recvReqRetry"><a href="#4-SimpleMemobj-MemSidePort-recvReqRetry" class="headerlink" title="4. SimpleMemobj::MemSidePort::recvReqRetry"></a>4. SimpleMemobj::MemSidePort::recvReqRetry</h3><p>内存总线结束忙态后，会调用MemSidePort类的recvReqRetry邀请MemSidePort重发之前被阻塞的请求数据包，即重发blockedPacket数据包。注意：在重发前，应该一定会有被阻塞的数据包，否则报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::MemSidePort::recvReqRetry()</span><br><span class="line">&#123;</span><br><span class="line">    // We should have a blocked packet if this function is called.</span><br><span class="line">    assert(blockedPacket != nullptr);</span><br><span class="line"></span><br><span class="line">    // Grab the blocked packet.</span><br><span class="line">    PacketPtr pkt = blockedPacket;</span><br><span class="line">    blockedPacket = nullptr;</span><br><span class="line"></span><br><span class="line">    // Try to resend it. It&#x27;s possible that it fails again.</span><br><span class="line">    sendPacket(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="textcolor-RGB-100-250-250-5-接收定时请求的响应-Mem-bus-–-CPU"><a href="#textcolor-RGB-100-250-250-5-接收定时请求的响应-Mem-bus-–-CPU" class="headerlink" title="$\textcolor[RGB]{100,250,250}{(5)接收定时请求的响应(Mem bus –&gt; CPU)} $"></a>$\textcolor[RGB]{100,250,250}{(5)接收定时请求的响应(Mem bus –&gt; CPU)} $</h2><p>内存总线处理完定时请求后，会向CPU发送该定时请求的响应。类似地，CPU也可能会因为处于忙态而拒绝接收响应，也<strong>可能会存在阻塞</strong></p><h3 id="1-SimpleMemobj-MemSidePort-recvTimingResp"><a href="#1-SimpleMemobj-MemSidePort-recvTimingResp" class="headerlink" title="1. SimpleMemobj::MemSidePort::recvTimingResp"></a>1. SimpleMemobj::MemSidePort::recvTimingResp</h3><p>MemSidePort直接将请求传递给其父对象SimpleMemobj</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">SimpleMemobj::MemSidePort::recvTimingResp(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Just forward to the memobj.</span><br><span class="line">    return owner-&gt;handleResponse(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SimpleMemobj-handleResponse"><a href="#2-SimpleMemobj-handleResponse" class="headerlink" title="2. SimpleMemobj::handleResponse"></a>2. SimpleMemobj::handleResponse</h3><p>SimpleMemobj处理响应时，首先因为收到了响应所以消除阻塞状态，然后根据数据包的属性确定是发送给指令端口还是数据端口。</p><p>结束了阻塞状态以后，会尝试通过trySendRetry()函数让CPU重发未能成功发送的请求（如果有的话）。</p><p>注意：在接收响应时，SimpleMemobj应该一定处于阻塞状态，否则报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">SimpleMemobj::handleResponse(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    assert(blocked);</span><br><span class="line">    DPRINTF(SimpleMemobj, &quot;Got response for addr %#x\n&quot;, pkt-&gt;getAddr());</span><br><span class="line"></span><br><span class="line">    // The packet is now done. We&#x27;re about to put it in the port, no need for</span><br><span class="line">    // this object to continue to stall.</span><br><span class="line">    // We need to free the resource before sending the packet in case the CPU</span><br><span class="line">    // tries to send another request immediately (e.g., in the same callchain).</span><br><span class="line">    blocked = false;</span><br><span class="line"></span><br><span class="line">    // Simply forward to the memory port</span><br><span class="line">    if (pkt-&gt;req-&gt;isInstFetch()) &#123;</span><br><span class="line">        instPort.sendPacket(pkt);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dataPort.sendPacket(pkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // For each of the cpu ports, if it needs to send a retry, it should do it</span><br><span class="line">    // now since this memory object may be unblocked now.</span><br><span class="line">    instPort.trySendRetry();</span><br><span class="line">    dataPort.trySendRetry();</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-SimpleMemobj-CPUSidePort-sendPacket"><a href="#3-SimpleMemobj-CPUSidePort-sendPacket" class="headerlink" title="3. SimpleMemobj::CPUSidePort::sendPacket"></a>3. SimpleMemobj::CPUSidePort::sendPacket</h3><p>CPUSidePort的sendPacket会调用sendTimingReq函数（在其父类中定义，可直接使用）发送响应数据包给CPU。如果发送不成功，则将要发送的数据包指针保存下来，准备重发该数据包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::CPUSidePort::sendPacket(PacketPtr pkt)</span><br><span class="line">&#123;</span><br><span class="line">    // Note: This flow control is very simple since the memobj is blocking.</span><br><span class="line"></span><br><span class="line">    panic_if(blockedPacket != nullptr, &quot;Should never try to send if blocked!&quot;);</span><br><span class="line"></span><br><span class="line">    // If we can&#x27;t send the packet across the port, store it for later.</span><br><span class="line">    if (!sendTimingResp(pkt)) &#123;</span><br><span class="line">        blockedPacket = pkt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-SimpleMemobj-CPUSidePort-trySendRetry"><a href="#4-SimpleMemobj-CPUSidePort-trySendRetry" class="headerlink" title="4. SimpleMemobj::CPUSidePort::trySendRetry"></a>4. SimpleMemobj::CPUSidePort::trySendRetry</h3><p>尝试让CPU重发未能发送的请求</p><p>如果needRetry为True，则说明之前CPU有未能发送的请求；如果blockedPacket指针为空，说明SimpleMemobj未处于阻塞状态，则可以通过sendRetryReq函数（父类中已经实现，可直接使用）让CPU重发请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::CPUSidePort::trySendRetry()</span><br><span class="line">&#123;</span><br><span class="line">    if (needRetry &amp;&amp; blockedPacket == nullptr) &#123;</span><br><span class="line">        // Only send a retry if the port is now completely free</span><br><span class="line">        needRetry = false;</span><br><span class="line">        DPRINTF(SimpleMemobj, &quot;Sending retry req for %d\n&quot;, id);</span><br><span class="line">        sendRetryReq();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-SimpleMemobj-CPUSidePort-recvRespRetry"><a href="#5-SimpleMemobj-CPUSidePort-recvRespRetry" class="headerlink" title="5. SimpleMemobj::CPUSidePort::recvRespRetry"></a>5. SimpleMemobj::CPUSidePort::recvRespRetry</h3><p>CPU忙态结束以后，会通过调用CPUSidePort类的recvRespRetry函数邀请CPUSidePort重新发送之前被阻塞的响应数据包，即重发blockedPacket数据包。注意：在重发前，应该一定会有被阻塞的数据包，否则报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">SimpleMemobj::CPUSidePort::recvRespRetry()</span><br><span class="line">&#123;</span><br><span class="line">    // We should have a blocked packet if this function is called.</span><br><span class="line">    assert(blockedPacket != nullptr);</span><br><span class="line"></span><br><span class="line">    // Grab the blocked packet.</span><br><span class="line">    PacketPtr pkt = blockedPacket;</span><br><span class="line">    blockedPacket = nullptr;</span><br><span class="line"></span><br><span class="line">    // Try to resend it. It&#x27;s possible that it fails again.</span><br><span class="line">    sendPacket(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、配置脚本"><a href="#五、配置脚本" class="headerlink" title="五、配置脚本"></a>五、配置脚本</h1><p>实例化SimpleMemobj对象，并运行hello world负载的配置脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import m5</span><br><span class="line">from m5.objects import *</span><br><span class="line"></span><br><span class="line">system = System()</span><br><span class="line">system.clk_domain = SrcClockDomain()</span><br><span class="line">system.clk_domain.clock = &#x27;1GHz&#x27;</span><br><span class="line">system.clk_domain.voltage_domain = VoltageDomain()</span><br><span class="line">system.mem_mode = &#x27;timing&#x27;</span><br><span class="line">system.mem_ranges = [AddrRange(&#x27;512MB&#x27;)]</span><br><span class="line"></span><br><span class="line">system.cpu = TimingSimpleCPU()</span><br><span class="line"></span><br><span class="line">system.memobj = SimpleMemobj()</span><br><span class="line"></span><br><span class="line">system.cpu.icache_port = system.memobj.inst_port</span><br><span class="line">system.cpu.dcache_port = system.memobj.data_port</span><br><span class="line"></span><br><span class="line">system.membus = SystemXBar()</span><br><span class="line"></span><br><span class="line">system.memobj.mem_side = system.membus.slave</span><br><span class="line"></span><br><span class="line">system.cpu.createInterruptController()</span><br><span class="line">system.cpu.interrupts[0].pio = system.membus.master</span><br><span class="line">system.cpu.interrupts[0].int_master = system.membus.slave</span><br><span class="line">system.cpu.interrupts[0].int_slave = system.membus.master</span><br><span class="line"></span><br><span class="line">system.mem_ctrl = DDR3_1600_8x8()</span><br><span class="line">system.mem_ctrl.range = system.mem_ranges[0]</span><br><span class="line">system.mem_ctrl.port = system.membus.master</span><br><span class="line"></span><br><span class="line">system.system_port = system.membus.slave</span><br><span class="line"></span><br><span class="line">process = Process()</span><br><span class="line">process.cmd = [&#x27;tests/test-progs/hello/bin/x86/linux/hello&#x27;]</span><br><span class="line">system.cpu.workload = process</span><br><span class="line">system.cpu.createThreads()</span><br><span class="line"></span><br><span class="line">root = Root(full_system = False, system = system)</span><br><span class="line">m5.instantiate()</span><br><span class="line"></span><br><span class="line">print &quot;Beginning simulation!&quot;</span><br><span class="line">exit_event = m5.simulate()</span><br><span class="line">print &#x27;Exiting @ tick %i because %s&#x27; % (m5.curTick(), exit_event.getCause())</span><br></pre></td></tr></table></figure><ol><li>在命令行执行以下命令，可以运行模拟系统</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/X86/gem5.opt configs/learning_gem5/part2/simple_memobj.py</span><br></pre></td></tr></table></figure><p>输出内容出现Hello World则模拟成功。</p><ol start="2"><li>在命令行执行以下命令，可以在debug模式下运行模拟系统，由于输出较多，只输出前五十行。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/X86/gem5.opt --debug-flags=SimpleMemobj configs/learning_gem5/part2/simple_memobj.py | head -n 50</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Beginning simulation!</span><br><span class="line">      0: system.memobj: Got request for addr 0x190</span><br><span class="line">  77000: system.memobj: Got response for addr 0x190</span><br><span class="line">  77000: system.memobj: Got request for addr 0x190</span><br><span class="line"> 126000: system.memobj: Got response for addr 0x190</span><br><span class="line"> 126000: system.memobj: Got request for addr 0x190</span><br><span class="line"> 175000: system.memobj: Got response for addr 0x190</span><br><span class="line"> 175000: system.memobj: Got request for addr 0x94db0</span><br><span class="line"> 238000: system.memobj: Got response for addr 0x94db0</span><br><span class="line"> 238000: system.memobj: Got request for addr 0x190</span><br><span class="line"> 287000: system.memobj: Got response for addr 0x190</span><br><span class="line"> 287000: system.memobj: Got request for addr 0x198</span><br><span class="line"> 336000: system.memobj: Got response for addr 0x198</span><br><span class="line"> 336000: system.memobj: Got request for addr 0x198</span><br><span class="line"> 385000: system.memobj: Got response for addr 0x198</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Gem5模拟器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gem5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理——图片拼接</title>
      <link href="/2023/10/25/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E6%8B%BC%E6%8E%A5/"/>
      <url>/2023/10/25/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E6%8B%BC%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="问题导入"><a href="#问题导入" class="headerlink" title="问题导入"></a>问题导入</h1><p>图片全景拼接</p><p>观察者在同一个点，不是简单的平移旋转，需要运用投射关系（近大远小）</p><h1 id="图像全局变换"><a href="#图像全局变换" class="headerlink" title="图像全局变换"></a>图像全局变换</h1><p>研究对象为二维图像</p><h2 id="1-线性变换"><a href="#1-线性变换" class="headerlink" title="1. 线性变换"></a>1. 线性变换</h2><p>缩放 Scale</p><p>旋转 Rotation</p><p>剪切 Shear</p><p>镜像 mirror</p><p>S &#x3D; 2 * 2矩阵<br>$$<br>S &#x3D; \begin{bmatrix}<br> a &amp; b\<br> c &amp; d<br>\end{bmatrix}<br>$$</p><h2 id="2-仿射变换"><a href="#2-仿射变换" class="headerlink" title="2. 仿射变换"></a>2. 仿射变换</h2><p>仿射变换 &#x3D; 线性变换+平移</p><p>S &#x3D; 3 * 3矩阵<br>$$<br> S &#x3D; \begin{bmatrix} a &amp; b &amp; c\ d &amp; e &amp; f\ 0 &amp; 0 &amp; 1\end{bmatrix}<br>$$<br>6个未知数</p><h2 id="3-投影变换"><a href="#3-投影变换" class="headerlink" title="3. 投影变换"></a>3. 投影变换</h2><p>S &#x3D; 3 * 3矩阵<br>$$<br>S &#x3D; \begin{bmatrix}<br> a &amp; b &amp; c\<br> d &amp; e &amp; f\<br> g &amp; h &amp; 1<br>\end{bmatrix}<br>$$<br>8个未知数，即8个自由度，表示能力最强</p>]]></content>
      
      
      <categories>
          
          <category> 数字图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片拼接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（三）</title>
      <link href="/2023/10/24/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/10/24/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Gem5学习——创建一个简单的SimObject"><a href="#Gem5学习——创建一个简单的SimObject" class="headerlink" title="Gem5学习——创建一个简单的SimObject"></a>Gem5学习——创建一个简单的SimObject</h1><h2 id="一、名词解释"><a href="#一、名词解释" class="headerlink" title="一、名词解释"></a>一、名词解释</h2><ul><li><p>$\textcolor[RGB]{200,50,50}{SimObject}$</p><p>在gem5中，SimObject是一个基础类，用于<strong>创建和管理模拟对象</strong>。</p></li><li><p>$\textcolor[RGB]{200,50,50}{SimObjects}$</p><p>SimObjects是gem5中用于管理模拟对象的组件。通常，gem5中的模拟对象都会继承自SimpleObject类，并且通过SimObjects组件来进行管理。</p></li><li><p>$\textcolor[RGB]{200,50,50}{SimpleObject}$</p><p>SimpleObject是SimObject类的一个派生类，它在SimObject类的基础上增加了一些额外的功能，通常，在gem5中创建新的模拟对象时，都会从SimpleObject类进行派生，以便获得这些基本的功能。</p></li></ul><h2 id="二、创建一个简单的SimObject"><a href="#二、创建一个简单的SimObject" class="headerlink" title="二、创建一个简单的SimObject"></a>二、创建一个简单的SimObject</h2><p>即官网教程创建helloobject<a href="https://www.gem5.org/documentation/learning_gem5/part2/helloobject/">gem5: Creating a very simple SimObject</a></p><p><strong>$\textcolor[RGB]{100,200,50}{Gem5使用了Python和C++两种编程语言混合编程}$</strong></p><p>gem5一方面通过python语言配置模拟器运行的参数和控制模拟过程的脚本，优势在于便于快速阅读和编写配置脚本；另一方面通过C++实现gem5中的各种模型（SimObjects），优势在于C++是一种高性能的编程语言，能够保证其模拟性能。混合编程充分发挥了两种语言的优势。</p>]]></content>
      
      
      <categories>
          
          <category> Gem5模拟器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gem5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（二）</title>
      <link href="/2023/10/24/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/10/24/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>d69</p>]]></content>
      
      
      <categories>
          
          <category> Gem5模拟器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gem5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1023-1028</title>
      <link href="/2023/10/23/1023-1028/"/>
      <url>/2023/10/23/1023-1028/</url>
      
        <content type="html"><![CDATA[<p><strong>10月23日</strong></p><p>根据博客，继续学习gem5的构建模拟环境、创建simObject</p>]]></content>
      
      
      <categories>
          
          <category> 毕设学习记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SCons</title>
      <link href="/2023/10/23/SCons/"/>
      <url>/2023/10/23/SCons/</url>
      
        <content type="html"><![CDATA[<p>scons是一个Python写的自动化构建工具</p><p><a href="https://www.jianshu.com/u/ddb7903b52e4">VictorWANG1992 - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/danshiming/article/details/122771064?ops_request_misc=%7B%22request_id%22:%22169805899416777224422665%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=169805899416777224422665&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122771064-null-null.142%5Ev96%5Epc_search_result_base2&utm_term=SCons&spm=1018.2226.3001.4187">SCons简单入门（一）-CSDN博客</a></p><p><a href="https://www.scons.org/doc/production/HTML/scons-user/index.html">SCons 4.5.2官方文档</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Scons </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：指令系统</title>
      <link href="/2023/10/22/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/10/22/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-指令系统结构的分类"><a href="#1-指令系统结构的分类" class="headerlink" title="1 指令系统结构的分类"></a>1 指令系统结构的分类</h1><p>CPU中用来存放操作数的存储单元主要有三种：<strong>堆栈</strong>、<strong>累加器</strong>、<strong>通用寄存器组</strong>。据此，指令系统（Instruction Set Architecture）可分为三种：</p><ul><li><strong>$\color[RGB]{40,120,181}{堆栈型结构}$：</strong>堆栈栈顶和次栈顶中的数据，运算后写入栈顶。两个操作数都是隐式的。<strong>优点：</strong>指令字比较短，程序占用的空间小；<strong>缺点：</strong>不能随机地访问堆栈，难以生成有效的代码，而且对栈顶的访问是个瓶颈。</li><li><strong>$\color[RGB]{40,120,181}{累加器型结构}$：</strong>一个操作数是隐式的，即累加器；另一个是显示给出的。<strong>优点：</strong>指令字比较短，程序占用的空间小；<strong>缺点：</strong>只有一个中间结果暂存在累加器中，需要频繁访问存储器。</li></ul><p>早期计算机大多采用堆栈型结构或累加器型结构</p><ul><li><strong>$\color[RGB]{40,120,181}{通用寄存器型结构}$：</strong>所有操作数都是显示给出的。<strong>优点：</strong>1.寄存器的访问比存储器快得多 2. 编译器能够更加容易、有效地分配寄存器 。根据操作数显式给出的来源不同，又可以分为两类：<ul><li>$\color[RGB]{248,172,140}{寄存器-存储器型结构(RM结构)}:$一个操作数来自寄存器，另一个来自存储器。</li><li>$\color[RGB]{248,172,140}{寄存器-寄存器型结构(RR结构)}:$两个操作数都来自寄存器。</li></ul></li></ul><p>**显式给出:**用指令字中的操作数字段给出</p><p>**隐式给出:**用事先约定好的单元</p><span id="more"></span><h1 id="2-寻址方式"><a href="#2-寻址方式" class="headerlink" title="2. 寻址方式"></a>2. 寻址方式</h1><p>寻址方式（Addressing Mode）是指指令系统中产生所要访问的数据地址的方法。寻址方式可以指明指令中的操作数是一个<strong>立即数</strong>、一个<strong>寄存器操作数</strong>或者是一个<strong>存储器操作数</strong></p><h2 id="2-1-寻址方式举例"><a href="#2-1-寻址方式举例" class="headerlink" title="2.1 寻址方式举例"></a>2.1 寻址方式举例</h2><ul><li>寄存器寻址</li><li>立即数寻址</li><li>偏移寻址</li></ul><p>等等</p><h2 id="2-2-字节对齐"><a href="#2-2-字节对齐" class="headerlink" title="2.2 字节对齐"></a>2.2 字节对齐</h2><p>计算机中信息的单位可分为字节(8bit)、半字(16bit)、单字(32bit)、双字(64bit)。计算机中采用按字节编址，各类信息都是用改信息的首字节地址来寻址的。</p><h3 id="信息存储的整数边界"><a href="#信息存储的整数边界" class="headerlink" title="信息存储的整数边界"></a>信息存储的整数边界</h3><p>此外还需要对它们的存储方式进行限制，如果允许它们任意存储，就可能出现一个信息跨存储字边界而存储与两个存储单元的情况，而在这种情况下，读取该信息就需要花费两个存储周期，为了避免出现这个问题，就要求<strong>宽度不超过主存宽度的信息必须存放在一个存储字内，信息在主存中存放的起始地址必须是该信息宽度（字节数）的整数倍</strong>，从而避免了跨边界，保证了访问速度。</p><p>对于一个32位机器（主存宽度为32位），要求：</p><h5 id="字节信息的起始地址为：x…xxxx"><a href="#字节信息的起始地址为：x…xxxx" class="headerlink" title="字节信息的起始地址为：x…xxxx"></a>字节信息的起始地址为：x…xxxx</h5><h5 id="半字信息的起始地址为：x…xxx0"><a href="#半字信息的起始地址为：x…xxx0" class="headerlink" title="半字信息的起始地址为：x…xxx0"></a>半字信息的起始地址为：x…xxx0</h5><h5 id="单字信息的起始地址为：x…xx00"><a href="#单字信息的起始地址为：x…xx00" class="headerlink" title="单字信息的起始地址为：x…xx00"></a>单字信息的起始地址为：x…xx00</h5><h5 id="双字信息的起始地址为：x…x000"><a href="#双字信息的起始地址为：x…x000" class="headerlink" title="双字信息的起始地址为：x…x000"></a>双字信息的起始地址为：x…x000</h5>]]></content>
      
      
      <categories>
          
          <category> 《计算机体系结构》学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
            <tag> 指令系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1019-1021</title>
      <link href="/2023/10/19/1019-1021/"/>
      <url>/2023/10/19/1019-1021/</url>
      
        <content type="html"><![CDATA[<h1 id="10-18"><a href="#10-18" class="headerlink" title="10.18"></a>10.18</h1><p>在Ubuntu20.04系统上成功配置gem5模拟器，并根据官网的教程编译了第一个单核x86架构系统，并运行hello world负载。</p><h1 id="10-19"><a href="#10-19" class="headerlink" title="10.19"></a>10.19</h1><p>进一步学习官网教程，阅读博客</p><p><a href="https://csdiy.wiki/">CS自学指南 (csdiy.wiki)</a></p>]]></content>
      
      
      <categories>
          
          <category> 毕设学习记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo主题和插件</title>
      <link href="/2023/10/18/hexo%E4%B8%BB%E9%A2%98%E5%92%8C%E6%8F%92%E4%BB%B6/"/>
      <url>/2023/10/18/hexo%E4%B8%BB%E9%A2%98%E5%92%8C%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Hexo主题"><a href="#1-Hexo主题" class="headerlink" title="1. Hexo主题"></a>1. Hexo主题</h1><p>hexo官方提供了很多的主题模板，可以在<a href="https://hexo.io/themes/index.html">hexo主题官网</a>中看到，<a href="https://hexo.io/zh-cn/docs/themes.html">官方教程</a>中也有配置主题操作</p><span id="more"></span><h2 id="Next主题"><a href="#Next主题" class="headerlink" title="Next主题"></a><strong>Next主题</strong></h2><p>在众多主题中，Next是最受欢迎的主题之一，它提供了许多的界面模板，并且支持安装许多的插件。</p><h2 id="Next主题下载"><a href="#Next主题下载" class="headerlink" title="Next主题下载"></a><strong>Next主题下载</strong></h2><ol><li><p>$\color[RGB]{200, 100, 10}{下载}$。在git bash窗口中通过git clone即可下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>下载成功后，在<strong>blog&#x2F;themes</strong>文件夹下即可找到下载的next主题文件夹，其中包含了next主题的配置信息</p></li><li><p>$\color[RGB]{200, 100, 10}{修改Hexo主题}$。返回<strong>bolg根目录</strong>，打开**_config.yml 文件**，并将其中的theme项的值改为next</p></li></ol><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src=hexo主题和插件/image-20231019001323077.png>    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #FFF;    padding: 2px;">hexo主题修改为next</div></center><p>经过以上两步，hexo的主题就成功更换为next啦！然后就通过hexo g重新生成博客，再通过hexo s 或 hexo d发布新的博客，看看新主题的样子。</p><hr><h1 id="2-添加分类、标签、关于"><a href="#2-添加分类、标签、关于" class="headerlink" title="2. 添加分类、标签、关于"></a>2. 添加分类、标签、关于</h1><p><a href="https://blog.csdn.net/weixin_48927364/article/details/123295436">【Hexo】nexT主题使用攻略基础——添加分类、标签及关于_hexo 分类-CSDN博客</a></p><h1 id="3-Hexo常用插件"><a href="#3-Hexo常用插件" class="headerlink" title="3. Hexo常用插件"></a>3. Hexo常用插件</h1><h2 id="（1）插入数学公式"><a href="#（1）插入数学公式" class="headerlink" title="（1）插入数学公式"></a>（1）插入数学公式</h2><p>在用markdown写技术文档时，免不了会碰到数学公式。Next这种大主题也集成了渲染数学公式的功能</p><p>目前Next提供两种数学公式渲染引擎，分别是Mathjax和Katex。</p><p>可以在Next主题的配置文件_config.yml中看到这两个项</p><img src="/2023/10/18/hexo%E4%B8%BB%E9%A2%98%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231019132036641.png" class="" title="Next主题的配置文件_config.yml"><p>默认情况下两个引擎的enable使能选项均为false，只需要改为true就可以渲染数学公式了</p><p>其中every_page项置为true的时候，引擎会默认对每篇博客中的数学公式进行渲染，但对于不含数学公式的博客，加载速度会额外变慢；而当置为false是，只会对在开头处声明使用mathjax引擎的博客进行渲染。</p><img src="/2023/10/18/hexo%E4%B8%BB%E9%A2%98%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231019145600478.png" class="" title="博客开头声明使用mathjax引擎"><p><strong>效果展示：</strong></p><ul><li><p>行内公式：</p><p>$f\left( x \right) &#x3D; \sum\limits_{i &#x3D; 1}^n {X_i^2} $</p><p>$MD\left(n_{i, j}, n_{x, y}\right)&#x3D;|i-x|+|j-y|$</p></li><li><p>行间公式：</p><p>$$ f\left( x \right) &#x3D; \sum\limits_{i &#x3D; 1}^n {X_i^2} $$</p><p>$$ MD\left(n_{i, j}, n_{x, y}\right)&#x3D;|i-x|+|j-y|$$</p></li></ul><p>（2）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu虚拟机</title>
      <link href="/2023/10/17/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2023/10/17/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机iso镜像下载"><a href="#虚拟机iso镜像下载" class="headerlink" title="虚拟机iso镜像下载"></a>虚拟机iso镜像下载</h1><p><a href="https://developer.aliyun.com/mirror/?spm=a2c6h.265751.1364563.38.728e2621iHKW48">阿里巴巴开源镜像站-OPSX镜像站-阿里云开发者社区 (aliyun.com)</a></p><p>进入阿里巴巴开源镜像站，点击OS，输入想要下载的发行版镜像及版本号，即可下载。</p><span id="more"></span><h1 id="Ubuntu20-04更换清华源"><a href="#Ubuntu20-04更换清华源" class="headerlink" title="Ubuntu20.04更换清华源"></a>Ubuntu20.04更换清华源</h1><p>Ubuntu安装完之后进行更换为国内源可以让下载更新的的速度快一点。</p><p>以下是具体操作的博客</p><p><a href="https://www.cnblogs.com/Lxk0825/p/9520002.html">ubuntu 执行apt-get update报错Failed to fetch - Lxk- - 博客园 (cnblogs.com)</a></p><p>使用清华源，将以下代码输入&#x2F;etc&#x2F;apt&#x2F;sources.list文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h1 id="解决Linux-下使用-ifconfig-查看不到-ip-地址"><a href="#解决Linux-下使用-ifconfig-查看不到-ip-地址" class="headerlink" title="解决Linux 下使用 ifconfig 查看不到 ip 地址"></a>解决Linux 下使用 ifconfig 查看不到 ip 地址</h1><p>ubuntu下ifconfig查找不到ens33</p><img src="/2023/10/17/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20231106094703783.png" class="" title="image-20231106094703783"><p>解决方案：<strong>在终端下使用 dhclient ens33 命令获取：</strong></p><p>效果立竿见影：</p><img src="/2023/10/17/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20231106094829938.png" class="" title="image-20231106094829938"><p>参考链接🔗：<a href="https://zhuanlan.zhihu.com/p/614401443">解决Linux 下使用 ifconfig 查看不到 ip 地址 - 知乎 (zhihu.com)</a></p><h1 id="python-版本切换"><a href="#python-版本切换" class="headerlink" title="python 版本切换"></a>python 版本切换</h1><p>使用update-alternatives 来为整个系统更改Python 版本</p><p><a href="https://blog.csdn.net/qq_43744723/article/details/122090500">Ubuntu下完美切换Python版，即设置系统默认的python版本(亲测有效)_ubuntu 切换python版本-CSDN博客</a></p><h1 id="配置、查看环境变量"><a href="#配置、查看环境变量" class="headerlink" title="配置、查看环境变量"></a>配置、查看环境变量</h1><p><a href="https://blog.csdn.net/white_idiot/article/details/78253004">【Ubuntu】Ubuntu设置和查看环境变量_ubuntu 环境变量-CSDN博客</a></p><h1 id="磁盘扩容"><a href="#磁盘扩容" class="headerlink" title="磁盘扩容"></a>磁盘扩容</h1><p><a href="https://blog.csdn.net/qq_45853229/article/details/124595300">Ubuntu磁盘扩容(简单亲测有效）_ubuntu扩展磁盘空间___乔木的博客-CSDN博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gem5模拟器学习（一）</title>
      <link href="/2023/10/17/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/10/17/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Gem5模拟器简介"><a href="#一、Gem5模拟器简介" class="headerlink" title="一、Gem5模拟器简介"></a>一、Gem5模拟器简介</h1><p>gem5是一个开源、模块化的时钟精确的全系统模拟器，应用于计算机体系结构研究。该模拟器可以对CPU、存储系统、片上互连系统、I&#x2F;O等系统组件进行详细的建模，并通过修改不同组件的具体实现和各个组件的配置参数可以灵活配置不同的计算系统。</p><span id="more"></span><h2 id="1-1-模拟组件"><a href="#1-1-模拟组件" class="headerlink" title="1.1 模拟组件"></a>1.1 模拟组件</h2><ul><li><p><strong>$\color[RGB]{0,150,255}{多种ISA}$</strong> ：gem5支持常见的各种指令集：X86、ARM、RISCV、SPARC、POWER、MIPS。不同的指令集包含了每条指令执行的完整过程。当前gem5中可用于全系统模拟的ISA主要有ARM、X86和RISCV；</p></li><li><p><strong>$\color[RGB]{0,150,255}{多种CPU模型}$</strong> ：gem5支持4种CPU模型：Simple、In-Order、Out-of-Order(简称O3)和KVM。每种CPU的具体实现和ISA不关联，因此CPU模型和ISA间可以任意搭配以组成多种计算机系统；</p></li><li><p><strong>$\color[RGB]{0,150,255}{Port  Interface}$</strong> ：该组件的主要功能是将系统中各个组件通过端口进行连接，屏蔽不同架构硬件实现细节，简化不同组件间的连接方式并增强系统通用性；</p></li><li><p><strong>$\color[RGB]{0,150,255}{Cache模型}$</strong> ：在gem5中支持Ruby和Classic Cache两种模型。</p></li><li><p><strong>Ruby存储模型</strong>:用户可以自定义不同Cache一致性协议，并对片上网络(Network-of-Chip, NoC)进行了详细建模；</p></li><li><p><strong>Classic存储模型</strong>: 支持硬编码的层次MOESI一致性协议</p></li><li><p><strong>$\color[RGB]{0,150,255}{DRAM模型}$</strong> ：gem5中的DRAM模型是事件驱动的，支持多种市面上常见的DRAM，如DDR3、DDR4、DDR5、GDDR、HMC、HBM等。在gem5中，DRAM模型不是时钟精确的，但是可以和时钟精确的DRAM模拟器DRAMSim3结合使用，gem5中提供了和DRAMSim连接的接口；</p></li><li><p><strong>$\color[RGB]{0,150,255}{GPU模型}$</strong> ：其GPU模型基于AMD的Graphic Core Next(GCN),是一种基于计算的时钟级GPU，支持多种异构系统的计算应用程序，不支持图形应用程序。一般都使用AMD的APU模拟器(基于gem5)对GPU进行模拟；</p></li><li><p><strong>$\color[RGB]{0,150,255}{I&#x2F;O设备}$</strong> ：支持常见的磁盘控制器、PCI、Ethernet等等，是进行全系统模拟必不可少的系统组件；</p></li><li><p><strong>$\color[RGB]{0,150,255}{丰富的接口}$</strong>  ：虽然gem5模拟器功能全面、配置灵活，但是在对各个组件进行建模的过程中，考虑复杂性和实现等方面因素，并不是对所有系统组件进行详细建模，因此配置了多种其他体系结构模拟器的结构，如SST、SystemC、DRAMSys、DRAMSim。</p></li></ul><h2 id="1-2-模拟模式"><a href="#1-2-模拟模式" class="headerlink" title="1.2 模拟模式"></a>1.2 模拟模式</h2><p>gem5支持两种系统模拟方式，一种是System Call Emulation(SE)，也叫系统调用模拟模式；另一种是Full System Simuluation(FS)，也叫全系统模拟模式。</p><ul><li><p>系统调用模拟模式 System Call Emulation(SE)</p></li><li><p>全系统模拟模式 Full System Simuluation(FS)</p></li></ul><h1 id="二、Gem5安装与测试"><a href="#二、Gem5安装与测试" class="headerlink" title="二、Gem5安装与测试"></a>二、Gem5安装与测试</h1><p>官网教程<a href="https://www.gem5.org/documentation/learning_gem5/part1/building/">gem5: Building gem5</a></p><h2 id="2-1-下载gem5源码"><a href="#2-1-下载gem5源码" class="headerlink" title="2.1 下载gem5源码"></a>2.1 下载gem5源码</h2><p>通过gitee网站下载源码，速度较快</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/koverlu/gem5.git</span><br></pre></td></tr></table></figure><h2 id="2-2-安装依赖"><a href="#2-2-安装依赖" class="headerlink" title="2.2 安装依赖"></a>2.2 安装依赖</h2><p>根据官网的安装命令一键安装全部依赖，主要包括git,gcc,python,protobuf,Boost</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential git m4 scons zlib1g zlib1g-dev \</span><br><span class="line">    libprotobuf-dev protobuf-compiler libprotoc-dev libgoogle-perftools-dev \</span><br><span class="line">    python3-dev python-is-python3 libboost-all-dev pkg-config</span><br></pre></td></tr></table></figure><h2 id="2-3-设置swap交换分区"><a href="#2-3-设置swap交换分区" class="headerlink" title="2.3 设置swap交换分区"></a>2.3 设置swap交换分区</h2><p>关于设置交换分区，读者可以自行百度或者看这篇博客<a href="https://www.vpsgo.com/linux-swap.html">Linux Swap交换分区设置教程</a>。简单说，Swap分区的作用就是在内存不够的情况下，操作系统先把内存中暂时不用的数据，存到硬盘的交换空间，腾出内存来让别的程序运行。而构建gem5环境是需要很大的内存，因此很需要通过交换分区来“扩大”内存。否则会因为内存补不足而报错如下：</p><img src="/2023/10/17/Gem5%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/image-20231025185902443.png" class="" title="error"><p>linux下设置swap分区的操作如下：</p><ul><li><p><strong>清空默认的Swap分区</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure></li><li><p><strong>创建分区文件并指定大小</strong></p><p>&#x2F;var&#x2F;swapfile是分区文件的位置，bs*count为文件大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dd if=/dev/zero of=/var/swapfile bs=1M count=10240</span><br></pre></td></tr></table></figure></li><li><p>格式化为Swap分区文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkswap /var/swapfile</span><br></pre></td></tr></table></figure></li><li><p>启动Swap分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo swapon /var/swapfile</span><br></pre></td></tr></table></figure></li><li><p>查看分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure><p>输出如下所示，分区创建成功，我的虚拟机设置的2GB内存+10GB分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu:~/Desktop/gem5$ free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:          1.9Gi       1.2Gi       116Mi        33Mi       567Mi       471Mi</span><br><span class="line">Swap:           9Gi       351Mi       9.7Gi</span><br></pre></td></tr></table></figure></li><li><p>设置开机启动</p><p>只需要在&#x2F;etc&#x2F;fstab中的末尾增加一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/swapfile swap swap defaults 0 0</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-4-编译gem5环境"><a href="#2-4-编译gem5环境" class="headerlink" title="2.4 编译gem5环境"></a>2.4 编译gem5环境</h2><p>下面创建一个简单的x86环境试一下，首先进入gem5目录，然后通过以下命令构建环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scons build/X86/gem5.opt -j[NumberOfThread]</span><br></pre></td></tr></table></figure><p>这里使用SCons构建工具，SCons使用当前目录和每个子目录的SConstruct文件查找和编译所有gem5源代码。</p><p>命令中build&#x2F;X86&#x2F;gem5.opt是构建环境的目标文件（opt后缀代表它是一个带有调试符号的优化二进制文件，其他后缀后面会介绍）。</p><p>[NumberOfThread]是用户期望该编译使用多少个线程进行编译，去掉-j 选项默认单线程，建议读者采用多线程编译，一般选为电脑 CPU 核数 - 1 最佳。</p><p>编译时间或许会有些长（我的破电脑跑了九九八十一天终于炼出来了）</p><p>出现以下log则表示模拟环境构建成功！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Checking for C header file Python.h... yes</span><br><span class="line">Checking for C library pthread... yes</span><br><span class="line">Checking for C library dl... yes</span><br><span class="line">Checking for C library util... yes</span><br><span class="line">Checking for C library m... yes</span><br><span class="line">Checking for C library python2.7... yes</span><br><span class="line">Checking for accept(0,0,0) in C++ library None... yes</span><br><span class="line">Checking for zlibVersion() in C++ library z... yes</span><br><span class="line">Checking for GOOGLE_PROTOBUF_VERIFY_VERSION in C++ library protobuf... yes</span><br><span class="line">Checking for clock_nanosleep(0,0,NULL,NULL) in C library None... yes</span><br><span class="line">Checking for timer_create(CLOCK_MONOTONIC, NULL, NULL) in C library None... no</span><br><span class="line">Checking for timer_create(CLOCK_MONOTONIC, NULL, NULL) in C library rt... yes</span><br><span class="line">Checking for C library tcmalloc... yes</span><br><span class="line">Checking for backtrace_symbols_fd((void*)0, 0, 0) in C library None... yes</span><br><span class="line">Checking for C header file fenv.h... yes</span><br><span class="line">Checking for C header file linux/kvm.h... yes</span><br><span class="line">Checking size of struct kvm_xsave ... yes</span><br><span class="line">Checking for member exclude_host in struct perf_event_attr...yes</span><br><span class="line">Building in /local.chinook/gem5/gem5-tutorial/gem5/build/X86</span><br><span class="line">Variables file /local.chinook/gem5/gem5-tutorial/gem5/build/variables/X86 not found,</span><br><span class="line">  using defaults in /local.chinook/gem5/gem5-tutorial/gem5/build_opts/X86</span><br><span class="line">scons: done reading SConscript files.</span><br><span class="line">scons: Building targets ...</span><br><span class="line"> [ISA DESC] X86/arch/x86/isa/main.isa -&gt; generated/inc.d</span><br><span class="line"> [NEW DEPS] X86/arch/x86/generated/inc.d -&gt; x86-deps</span><br><span class="line"> [ENVIRONS] x86-deps -&gt; x86-environs</span><br><span class="line"> [     CXX] X86/sim/main.cc -&gt; .o</span><br><span class="line"> ....</span><br><span class="line"> .... &lt;lots of output&gt;</span><br><span class="line"> ....</span><br><span class="line"> [   SHCXX] nomali/lib/mali_midgard.cc -&gt; .os</span><br><span class="line"> [   SHCXX] nomali/lib/mali_t6xx.cc -&gt; .os</span><br><span class="line"> [   SHCXX] nomali/lib/mali_t7xx.cc -&gt; .os</span><br><span class="line"> [      AR]  -&gt; drampower/libdrampower.a</span><br><span class="line"> [   SHCXX] nomali/lib/addrspace.cc -&gt; .os</span><br><span class="line"> [   SHCXX] nomali/lib/mmu.cc -&gt; .os</span><br><span class="line"> [  RANLIB]  -&gt; drampower/libdrampower.a</span><br><span class="line"> [   SHCXX] nomali/lib/nomali_api.cc -&gt; .os</span><br><span class="line"> [      AR]  -&gt; nomali/libnomali.a</span><br><span class="line"> [  RANLIB]  -&gt; nomali/libnomali.a</span><br><span class="line"> [     CXX] X86/base/date.cc -&gt; .o</span><br><span class="line"> [    LINK]  -&gt; X86/gem5.opt</span><br><span class="line">scons: done building targets. &lt;这个代表环境构建成功&gt;</span><br></pre></td></tr></table></figure><h2 id="2-5-测试gem5"><a href="#2-5-测试gem5" class="headerlink" title="2.5 测试gem5"></a>2.5 测试gem5</h2><p>环境构建成功以后，就可以根据官网的指南编写python配置文件进行系统模拟了。</p><p>这里借助官网提供的默认配置文件se.py进行配置，并运行hello world程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/X86/gem5.opt ./configs/example/se.py -c ./tests/test-progs/hello/bin/x86/linux/hello</span><br></pre></td></tr></table></figure><p>出现以下输出则表示模拟正确</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">gem5 Simulator System.  https://www.gem5.org</span><br><span class="line">gem5 is copyrighted software; use the --copyright option for details.</span><br><span class="line"></span><br><span class="line">gem5 version 22.1.0.0</span><br><span class="line">gem5 compiled Oct 24 2023 01:52:12</span><br><span class="line">gem5 started Oct 24 2023 02:00:27</span><br><span class="line">gem5 executing on ubuntu, pid 28261</span><br><span class="line">command line: ./build/X86/gem5.opt ./configs/example/se.py -c ./tests/test-progs/hello/bin/x86/linux/hello</span><br><span class="line"></span><br><span class="line">warn: The `get_runtime_isa` function is deprecated. Please migrate away from using this function.</span><br><span class="line">warn: The `get_runtime_isa` function is deprecated. Please migrate away from using this function.</span><br><span class="line">Global frequency set at 1000000000000 ticks per second</span><br><span class="line">warn: No dot file generated. Please install pydot to generate the dot file and pdf.</span><br><span class="line">build/X86/mem/dram_interface.cc:690: warn: DRAM device capacity (8192 Mbytes) does not match the address range assigned (512 Mbytes)</span><br><span class="line">0: system.remote_gdb: listening for remote gdb on port 7000</span><br><span class="line">**** REAL SIMULATION ****</span><br><span class="line">build/X86/sim/simulate.cc:192: info: Entering event queue @ 0.  Starting simulation...</span><br><span class="line">Hello world!</span><br><span class="line">Exiting @ tick 5985500 because exiting with last active thread context</span><br></pre></td></tr></table></figure><h1 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h1><p><a href="https://blog.csdn.net/qq_45726331/article/details/129757815?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-129757815-blog-128272972.235%5Ev38%5Epc_relevant_sort_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-129757815-blog-128272972.235%5Ev38%5Epc_relevant_sort_base2&utm_relevant_index=5">有关gem5模拟器的资料导航</a></p><p><a href="https://www.gem5.org/">Gem5官网</a></p><p><a href="https://www.gem5.org/documentation/learning_gem5/introduction/">Gem5官方学习向导</a></p><p><a href="https://mp.weixin.qq.com/s/VoPI0jbAERg8VK98oVff4Q">gem5学习笔记一：模拟器安装与使用 (qq.com)</a></p><p><a href="https://www.terapines.com/post/767/">兆松科技研发的基于gem5的模拟器zemu</a></p><p><a href="https://blog.csdn.net/qq_43381135/article/details/104371236">GEM5教程–gem5开始之旅（一）-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_46675545/category_12120503.html">Gem5模拟器_好啊啊啊啊的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/ivy_reny/category_6666068.html">gem5_ivy_reny的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/wyj7260/category_1301132.html">gem5_wyj7260的博客-CSDN博客</a></p><p>收集一下前辈们的踩坑记录</p><p><a href="https://zhuanlan.zhihu.com/p/412917633">gem5安装踩坑指南 - 知乎 (zhihu.com)</a></p><ul><li><p>报错 ImportError: No module named six</p><p>  通过pip 安装six模块即可 <code>pip install six</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Gem5模拟器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gem5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown常用语法</title>
      <link href="/2023/10/07/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/10/07/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>markdown是一种被广泛使用的轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，Markdown文件的后缀名是“.md”。</p><h1 id="修改文字颜色"><a href="#修改文字颜色" class="headerlink" title="修改文字颜色"></a>修改文字颜色</h1><p>默认字体颜色自然是黑色啦，想要修改字体颜色有两种方法</p><span id="more"></span><h2 id="1-html格式"><a href="#1-html格式" class="headerlink" title="1. html格式"></a>1. html格式</h2><h3 id="（1）英文单词指示颜色"><a href="#（1）英文单词指示颜色" class="headerlink" title="（1）英文单词指示颜色"></a>（1）英文单词指示颜色</h3><p>可以通过html的各种英文颜色名来使用颜色</p><p><a href="https://www.runoob.com/html/html-colornames.html">HTML 颜色名</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color=&#x27;red&#x27;&gt;文本&lt;/font&gt;</span><br></pre></td></tr></table></figure><h3 id="（2）RGB指示颜色"><a href="#（2）RGB指示颜色" class="headerlink" title="（2）RGB指示颜色"></a>（2）RGB指示颜色</h3><p>RGB颜色格式：$#RRGGBB$，RGB均用16进制数字表示</p><p>其中两个R代表了红色光，两个G代表了绿色光，两个B代表了蓝色光</p><p>如$#FF0000$代表了255份红色光，0份绿色光和0份蓝色光。</p><p><a href="http://www.yini.org/liuyan/rgbcolor.htm">RGB颜色表</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color=#FF0000&gt;文本&lt;/font&gt;</span><br></pre></td></tr></table></figure><h3 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h3><p><font color='red'>我是红色</font></p><p><font color=#119966>我是#119966</font></p><h2 id="2-通过LaTeX内联公式"><a href="#2-通过LaTeX内联公式" class="headerlink" title="2. 通过LaTeX内联公式"></a>2. 通过LaTeX内联公式</h2><h3 id="（1）英文单词指示颜色-1"><a href="#（1）英文单词指示颜色-1" class="headerlink" title="（1）英文单词指示颜色"></a>（1）英文单词指示颜色</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$\textcolor&#123;Blue&#125;&#123;文本&#125;$</span><br><span class="line">或者简写为</span><br><span class="line">$\color&#123;Blue&#125;&#123;文本&#125;$</span><br></pre></td></tr></table></figure><p>$ \color{Blue}{文本} \mu $</p><h3 id="（2）RGB指示颜色-1"><a href="#（2）RGB指示颜色-1" class="headerlink" title="（2）RGB指示颜色"></a>（2）RGB指示颜色</h3><p>有两种通过RGB指示颜色的语法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$\textcolor[rgb]&#123;r,g,b&#125;&#123;文本&#125;$</span><br><span class="line">其中&#123;r,g,b&#125;代表red、green和blue三种颜色的组合，取值范围为[0-1]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$\textcolor[RGB]&#123;R,G,B&#125;&#123;文本&#125;$</span><br><span class="line">其中&#123;R,G,B&#125;代表red、green和blue三种颜色的组合，取值范围为[0-255]</span><br></pre></td></tr></table></figure><p>$$<br>\textcolor[RGB]{0,0,255}{文本}<br>$$</p><p>$\textcolor[RGB]{0,0,255}{文本}$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo上传图片</title>
      <link href="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
      <url>/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>Hexo网站已经搭建好了，我们可以开始愉快地写博客了！</p><h2 id="1-Typora编辑器"><a href="#1-Typora编辑器" class="headerlink" title="1. Typora编辑器"></a>1. Typora编辑器</h2><p>Typora是一种markdown语言的常用编辑器，这个软件的方便之处在于可以直接将markdown语法呈现出其效果，并且集成了许多有用的工具，是编辑markdown的不二之选。</p><p><a href="https://typora.io/">Typora官网</a></p><hr><h2 id="2-Hexo插入本地图片遇到的问题"><a href="#2-Hexo插入本地图片遇到的问题" class="headerlink" title="2. Hexo插入本地图片遇到的问题"></a>2. Hexo插入本地图片遇到的问题</h2><p>markdown的图片插入语法为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片描述](图片路径)</span><br></pre></td></tr></table></figure><p>如果使用Typora，可以直接将图片复制粘贴在想要放置的位置，十分方便</p><p>当我们将图片直接复制到Typora中时，会出现图片可以在markdown中显示，但却无法在网页中显示的问题。</p><span id="more"></span><p><img src="/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007210728956.png" alt="图一：Typora视角"></p><p><img src="/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007210809543.png" alt="图二：网页视角"></p><hr><h2 id="3-将本地图片上传至Github"><a href="#3-将本地图片上传至Github" class="headerlink" title="3. 将本地图片上传至Github"></a>3. 将本地图片上传至Github</h2><p>这其实很好理解，因为使用的图片还在你的本地，markdown语法也使用的是本地路径（如图三），而静态网页不可能在你电脑本地找图片，所以需要我们将图片也一起上传。</p><p><img src="/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007205825905.png" alt="图三：我从微信直接复制粘贴到Typora的一张图片"></p><p>上传图片等资源十分简单，只需要在Hexo的配置文件_config.yml里将post_asset_folder这一个选项配置从false更改为true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>于是每当你新建一个博客时，Hexo会自动在相同目录建立一个同名的资源文件夹，只需要将图片放到资源文件夹中，然会在markdown中通过相对路径找到图片就可以啦！</p><p>然而，每次在博客中添加图片还要手动放到资源文件夹中，然后再用语法![]()去描述图片，实在是麻烦！</p><p>好在我们可以使用Typora中的工具，依次在Typora中进入文件-&gt;偏好设置-&gt;图像，然后在插入图片时选择复制到指定路径，也就是那个在同目录下同名的资源文件夹.&#x2F;&amp;{filename}，并勾选</p><ul><li><p>对本地位置的图片应用上述规则</p></li><li><p>对网络位置的图片应用上述规则</p></li><li><p>优先使用相对路径</p></li></ul><p>建议都勾选上，至少要勾选上第一项</p><p><img src="/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007211935125.png" alt="图四"></p><img src="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007212121607.png" class="" title="图五"><p>于是，复制粘贴过来的图片就可以自动保存在资源文件夹中，并且也自动将图片路径指向了资源文件夹中的这张图片，真方便！</p><img src="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007212607249.png" class="" title="图六"><img src="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231007212643086.png" class="" title="图七"><p>当我满心欢喜地将博客部署到Github上时，却发现还是和图二一样没法显示</p><p>这是问什么呢？！</p><hr><h2 id="4-Hexo显示图像语法"><a href="#4-Hexo显示图像语法" class="headerlink" title="4. Hexo显示图像语法"></a>4. Hexo显示图像语法</h2><p>翻阅Hexo<a href="https://hexo.io/zh-cn/docs/asset-folders#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%BC%95%E7%94%A8%E7%9A%84%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6">官方教程之后</a>，才发现Hexo并不可以直接将markdown显示图片的![]()语法在网页中显示图片，而必须使用以下图像标签插件来插入图片，否则图片会路径错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure><p>在markdown中编辑如下代码之后，卡比终于能在网页上出现了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img c0229a294ce2c67e2ba3d44298fcb98.jpg [我正在学习，请不要打扰] %&#125;</span><br></pre></td></tr></table></figure><img src="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231008110447546.png" class="" title="图八：使用Hexo插入图片语法——在页面中的视角"><p>然而，这种插入图片的Hexo语法不仅较为繁琐，而且在编辑的时候还不可以在编辑器里即时查看图片，这十分不方便。。</p><img src="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231008110647937.png" class="" title="图九：使用Hexo插入图片语法——在编辑器中的视角"><p>至此，我们现在有了两种都不完美的插入图片的方法</p><ol><li>使用markdown语法，好处是可以很方便地插入图片，而且可以享受实时预览图片，但坏处是根本因为路径问题无法在网页显示图片。</li><li>使用Hexo语法，可以在网页显示图片，但每插入一张图片需要手动编辑图片代码，还要手动把图片放进资源文件夹，还不能实时预览。</li></ol><p>既然如此，我们可不可以将两种方法结合起来，实现无痛插入图片的梦想？</p><p>使用Hexo的插件就可以实现！</p><hr><h2 id="5-Hexo插件实现无痛插入图片"><a href="#5-Hexo插件实现无痛插入图片" class="headerlink" title="5. Hexo插件实现无痛插入图片"></a>5. Hexo插件实现无痛插入图片</h2><p><a href="https://github.com/xcodebuild/hexo-asset-image">hexo-asset-img</a>插件可以在文章编译为html之前，自动地将markdown的图片语法自动转换成Hexo的图片语法，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![example](blogname/example.jpg) --&gt; &#123;% asset_img example.jpg example %&#125;</span><br></pre></td></tr></table></figure><p>hexo-asset-img的安装命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>ps.或者可以使用以下命令安装，安装后删除node_modules文件夹中的hexo-asset-image文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure><p>pps.有不少教程安装了 hexo-asset-image 包，但我电脑上不行，踩了一天坑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>安装好插件后，还需要在Hexo的配置文件_config.yml里加入两个配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure><p>如此，就可以在网页上看到插入的图片了！</p><img src="/2023/10/07/Hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231008123837571.png" class="" title="图十：博客中插入本地图片效果图"><hr><h2 id="6-全部步骤"><a href="#6-全部步骤" class="headerlink" title="6. 全部步骤"></a>6. 全部步骤</h2><ol><li><p>安装Typora编辑器</p></li><li><p>在Typora中进入文件-&gt;偏好设置-&gt;图像，在插入图片时选择复制到指定路径，也就是那个在同目录下同名的资源文件夹.&#x2F;&amp;{filename}，并勾选</p><ul><li><p>对本地位置的图片应用上述规则</p></li><li><p>对网络位置的图片应用上述规则</p></li><li><p>优先使用相对路径</p></li></ul></li><li><p>通过以下命令安装插件hexo-asset-img</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure></li><li><p>在Hexo的配置文件_config.yml里将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>这个配置项由false改为ture</p><p>并加入以下两个配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="7-最终效果"><a href="#7-最终效果" class="headerlink" title="7. 最终效果"></a>7. 最终效果</h2><p>经过以上操作，我们以后就在Hexo博客中很方便地插入本地图片啦。</p><p>只需要将图片直接复制粘贴到Typora编辑器中，图片就会自动保存在资源文件夹中，并通过正确的路径保存，同时还可以支持编辑过程中的实时预览！</p><p>ps：有对于图片如何添加题注感兴趣的小伙伴可以看这篇博客</p><p><a href="https://blog.csdn.net/Lincain/article/details/89892249">Markdown 图片居中并添加标题_markdown图片标题-CSDN博客</a></p><p>参考链接🔗：</p><ul><li><p><a href="https://moeci.com/posts/hexo-typora/">Hexo + Typora + 开发Hexo插件 解决图片路径不一致 | yiyun’s Blog (moeci.com)</a></p></li><li><p><a href="http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/">hexo中完美插入本地图片 | ETRD</a></p></li><li><p><a href="https://hexo.io/zh-cn/docs/asset-folders">资源文件夹 | Hexo</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 插入图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络配置</title>
      <link href="/2023/10/05/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/10/05/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-ifconfig（Linux）-ipconfig（windows）"><a href="#1-ifconfig（Linux）-ipconfig（windows）" class="headerlink" title="1. ifconfig（Linux） &#x2F; ipconfig（windows）"></a>1. ifconfig（Linux） &#x2F; ipconfig（windows）</h2><p>作用：用于查看网卡配置信息</p><p>如IPV4地址、IPV6地址、工作状态、网络类型</p><p>参考博客：<a href="https://blog.csdn.net/l_liangkk/article/details/114959914">查看网卡信息：ifconfig命令及详细介绍_ifconfig ether_-纸短情长的博客-CSDN博客</a> </p><p><img src="/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20231007104602303.png" alt="image-20231007104602303"></p><h2 id="Ubuntu网络图标消失"><a href="#Ubuntu网络图标消失" class="headerlink" title="Ubuntu网络图标消失"></a>Ubuntu网络图标消失</h2><p>[Ubuntu 虚拟机没有网络图标（连接不上网络）_ubuntu没有网络图标_快乐科研喵的博客-CSDN博客](<a href="https://blog.csdn.net/qq_53089817/article/details/119490128#:~:text=%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9A">https://blog.csdn.net/qq_53089817/article/details/119490128#:~:text=解决方法：</a> 1、先关闭当前的虚拟机。 2、选择虚拟机设置查看网络配置是否正确（选择NAT连接）。 点击确定。,3、选择菜单编辑的虚拟网络编辑器。 选择NAT模式后 点击更改设置。 4、最后重启Ubuntu系统就有网络图标了。)</p><p><a href="https://blog.csdn.net/aggie4628/article/details/125765055">ubuntu-22.04无法连接网络-sudo service network-manager stop说不行-CSDN博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo网站搭建教程</title>
      <link href="/2023/09/26/Hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
      <url>/2023/09/26/Hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果</p><p>你也可以像我一样</p><p>拥有一篇属于你自己的Hexo框架博客网站</p><p>那我觉得</p><p>这件事情</p><p>泰酷辣！！！！！！！！！</p><p><img src="/Hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/1684920495319.png" alt="泰裤辣"></p></blockquote><hr><p>这是一个手把手教你如何搭建一个属于你自己的Hexo框架博客网站的教程</p><hr><h2 id="第一节-Hexo简介"><a href="#第一节-Hexo简介" class="headerlink" title="第一节  Hexo简介"></a>第一节  Hexo简介</h2><p>Hexo是一款基于Node.js的静态博客框架，Hexo 使用 <a href="https://link.zhihu.com/?target=http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，可以方便地生成静态网页，并托管在GitHub和Gitee上，是搭建博客的首选框架，让你实现在不用购买云服务器的情况下拥有一个属于自己的博客网站的梦想。</p><span id="more"></span><hr><h2 id="第二节-前期准备"><a href="#第二节-前期准备" class="headerlink" title="第二节 前期准备"></a>第二节 前期准备</h2><p>在安装Hexo之前，需要安装Node.js</p><p>进一步想要将Hexo部署到Github或Gitee上，还必须通过Git</p><h3 id="2-1-安装Node-js"><a href="#2-1-安装Node-js" class="headerlink" title="2.1 安装Node.js"></a>2.1 安装Node.js</h3><ul><li>Windows：</li></ul><p>在官网下载LTS版本（下载nodejs自带npm）</p><p><img src="/Hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/image-20231003193554011.png" alt="image-20231003193554011"></p><p>官网下载地址：<a href="https://nodejs.org/en">Node.js (nodejs.org)</a></p><ul><li>Linux</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><p>安装成功验证：</p><p>在命令行中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>能够顺利输出node和npm的版本号即可</p><h3 id="2-2-安装git"><a href="#2-2-安装git" class="headerlink" title="2.2 安装git"></a>2.2 安装git</h3><ul><li><p>Windows</p><p>点击Git官网下载安装包，然后按Wizard安装即可</p></li></ul><ul><li><p>Linux (Ubuntu, Debian)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git-core</span><br></pre></td></tr></table></figure></li><li><p>Linux (Fedora, Red Hat, CentOS)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install git-core</span><br></pre></td></tr></table></figure></li></ul><p>git -v查看版本，验证是否安装成功</p><h3 id="2-3-安装Hexo"><a href="#2-3-安装Hexo" class="headerlink" title="2.3 安装Hexo"></a>2.3 安装Hexo</h3><p>通过npm可以直接安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>hexo -v查看版本，验证是否安装成功</p><hr><h2 id="第三节-搭建本地静态博客"><a href="#第三节-搭建本地静态博客" class="headerlink" title="第三节 搭建本地静态博客"></a>第三节 搭建本地静态博客</h2><h3 id="3-1-初始化Hexo博客框架"><a href="#3-1-初始化Hexo博客框架" class="headerlink" title="3.1  初始化Hexo博客框架"></a>3.1  初始化Hexo博客框架</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2-进入新建的文件夹，安装一下npm"><a href="#3-2-进入新建的文件夹，安装一下npm" class="headerlink" title="3.2  进入新建的文件夹，安装一下npm"></a>3.2  进入新建的文件夹，安装一下npm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><ul><li><p>npm install 更新可能会较慢，如果失败，可以尝试配置npm代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//  配置nmp代理来提高速度，如设置淘宝镜像</span><br><span class="line">npm config set registry https://registry.npm.taobao.org </span><br><span class="line"></span><br><span class="line">// 查看配置是否成功</span><br><span class="line">npm config get registry </span><br><span class="line"></span><br><span class="line">// 成功后重新npm install安装</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li></ul><p>进入文件夹后，目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p><strong>_config.yml</strong></p><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p><p><strong>package.json</strong></p><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> 渲染引擎 已默认安装，您可以自由移除。</p><p><strong>scaffolds</strong></p><p><a href="https://hexo.io/zh-cn/docs/writing#%E6%A8%A1%E7%89%88%EF%BC%88Scaffold%EF%BC%89">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来创建文件。</p><p>Hexo 的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改 <code>scaffold/post.md</code> 中的 Front-matter 内容，那么每次新建一篇文章时都会包含这个修改。</p><p><strong>source</strong></p><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p><p><strong>themes</strong></p><p><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p><h3 id="3-3-生成静态博客网站"><a href="#3-3-生成静态博客网站" class="headerlink" title="3.3  生成静态博客网站"></a>3.3  生成静态博客网站</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><h3 id="3-4-启动服务器"><a href="#3-4-启动服务器" class="headerlink" title="3.4  启动服务器"></a>3.4  启动服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>默认情况下，访问网址为：<a href="http://localhost:4000/%EF%BC%8C%E8%AE%BF%E9%97%AE%E8%BF%99%E4%B8%AA%E6%9C%AC%E5%9C%B0%E7%BD%91%E5%9D%80%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E8%87%AA%E5%B7%B1%E7%94%9F%E6%88%90%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99">http://localhost:4000/，访问这个本地网址就可以看到自己生成的博客网站</a></p><hr><h2 id="第四节-将博客部署到Github"><a href="#第四节-将博客部署到Github" class="headerlink" title="第四节 将博客部署到Github"></a>第四节 将博客部署到Github</h2><p>生成的博客网站只能在自己电脑本地访问当然没意思，所以接下来看看如何把写好的博客部署到Github Pages上。</p><h5 id="GitHub-Pages-是什么"><a href="#GitHub-Pages-是什么" class="headerlink" title="GitHub Pages 是什么?"></a>GitHub Pages 是什么?</h5><ul><li><a href="https://link.zhihu.com/?target=https://help.github.com/en/articles/what-is-github-pages">What is GitHub Pages? - GitHub Help</a></li></ul><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。</p><h5 id="Hexo-Github-Pages-发布博客原理"><a href="#Hexo-Github-Pages-发布博客原理" class="headerlink" title="Hexo + Github Pages 发布博客原理"></a>Hexo + Github Pages 发布博客原理</h5><p>在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 上完成博文的发布。</p><p>下面看看怎么实现</p><h3 id="4-1-Github创建个人仓库"><a href="#4-1-Github创建个人仓库" class="headerlink" title="4.1 Github创建个人仓库"></a>4.1 Github创建个人仓库</h3><p>点击New repository，开始新建仓库</p><p>新仓库的名字有固定格式要求，否组无法建站</p><p>格式为：用户名 + .github.oi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repository name eg.     yourusername.github.oi</span><br></pre></td></tr></table></figure><h3 id="4-2-安装hexo上传插件"><a href="#4-2-安装hexo上传插件" class="headerlink" title="4.2 安装hexo上传插件"></a>4.2 安装hexo上传插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="4-3-修改hexo配置文件指定仓库路径"><a href="#4-3-修改hexo配置文件指定仓库路径" class="headerlink" title="4.3 修改hexo配置文件指定仓库路径"></a>4.3 修改hexo配置文件指定仓库路径</h3><p>打开文件夹中的_config.yml文件，在文件最下面的Deployment部分修改配置</p><ol><li>type项填入”git”</li><li>repo项填入你的仓库的https或者ssh地址（点开仓库主页那个绿色的Code就能看到）</li><li>branch项填入你的仓库的分支名</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line"> type: git</span><br><span class="line"> repo: 你的仓库的https或者ssh地址</span><br><span class="line"> branch: &lt;你的仓库的分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="4-4-部署博客到Github"><a href="#4-4-部署博客到Github" class="headerlink" title="4.4 部署博客到Github"></a>4.4 部署博客到Github</h3><p>部署命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>部署完成后，可以在仓库主页的Deployment</p><hr><h2 id="第五节-常用命令"><a href="#第五节-常用命令" class="headerlink" title="第五节 常用命令"></a>第五节 常用命令</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a><font color=#0080ff>new</font></h3><p>新建一个博客。执行以下命令后，会在blog&#x2F;source&#x2F;_posts&#x2F;文件夹中新建一个同名的博客文件（.md格式）。通过设置tags字段还可以给这个文章添加标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;博客名称&quot;</span><br></pre></td></tr></table></figure><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a><font color=#0080ff>clean</font></h3><p>清除缓存文件（db.json）和已经生成的静态博客文件（public文件夹下的内容）.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a><font color=#0080ff>generate</font></h3><p>生成静态博客</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">简写为:hexo g</span><br></pre></td></tr></table></figure><p><font color=#0080ff>server</font></p><p>启动本地的博客服务器。默认情况下，访问网址为：<code>http://localhost:4000/</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line">简写为:hexo s</span><br></pre></td></tr></table></figure><p><font color=#0080ff>deploy</font></p><p>在相应的网站服务器（一般是Github或Gitee）中部署博客</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">简写为:hexo d</span><br></pre></td></tr></table></figure><hr><h2 id="第六节-访问网站"><a href="#第六节-访问网站" class="headerlink" title="第六节 访问网站"></a>第六节 访问网站</h2><p>部署在Github后的默认网站url为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://你的用户名.github.io/</span><br></pre></td></tr></table></figure><p>如果能成功访问，那么恭喜！你已经成功部署了一个属于自己的博客网站！</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
